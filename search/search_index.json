{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"BitBully: A fast and perfect-playing Connect-4 Agent for Python 3 &amp; C/C++","text":"<p>BitBully is a high-performance Connect-4 solver built using C++ and Python bindings, leveraging advanced algorithms and optimized bitwise operations. It provides tools for solving and analyzing Connect-4 games efficiently, designed for both developers and researchers.</p>"},{"location":"bitbully_core/","title":"bitbully_core","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core","title":"bitbully_core","text":"<p>Low-level pybind11 bindings for BitBully (Connect-4 solver).</p> <p>This module exposes the core C++ engine via pybind11. It provides:</p> <ul> <li>class BoardCore: Fast bitboard-based Connect-4 position representation.</li> <li>class BitBullyCore : Perfect-play solver (MTD(f), negamax, null-window) with optional opening book.</li> <li>class OpeningBookCore: Opening book reader / lookup helper.</li> <li>enum Player: Player enum used by the engine.</li> <li>data N_COLUMNS, data N_ROWS: Board dimensions (standard Connect-4: 7x6).</li> </ul> Notes <p>These APIs are low-level and mirror the underlying C++ engine closely. Most users should prefer the high-level Python wrapper (e.g. <code>bitbully.Board</code>, <code>bitbully.BitBully</code>) unless they need maximum control or performance.</p> Example <p>Create a board, score moves, and pick a best move: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nassert board.play(\"334411\")\nassert isinstance(str(board), str) and str(board) != \"\"\n\nsolver = bbc.BitBullyCore()\nscores = solver.scoreMoves(board)\n\n# One score per column.\nassert len(scores) == 7\n\n# Pick best column by score (ties resolved by first max).\nbest_col = max(range(7), key=scores.__getitem__)\nassert 0 &lt;= best_col &lt; 7\n</code></pre></p> <p>Classes:</p> Name Description <code>BitBullyCore</code> <p>Perfect-play Connect-4 solver implemented in C++.</p> <code>BoardCore</code> <p>Low-level Connect-4 board representation (bitboard-based).</p> <code>OpeningBookCore</code> <p>Opening book reader and lookup helper.</p> <code>Player</code> <p>Player identifiers used by the engine.</p> <p>Attributes:</p> Name Type Description <code>N_COLUMNS</code> <code>int</code> <p>Number of columns of the standard Connect-4 board (7).</p> <code>N_ROWS</code> <code>int</code> <p>Number of rows of the standard Connect-4 board (6).</p>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.N_COLUMNS","title":"N_COLUMNS  <code>module-attribute</code>","text":"<pre><code>N_COLUMNS: int\n</code></pre> <p>Number of columns of the standard Connect-4 board (7).</p> Example <p>Read the board dimensions: <pre><code>import bitbully.bitbully_core as bbc\n\nassert bbc.N_COLUMNS == 7\nassert bbc.N_ROWS == 6\n</code></pre></p> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0bitbully_core </li> </ul> Used by: <ul> <li> BitBully API Reference <code></code>\u00a0board <code></code>\u00a0Board <code></code>\u00a0N_COLUMNS </li> </ul>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.N_ROWS","title":"N_ROWS  <code>module-attribute</code>","text":"<pre><code>N_ROWS: int\n</code></pre> <p>Number of rows of the standard Connect-4 board (6).</p> Example <p>Read the board dimensions: <pre><code>import bitbully.bitbully_core as bbc\n\nassert bbc.N_COLUMNS == 7\nassert bbc.N_ROWS == 6\n</code></pre></p> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0bitbully_core </li> </ul> Used by: <ul> <li> BitBully API Reference <code></code>\u00a0board <code></code>\u00a0Board <code></code>\u00a0N_ROWS </li> </ul>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__: list[str] = ['N_COLUMNS', 'N_ROWS', 'BitBullyCore', 'BoardCore', 'OpeningBookCore', 'Player']\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore","title":"BitBullyCore","text":"<p>Perfect-play Connect-4 solver implemented in C++.</p> <p>The solver evaluates positions from the perspective of the side to move. It supports multiple search methods and optional opening-book acceleration.</p> Notes <ul> <li>Column indices are 0..6 (left to right).</li> <li>Scores are engine-defined integers; higher is better for the player to move.</li> <li>When an opening book is loaded, early-game positions can be evaluated in   constant time.</li> </ul> Example <p>Score all legal moves in a position: <pre><code>import bitbully.bitbully_core as bbc\nimport bitbully_databases as bbd\ndb_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\nboard = bbc.BoardCore()\nassert board.play(6 * \"3\")\n\nsolver = bbc.BitBullyCore(db_path)\nscores = solver.scoreMoves(board)\n\n# Scores has length 7 (one per column).\nassert len(scores) == 7\n\n# Pick best column by score.\nbest_col = max(range(7), key=scores.__getitem__)\nprint(\"Best column:\", best_col)\n</code></pre> Expected output: <pre><code>    Best column: 2\n</code></pre></p> Referenced by: <ul> <li> BitBully API Reference <ul> <li> <code></code>\u00a0bitbully_core </li> <li> <code></code>\u00a0solver <code></code>\u00a0BitBully </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>getNodeCounter</code> <p>Return the number of visited nodes since the last reset.</p> <code>isBookLoaded</code> <p>Return whether an opening book is currently loaded.</p> <code>loadBook</code> <p>Load an opening book from a file path.</p> <code>mtdf</code> <p>Evaluate a position using the MTD(f) algorithm.</p> <code>negamax</code> <p>Evaluate a position using negamax (alpha-beta) search.</p> <code>nullWindow</code> <p>Evaluate a position using a null-window search.</p> <code>resetBook</code> <p>Unload the currently loaded opening book (if any).</p> <code>resetNodeCounter</code> <p>Reset the internal node counter.</p> <code>resetTranspositionTable</code> <p>Clear the internal transposition table.</p> <code>scoreMove</code> <p>Evaluate a single move in the given position.</p> <code>scoreMoves</code> <p>Evaluate all columns (0..6) in the given position.</p>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.getNodeCounter","title":"getNodeCounter","text":"<pre><code>getNodeCounter() -&gt; int\n</code></pre> <p>Return the number of visited nodes since the last reset.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of search nodes visited since the last call to BitBullyCore.resetNodeCounter.</p> Example <p>Count how many nodes a search visited: <pre><code>import bitbully.bitbully_core as bbc\n\nsolver = bbc.BitBullyCore()\nboard = bbc.BoardCore()\nassert board.play(\"333331111555\")\nassert solver.getNodeCounter() == 0\n\n_ = solver.mtdf(board, first_guess=0)\nassert solver.getNodeCounter() &gt; 0\n\nsolver.resetNodeCounter()\nassert solver.getNodeCounter() == 0\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def getNodeCounter(self) -&gt; int:\n    \"\"\"Return the number of visited nodes since the last reset.\n\n    Returns:\n        int: Number of search nodes visited since the last call to\n            [BitBullyCore.resetNodeCounter][src.bitbully.bitbully_core.BitBullyCore.resetNodeCounter].\n\n    Example:\n        Count how many nodes a search visited:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        solver = bbc.BitBullyCore()\n        board = bbc.BoardCore()\n        assert board.play(\"333331111555\")\n        assert solver.getNodeCounter() == 0\n\n        _ = solver.mtdf(board, first_guess=0)\n        assert solver.getNodeCounter() &gt; 0\n\n        solver.resetNodeCounter()\n        assert solver.getNodeCounter() == 0\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.isBookLoaded","title":"isBookLoaded","text":"<pre><code>isBookLoaded() -&gt; bool\n</code></pre> <p>Return whether an opening book is currently loaded.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if a book is loaded, otherwise <code>False</code>.</p> Example <p>Check if the solver currently uses an opening book: <pre><code>import bitbully.bitbully_core as bbc\n\nsolver = bbc.BitBullyCore()\nassert solver.isBookLoaded() is False\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def isBookLoaded(self) -&gt; bool:\n    \"\"\"Return whether an opening book is currently loaded.\n\n    Returns:\n        bool: ``True`` if a book is loaded, otherwise ``False``.\n\n    Example:\n        Check if the solver currently uses an opening book:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        solver = bbc.BitBullyCore()\n        assert solver.isBookLoaded() is False\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.loadBook","title":"loadBook","text":"<pre><code>loadBook(bookPath: PathLike[str] | str = ...) -&gt; bool\n</code></pre> <p>Load an opening book from a file path.</p> <p>Parameters:</p> Name Type Description Default <code>PathLike[str] | str</code> <p>Path to the opening book file.</p> <code>...</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the book was loaded successfully, otherwise <code>False</code>.</p> Example <p>Load a book and verify it is active: <pre><code>import bitbully.bitbully_core as bbc\nimport bitbully_databases as bbd\ndb_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\nsolver = bbc.BitBullyCore()\nok = solver.loadBook(db_path)  # replace with your file\nif ok:\n    assert solver.isBookLoaded() is True\n</code></pre></p> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0solver <code></code>\u00a0BitBully <code></code>\u00a0load_book </li> </ul> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def loadBook(self, bookPath: os.PathLike[str] | str = ...) -&gt; bool:\n    \"\"\"Load an opening book from a file path.\n\n    Args:\n        bookPath (os.PathLike[str] | str): Path to the opening book file.\n\n    Returns:\n        bool: ``True`` if the book was loaded successfully, otherwise ``False``.\n\n    Example:\n        Load a book and verify it is active:\n        ```python\n        import bitbully.bitbully_core as bbc\n        import bitbully_databases as bbd\n        db_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\n        solver = bbc.BitBullyCore()\n        ok = solver.loadBook(db_path)  # replace with your file\n        if ok:\n            assert solver.isBookLoaded() is True\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.loadBook(bookPath)","title":"<code>bookPath</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.mtdf","title":"mtdf","text":"<pre><code>mtdf(board: BoardCore, first_guess: int) -&gt; int\n</code></pre> <p>Evaluate a position using the MTD(f) algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>BoardCore</code> <p>Position to evaluate.</p> required <code>int</code> <p>Initial guess for the score (often 0).</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Evaluation score for the side to move.</p> Example <p>Evaluate a position using MTD(f) (six moves in the center column): <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nfor _ in range(6):\n    assert board.play(3)\n\nsolver = bbc.BitBullyCore()\nscore = solver.mtdf(board, first_guess=0)\nprint(\"MTD(f) score:\", score)\n\nassert isinstance(score, int)\nassert solver.getNodeCounter() &gt; 0\n</code></pre> Expected output: <pre><code>    MTD(f) score: 1\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def mtdf(self, board: \"BoardCore\", first_guess: int) -&gt; int:\n    \"\"\"Evaluate a position using the MTD(f) algorithm.\n\n    Args:\n        board (BoardCore): Position to evaluate.\n        first_guess (int): Initial guess for the score (often 0).\n\n    Returns:\n        int: Evaluation score for the side to move.\n\n    Example:\n        Evaluate a position using MTD(f) (six moves in the center column):\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        for _ in range(6):\n            assert board.play(3)\n\n        solver = bbc.BitBullyCore()\n        score = solver.mtdf(board, first_guess=0)\n        print(\"MTD(f) score:\", score)\n\n        assert isinstance(score, int)\n        assert solver.getNodeCounter() &gt; 0\n        ```\n        Expected output:\n        ```text\n            MTD(f) score: 1\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.mtdf(board)","title":"<code>board</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.mtdf(first_guess)","title":"<code>first_guess</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.negamax","title":"negamax","text":"<pre><code>negamax(board: BoardCore, alpha: int, beta: int, depth: int) -&gt; int\n</code></pre> <p>Evaluate a position using negamax (alpha-beta) search.</p> <p>Parameters:</p> Name Type Description Default <code>BoardCore</code> <p>Position to evaluate.</p> required <code>int</code> <p>Alpha bound.</p> required <code>int</code> <p>Beta bound.</p> required <code>int</code> <p>Search depth in plies.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Evaluation score for the side to move.</p> Example <p>Run a negamax call with an alpha-beta window: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nassert board.play(\"334411\")\n\nsolver = bbc.BitBullyCore()\nscore = solver.negamax(board, alpha=-1000, beta=1000, depth=0)\nprint(\"Negamax score:\", score)\n</code></pre> Expected output: <pre><code>    Negamax score: 18\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def negamax(self, board: \"BoardCore\", alpha: int, beta: int, depth: int) -&gt; int:\n    \"\"\"Evaluate a position using negamax (alpha-beta) search.\n\n    Args:\n        board (BoardCore): Position to evaluate.\n        alpha (int): Alpha bound.\n        beta (int): Beta bound.\n        depth (int): Search depth in plies.\n\n    Returns:\n        int: Evaluation score for the side to move.\n\n    Example:\n        Run a negamax call with an alpha-beta window:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        assert board.play(\"334411\")\n\n        solver = bbc.BitBullyCore()\n        score = solver.negamax(board, alpha=-1000, beta=1000, depth=0)\n        print(\"Negamax score:\", score)\n        ```\n        Expected output:\n        ```text\n            Negamax score: 18\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.negamax(board)","title":"<code>board</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.negamax(alpha)","title":"<code>alpha</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.negamax(beta)","title":"<code>beta</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.negamax(depth)","title":"<code>depth</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.nullWindow","title":"nullWindow","text":"<pre><code>nullWindow(board: BoardCore) -&gt; int\n</code></pre> <p>Evaluate a position using a null-window search.</p> <p>Parameters:</p> Name Type Description Default <code>BoardCore</code> <p>Position to evaluate.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Evaluation score for the side to move.</p> Example <p>Use null-window search: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nassert board.play(\"334411\")\n\nsolver = bbc.BitBullyCore()\nscore = solver.nullWindow(board)\nprint(\"Null-window score:\", score)\n</code></pre> Expected output: <pre><code>    Null-window score: 18\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def nullWindow(self, board: \"BoardCore\") -&gt; int:\n    \"\"\"Evaluate a position using a null-window search.\n\n    Args:\n        board (BoardCore): Position to evaluate.\n\n    Returns:\n        int: Evaluation score for the side to move.\n\n    Example:\n        Use null-window search:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        assert board.play(\"334411\")\n\n        solver = bbc.BitBullyCore()\n        score = solver.nullWindow(board)\n        print(\"Null-window score:\", score)\n        ```\n        Expected output:\n        ```text\n            Null-window score: 18\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.nullWindow(board)","title":"<code>board</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.resetBook","title":"resetBook","text":"<pre><code>resetBook() -&gt; None\n</code></pre> <p>Unload the currently loaded opening book (if any).</p> Example <p>Unload a book: <pre><code>import bitbully.bitbully_core as bbc\nimport bitbully_databases as bbd\ndb_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\nsolver = bbc.BitBullyCore()\n_ = solver.loadBook(db_path)  # replace with your file\nassert solver.isBookLoaded() is True\nsolver.resetBook()\nassert solver.isBookLoaded() is False\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def resetBook(self) -&gt; None:\n    \"\"\"Unload the currently loaded opening book (if any).\n\n    Example:\n        Unload a book:\n        ```python\n        import bitbully.bitbully_core as bbc\n        import bitbully_databases as bbd\n        db_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\n        solver = bbc.BitBullyCore()\n        _ = solver.loadBook(db_path)  # replace with your file\n        assert solver.isBookLoaded() is True\n        solver.resetBook()\n        assert solver.isBookLoaded() is False\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.resetNodeCounter","title":"resetNodeCounter","text":"<pre><code>resetNodeCounter() -&gt; None\n</code></pre> <p>Reset the internal node counter.</p> Example <p>Reset node counter between searches: <pre><code>import bitbully.bitbully_core as bbc\nboard = bbc.BoardCore()\nassert board.play(\"333331111555\")\n\nsolver = bbc.BitBullyCore()\n_ = solver.mtdf(board, first_guess=0)\n\nassert solver.getNodeCounter() &gt; 0\nsolver.resetNodeCounter()\nassert solver.getNodeCounter() == 0\n</code></pre></p> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0bitbully_core <code></code>\u00a0BitBullyCore <code></code>\u00a0getNodeCounter </li> </ul> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def resetNodeCounter(self) -&gt; None:\n    \"\"\"Reset the internal node counter.\n\n    Example:\n        Reset node counter between searches:\n        ```python\n        import bitbully.bitbully_core as bbc\n        board = bbc.BoardCore()\n        assert board.play(\"333331111555\")\n\n        solver = bbc.BitBullyCore()\n        _ = solver.mtdf(board, first_guess=0)\n\n        assert solver.getNodeCounter() &gt; 0\n        solver.resetNodeCounter()\n        assert solver.getNodeCounter() == 0\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.resetTranspositionTable","title":"resetTranspositionTable","text":"<pre><code>resetTranspositionTable() -&gt; None\n</code></pre> <p>Clear the internal transposition table.</p> Example <p>Clear cached results (useful for benchmarking): <pre><code>import bitbully.bitbully_core as bbc\n\nsolver = bbc.BitBullyCore()\nsolver.resetTranspositionTable()\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def resetTranspositionTable(self) -&gt; None:\n    \"\"\"Clear the internal transposition table.\n\n    Example:\n        Clear cached results (useful for benchmarking):\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        solver = bbc.BitBullyCore()\n        solver.resetTranspositionTable()\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.scoreMove","title":"scoreMove","text":"<pre><code>scoreMove(board: BoardCore, column: int, first_guess: int) -&gt; int\n</code></pre> <p>Evaluate a single move in the given position.</p> <p>Parameters:</p> Name Type Description Default <code>BoardCore</code> <p>Current position.</p> required <code>int</code> <p>Column index (0-6) of the move to evaluate.</p> required <code>int</code> <p>Initial guess for the score (often 0).</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Evaluation score of playing the move in <code>column</code>.</p> Example <p>Score one candidate move: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nassert board.play(\"334411\")\n\nsolver = bbc.BitBullyCore()\nscore = solver.scoreMove(board, column=3, first_guess=0)\nprint(\"Score for column 3:\", score)\n</code></pre> Expected output: <pre><code>    Score for column 3: 3\n</code></pre></p> Example <p>Score one candidate move and verify it matches the per-column score vector: <pre><code>import bitbully.bitbully_core as bbc\n\nsolver = bbc.BitBullyCore()\nboard = bbc.BoardCore()\nassert board.setBoard([3, 4, 1, 1, 0, 2, 2, 2])\n\nscores = solver.scoreMoves(board)\n\n# Column 4 is known to be best in this position.\none = solver.scoreMove(board, column=4, first_guess=0)\nassert one == scores[4] == 3\n</code></pre></p> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0solver <code></code>\u00a0BitBully <code></code>\u00a0score_move </li> </ul> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def scoreMove(self, board: \"BoardCore\", column: int, first_guess: int) -&gt; int:\n    \"\"\"Evaluate a single move in the given position.\n\n    Args:\n        board (BoardCore): Current position.\n        column (int): Column index (0-6) of the move to evaluate.\n        first_guess (int): Initial guess for the score (often 0).\n\n    Returns:\n        int: Evaluation score of playing the move in ``column``.\n\n    Example:\n        Score one candidate move:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        assert board.play(\"334411\")\n\n        solver = bbc.BitBullyCore()\n        score = solver.scoreMove(board, column=3, first_guess=0)\n        print(\"Score for column 3:\", score)\n        ```\n        Expected output:\n        ```text\n            Score for column 3: 3\n        ```\n\n    Example:\n        Score one candidate move and verify it matches the per-column score vector:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        solver = bbc.BitBullyCore()\n        board = bbc.BoardCore()\n        assert board.setBoard([3, 4, 1, 1, 0, 2, 2, 2])\n\n        scores = solver.scoreMoves(board)\n\n        # Column 4 is known to be best in this position.\n        one = solver.scoreMove(board, column=4, first_guess=0)\n        assert one == scores[4] == 3\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.scoreMove(board)","title":"<code>board</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.scoreMove(column)","title":"<code>column</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.scoreMove(first_guess)","title":"<code>first_guess</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.scoreMoves","title":"scoreMoves","text":"<pre><code>scoreMoves(board: BoardCore) -&gt; list[int]\n</code></pre> <p>Evaluate all columns (0..6) in the given position.</p> <p>Parameters:</p> Name Type Description Default <code>BoardCore</code> <p>Current position.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: A list of length 7 with per-column scores. Illegal moves (full columns) are included and use an engine-defined sentinel value.</p> Example <p>Score all moves and pick the best: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nassert board.play(\"334411\")\n\nsolver = bbc.BitBullyCore()\nscores = solver.scoreMoves(board)\nassert len(scores) == 7\n\nbest_col = max(range(7), key=scores.__getitem__)\nassert 0 &lt;= best_col &lt; 7\nassert board.isLegalMove(best_col) is True\n</code></pre></p> Example <p>Score all columns and compare against a known expected score vector: <pre><code>import bitbully.bitbully_core as bbc\n\nsolver = bbc.BitBullyCore()\nboard = bbc.BoardCore()\n\nmove_sequence = [3, 4, 1, 1, 0, 2, 2, 2]\nassert board.setBoard(move_sequence)\n\nscores = solver.scoreMoves(board)\nassert scores == [-3, -3, 1, -4, 3, -2, -2]\n</code></pre></p> Example <p>Illegal moves are included and use the engine sentinel value (-1000): <pre><code>import bitbully.bitbully_core as bbc\n\nsolver = bbc.BitBullyCore()\nboard = bbc.BoardCore()\nassert board.setBoard([3, 3, 3, 3, 3, 3, 4, 2])\n\nscores = solver.scoreMoves(board)\nassert scores == [-2, -2, 2, -1000, -2, 1, -1]\n\n# Column 3 is full here (sentinel score).\nassert board.isLegalMove(3) is False\nassert scores[3] == -1000\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def scoreMoves(self, board: \"BoardCore\") -&gt; list[int]:\n    \"\"\"Evaluate all columns (0..6) in the given position.\n\n    Args:\n        board (BoardCore): Current position.\n\n    Returns:\n        list[int]: A list of length 7 with per-column scores. Illegal moves\n            (full columns) are included and use an engine-defined sentinel value.\n\n    Example:\n        Score all moves and pick the best:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        assert board.play(\"334411\")\n\n        solver = bbc.BitBullyCore()\n        scores = solver.scoreMoves(board)\n        assert len(scores) == 7\n\n        best_col = max(range(7), key=scores.__getitem__)\n        assert 0 &lt;= best_col &lt; 7\n        assert board.isLegalMove(best_col) is True\n        ```\n\n    Example:\n        Score all columns and compare against a known expected score vector:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        solver = bbc.BitBullyCore()\n        board = bbc.BoardCore()\n\n        move_sequence = [3, 4, 1, 1, 0, 2, 2, 2]\n        assert board.setBoard(move_sequence)\n\n        scores = solver.scoreMoves(board)\n        assert scores == [-3, -3, 1, -4, 3, -2, -2]\n        ```\n\n    Example:\n        Illegal moves are included and use the engine sentinel value (-1000):\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        solver = bbc.BitBullyCore()\n        board = bbc.BoardCore()\n        assert board.setBoard([3, 3, 3, 3, 3, 3, 4, 2])\n\n        scores = solver.scoreMoves(board)\n        assert scores == [-2, -2, 2, -1000, -2, 1, -1]\n\n        # Column 3 is full here (sentinel score).\n        assert board.isLegalMove(3) is False\n        assert scores[3] == -1000\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.scoreMoves(board)","title":"<code>board</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore","title":"BoardCore","text":"<p>Low-level Connect-4 board representation (bitboard-based).</p> <p>This class is optimized for speed and is the main input type for the solver. It supports playing moves, mirroring, hashing/UIDs, win checks, and move generation.</p> Notes <ul> <li>Column indices are 0..6 (left to right).</li> <li>The side to move is part of the position state.</li> <li>Many methods correspond 1:1 to C++ engine functions.</li> </ul> Example <p>Create a board, play a sequence, and print: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nassert board.play(\"33333111\")\nprint(board.toString())\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0bitbully_core </li> </ul> Returned by: <ul> <li> BitBully API Reference <ul> <li> <code></code>\u00a0bitbully_core <code></code>\u00a0BoardCore <ul> <li> <code></code>\u00a0allPositions </li> <li> <code></code>\u00a0copy </li> <li> <code></code>\u00a0mirror </li> <li> <code></code>\u00a0playMoveOnCopy </li> <li> <code></code>\u00a0randomBoard </li> </ul> </li> <li> <code></code>\u00a0board <code></code>\u00a0Board <code></code>\u00a0native </li> </ul> </li> </ul> Used by: <ul> <li> BitBully API Reference <code></code>\u00a0bitbully_core <ul> <li> <code></code>\u00a0BitBullyCore <ul> <li> <code></code>\u00a0mtdf </li> <li> <code></code>\u00a0negamax </li> <li> <code></code>\u00a0nullWindow </li> <li> <code></code>\u00a0scoreMove </li> <li> <code></code>\u00a0scoreMoves </li> </ul> </li> <li> <code></code>\u00a0BoardCore <ul> <li> <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0__ne__ </li> </ul> </li> <li> <code></code>\u00a0OpeningBookCore <ul> <li> <code></code>\u00a0convertValue </li> <li> <code></code>\u00a0getBoardValue </li> <li> <code></code>\u00a0isInBook </li> </ul> </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__eq__</code> <p>Compare two boards for exact position equality.</p> <code>__ne__</code> <p>Compare two boards for inequality.</p> <code>allPositions</code> <p>Generate all reachable positions from the current board up to a ply limit.</p> <code>copy</code> <p>Create a deep copy of the board.</p> <code>countTokens</code> <p>Return the number of tokens currently on the board.</p> <code>doubleThreat</code> <p>Compute double-threat information (engine-specific).</p> <code>findThreats</code> <p>Compute threat information (engine-specific).</p> <code>generateNonLosingMoves</code> <p>Return a bitmask of non-losing legal moves (engine definition).</p> <code>getColumnHeight</code> <p>Return the number of tokens in the given column.</p> <code>hasWin</code> <p>Check whether the player who made the last move has a connect-four.</p> <code>hash</code> <p>Return a hash of the current position.</p> <code>isLegalMove</code> <p>Check whether playing in <code>column</code> is legal (in-range and not full).</p> <code>isValid</code> <p>Check whether a 7x6 column-major token grid is valid.</p> <code>legalMoves</code> <p>Return legal moves as a list of column indices.</p> <code>legalMovesMask</code> <p>Return the legal moves as a bitmask.</p> <code>mirror</code> <p>Return the horizontally mirrored position.</p> <code>movesLeft</code> <p>Return the number of empty cells remaining.</p> <code>playMoveOnCopy</code> <p>Return a new board with <code>mv</code> applied, leaving the original unchanged.</p> <code>popCountBoard</code> <p>Return the number of occupied cells (popcount of the token bitboard).</p> <code>randomBoard</code> <p>Generate a random reachable position by playing random moves.</p> <code>toArray</code> <p>Return the current position as a 7x6 column-major token grid.</p> <code>toHuffman</code> <p>Encode the current position into the engine's Huffman representation.</p> <code>toString</code> <p>Return a human-readable ASCII rendering of the board.</p> <code>uid</code> <p>Return a deterministic unique identifier for the current position.</p> <p>Attributes:</p> Name Type Description <code>__hash__</code> <code>None</code>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.__hash__","title":"__hash__  <code>class-attribute</code>","text":"<pre><code>__hash__: None = None\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.__eq__","title":"__eq__","text":"<pre><code>__eq__(arg0: BoardCore) -&gt; bool\n</code></pre> <p>Compare two boards for exact position equality.</p> <p>Parameters:</p> Name Type Description Default <code>BoardCore</code> <p>Other board.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if both boards represent the same position.</p> Example <p>Compare two independently built boards: <pre><code>import bitbully.bitbully_core as bbc\n\nb1 = bbc.BoardCore()\nb2 = bbc.BoardCore()\nassert b1.play(\"3344\")\nassert b2.play(\"3344\")\n\nassert b1 == b2\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def __eq__(self, arg0: \"BoardCore\") -&gt; bool:\n    \"\"\"Compare two boards for exact position equality.\n\n    Args:\n        arg0 (BoardCore): Other board.\n\n    Returns:\n        bool: ``True`` if both boards represent the same position.\n\n    Example:\n        Compare two independently built boards:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        b1 = bbc.BoardCore()\n        b2 = bbc.BoardCore()\n        assert b1.play(\"3344\")\n        assert b2.play(\"3344\")\n\n        assert b1 == b2\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.__eq__(arg0)","title":"<code>arg0</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.__ne__","title":"__ne__","text":"<pre><code>__ne__(arg0: BoardCore) -&gt; bool\n</code></pre> <p>Compare two boards for inequality.</p> <p>Parameters:</p> Name Type Description Default <code>BoardCore</code> <p>Other board.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the boards differ, otherwise <code>False</code>.</p> Example <p>Build two different positions and compare: <pre><code>import bitbully.bitbully_core as bbc\n\nb1 = bbc.BoardCore()\nb2 = bbc.BoardCore()\nassert b1.play(\"3\")\nassert b2.play(\"4\")\n\nassert b1 != b2\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def __ne__(self, arg0: \"BoardCore\") -&gt; bool:\n    \"\"\"Compare two boards for inequality.\n\n    Args:\n        arg0 (BoardCore): Other board.\n\n    Returns:\n        bool: ``True`` if the boards differ, otherwise ``False``.\n\n    Example:\n        Build two different positions and compare:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        b1 = bbc.BoardCore()\n        b2 = bbc.BoardCore()\n        assert b1.play(\"3\")\n        assert b2.play(\"4\")\n\n        assert b1 != b2\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.__ne__(arg0)","title":"<code>arg0</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.allPositions","title":"allPositions","text":"<pre><code>allPositions(upToNPly: int, exactlyN: bool) -&gt; list[BoardCore]\n</code></pre> <p>Generate all reachable positions from the current board up to a ply limit.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>Maximum total token count for generated positions.</p> required <code>bool</code> <p>If <code>True</code>, return only positions with exactly <code>upToNPly</code> tokens. If <code>False</code>, include all positions from the current ply up to <code>upToNPly</code>.</p> required <p>Returns:</p> Type Description <code>list[BoardCore]</code> <p>list[BoardCore]: List of generated positions.</p> Example <p>Enumerate all positions with exactly 2 tokens from the empty board: <pre><code>import bitbully.bitbully_core as bbc\n\nroot = bbc.BoardCore()\npositions = root.allPositions(upToNPly=2, exactlyN=True)\n\nassert all(p.countTokens() == 2 for p in positions)\nprint(\"Count:\", len(positions))\n</code></pre> Expected output: <pre><code>    Count: 49\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def allPositions(self, upToNPly: int, exactlyN: bool) -&gt; list[\"BoardCore\"]:\n    \"\"\"Generate all reachable positions from the current board up to a ply limit.\n\n    Args:\n        upToNPly (int): Maximum total token count for generated positions.\n        exactlyN (bool): If ``True``, return only positions with exactly\n            ``upToNPly`` tokens. If ``False``, include all positions from the\n            current ply up to ``upToNPly``.\n\n    Returns:\n        list[BoardCore]: List of generated positions.\n\n    Example:\n        Enumerate all positions with exactly 2 tokens from the empty board:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        root = bbc.BoardCore()\n        positions = root.allPositions(upToNPly=2, exactlyN=True)\n\n        assert all(p.countTokens() == 2 for p in positions)\n        print(\"Count:\", len(positions))\n        ```\n        Expected output:\n        ```text\n            Count: 49\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.allPositions(upToNPly)","title":"<code>upToNPly</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.allPositions(exactlyN)","title":"<code>exactlyN</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.copy","title":"copy","text":"<pre><code>copy() -&gt; BoardCore\n</code></pre> <p>Create a deep copy of the board.</p> <p>Returns:</p> Name Type Description <code>BoardCore</code> <code>BoardCore</code> <p>Independent copy of the current position.</p> Example <p>Create a board, copy it, and verify that both represent the same position: <pre><code>import bitbully.bitbully_core as bbc\n\n# Create a board from a compact move string.\nboard = bbc.BoardCore()\nassert board.play(\"33333111\")\n\n# Create an independent copy of the current position.\nboard_copy = board.copy()\n\n# Both boards represent the same position and are considered equal.\nassert board == board_copy\nassert board.uid() == board_copy.uid()\nassert board.toString() == board_copy.toString()\n\n# Display the board state.\nprint(board.toString())\n</code></pre> Expected output: <pre><code>  _  _  _  _  _  _  _\n  _  _  _  X  _  _  _\n  _  _  _  O  _  _  _\n  _  O  _  X  _  _  _\n  _  X  _  O  _  _  _\n  _  O  _  X  _  _  _\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def copy(self) -&gt; \"BoardCore\":\n    \"\"\"Create a deep copy of the board.\n\n    Returns:\n        BoardCore: Independent copy of the current position.\n\n    Example:\n        Create a board, copy it, and verify that both represent the same position:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        # Create a board from a compact move string.\n        board = bbc.BoardCore()\n        assert board.play(\"33333111\")\n\n        # Create an independent copy of the current position.\n        board_copy = board.copy()\n\n        # Both boards represent the same position and are considered equal.\n        assert board == board_copy\n        assert board.uid() == board_copy.uid()\n        assert board.toString() == board_copy.toString()\n\n        # Display the board state.\n        print(board.toString())\n        ```\n        Expected output:\n        ```text\n          _  _  _  _  _  _  _\n          _  _  _  X  _  _  _\n          _  _  _  O  _  _  _\n          _  O  _  X  _  _  _\n          _  X  _  O  _  _  _\n          _  O  _  X  _  _  _\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.countTokens","title":"countTokens","text":"<pre><code>countTokens() -&gt; int\n</code></pre> <p>Return the number of tokens currently on the board.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Token count (0-42).</p> Example <p>Count tokens after playing a move string: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nassert board.play(\"3344\")\nassert board.countTokens() == 4\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def countTokens(self) -&gt; int:\n    \"\"\"Return the number of tokens currently on the board.\n\n    Returns:\n        int: Token count (0-42).\n\n    Example:\n        Count tokens after playing a move string:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        assert board.play(\"3344\")\n        assert board.countTokens() == 4\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.doubleThreat","title":"doubleThreat","text":"<pre><code>doubleThreat(moves: int) -&gt; int\n</code></pre> <p>Compute double-threat information (engine-specific).</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>Move mask / move set parameter as expected by the engine. A typical input is the result of <code>legalMovesMask()</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Engine-defined bitmask/encoding of detected double threats.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def doubleThreat(self, moves: int) -&gt; int:\n    \"\"\"Compute double-threat information (engine-specific).\n\n    Args:\n        moves (int): Move mask / move set parameter as expected by the engine.\n            A typical input is the result of ``legalMovesMask()``.\n\n    Returns:\n        int: Engine-defined bitmask/encoding of detected double threats.\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.doubleThreat(moves)","title":"<code>moves</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.findThreats","title":"findThreats","text":"<pre><code>findThreats(moves: int) -&gt; int\n</code></pre> <p>Compute threat information (engine-specific).</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>Move mask / move set parameter as expected by the engine. A typical input is the result of <code>legalMovesMask()</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Engine-defined bitmask/encoding of detected threats.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def findThreats(self, moves: int) -&gt; int:\n    \"\"\"Compute threat information (engine-specific).\n\n    Args:\n        moves (int): Move mask / move set parameter as expected by the engine.\n            A typical input is the result of ``legalMovesMask()``.\n\n    Returns:\n        int: Engine-defined bitmask/encoding of detected threats.\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.findThreats(moves)","title":"<code>moves</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.generateNonLosingMoves","title":"generateNonLosingMoves","text":"<pre><code>generateNonLosingMoves() -&gt; int\n</code></pre> <p>Return a bitmask of non-losing legal moves (engine definition).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Bitmask encoding non-losing moves for the side to move.</p> Example <p>Generate non-losing moves and compare with all legal moves: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nassert board.play(\"334411\")\n\nlegal = board.legalMovesMask()\nnon_losing = board.generateNonLosingMoves()\n\n# Non-losing is a subset of legal (bitwise).\nassert (non_losing &amp; legal) == non_losing\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def generateNonLosingMoves(self) -&gt; int:\n    \"\"\"Return a bitmask of non-losing legal moves (engine definition).\n\n    Returns:\n        int: Bitmask encoding non-losing moves for the side to move.\n\n    Example:\n        Generate non-losing moves and compare with all legal moves:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        assert board.play(\"334411\")\n\n        legal = board.legalMovesMask()\n        non_losing = board.generateNonLosingMoves()\n\n        # Non-losing is a subset of legal (bitwise).\n        assert (non_losing &amp; legal) == non_losing\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.getColumnHeight","title":"getColumnHeight","text":"<pre><code>getColumnHeight(column: int) -&gt; int\n</code></pre> <p>Return the number of tokens in the given column.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>Column index (0-6).</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of tokens in the column (0-6).</p> Example <p>Check column heights after some moves: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nassert board.play(\"3332211\" + 6 * \"5\")\n\nassert board.getColumnHeight(0) == 0\nassert board.getColumnHeight(1) == 2\nassert board.getColumnHeight(2) == 2\nassert board.getColumnHeight(3) == 3\nassert board.getColumnHeight(4) == 0\nassert board.getColumnHeight(5) == 6\nassert board.getColumnHeight(6) == 0\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def getColumnHeight(self, column: int) -&gt; int:\n    \"\"\"Return the number of tokens in the given column.\n\n    Args:\n        column (int): Column index (0-6).\n\n    Returns:\n        int: Number of tokens in the column (0-6).\n\n    Example:\n        Check column heights after some moves:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        assert board.play(\"3332211\" + 6 * \"5\")\n\n        assert board.getColumnHeight(0) == 0\n        assert board.getColumnHeight(1) == 2\n        assert board.getColumnHeight(2) == 2\n        assert board.getColumnHeight(3) == 3\n        assert board.getColumnHeight(4) == 0\n        assert board.getColumnHeight(5) == 6\n        assert board.getColumnHeight(6) == 0\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.getColumnHeight(column)","title":"<code>column</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.hasWin","title":"hasWin","text":"<pre><code>hasWin() -&gt; bool\n</code></pre> <p>Check whether the player who made the last move has a connect-four.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the previous player has a winning 4-in-a-row.</p> Example <p>Play a winning sequence and check that the last mover has a win: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nassert board.play([3, 2, 3, 2, 3, 2, 3])\nassert board.hasWin() is True\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def hasWin(self) -&gt; bool:\n    \"\"\"Check whether the player who made the last move has a connect-four.\n\n    Returns:\n        bool: ``True`` if the previous player has a winning 4-in-a-row.\n\n    Example:\n        Play a winning sequence and check that the last mover has a win:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        assert board.play([3, 2, 3, 2, 3, 2, 3])\n        assert board.hasWin() is True\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.hash","title":"hash","text":"<pre><code>hash() -&gt; int\n</code></pre> <p>Return a hash of the current position.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Hash value suitable for hash tables / transposition tables.</p> Example <p>Hashes match for identical positions and differ after divergence: <pre><code>import bitbully.bitbully_core as bbc\n\nb1 = bbc.BoardCore()\nb2 = bbc.BoardCore()\nassert b1.play(\"334411\")\nassert b2.play(\"334411\")\nassert b1.hash() == b2.hash()\n\nassert b1.play(1)\nassert b1.hash() != b2.hash()\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def hash(self) -&gt; int:\n    \"\"\"Return a hash of the current position.\n\n    Returns:\n        int: Hash value suitable for hash tables / transposition tables.\n\n    Example:\n        Hashes match for identical positions and differ after divergence:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        b1 = bbc.BoardCore()\n        b2 = bbc.BoardCore()\n        assert b1.play(\"334411\")\n        assert b2.play(\"334411\")\n        assert b1.hash() == b2.hash()\n\n        assert b1.play(1)\n        assert b1.hash() != b2.hash()\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.isLegalMove","title":"isLegalMove","text":"<pre><code>isLegalMove(column: int) -&gt; bool\n</code></pre> <p>Check whether playing in <code>column</code> is legal (in-range and not full).</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>Column index (0-6).</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the move is legal, otherwise <code>False</code>.</p> Example <p>Check legality before playing: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nif board.isLegalMove(3):\n    assert board.play(3)\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def isLegalMove(self, column: int) -&gt; bool:\n    \"\"\"Check whether playing in ``column`` is legal (in-range and not full).\n\n    Args:\n        column (int): Column index (0-6).\n\n    Returns:\n        bool: ``True`` if the move is legal, otherwise ``False``.\n\n    Example:\n        Check legality before playing:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        if board.isLegalMove(3):\n            assert board.play(3)\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.isLegalMove(column)","title":"<code>column</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.isValid","title":"isValid  <code>staticmethod</code>","text":"<pre><code>isValid(board: list[list[int]]) -&gt; bool\n</code></pre> <p>Check whether a 7x6 column-major token grid is valid.</p> <p>Parameters:</p> Name Type Description Default <code>list[list[int]]</code> <p>Column-major 7x6 grid (<code>board[col][row]</code>) with values typically in <code>{0, 1, 2}</code> (empty/yellow/red).</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the array has the right shape and encodes a legal position according to engine rules.</p> Example <p>Validate a board grid before setting it: <pre><code>import bitbully.bitbully_core as bbc\n\ngrid = [[0] * 6 for _ in range(7)]\ngrid[3][0] = int(bbc.Player.P_YELLOW)\nassert bbc.BoardCore.isValid(grid) is True\n\ngrid[3][0] = 3  # invalid token\nassert bbc.BoardCore.isValid(grid) is False\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>@staticmethod\ndef isValid(\n    board: typing.Annotated[\n        list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(6)]],\n        pybind11_stubgen.typing_ext.FixedSize(7),\n    ],\n) -&gt; bool:\n    \"\"\"Check whether a 7x6 column-major token grid is valid.\n\n    Args:\n        board (list[list[int]]): Column-major 7x6 grid (``board[col][row]``)\n            with values typically in ``{0, 1, 2}`` (empty/yellow/red).\n\n    Returns:\n        bool: ``True`` if the array has the right shape and encodes a legal\n            position according to engine rules.\n\n    Example:\n        Validate a board grid before setting it:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        grid = [[0] * 6 for _ in range(7)]\n        grid[3][0] = int(bbc.Player.P_YELLOW)\n        assert bbc.BoardCore.isValid(grid) is True\n\n        grid[3][0] = 3  # invalid token\n        assert bbc.BoardCore.isValid(grid) is False\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.isValid(board)","title":"<code>board</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.legalMoves","title":"legalMoves","text":"<pre><code>legalMoves(nonLosing: bool, orderMoves: bool) -&gt; list[int]\n</code></pre> <p>Return legal moves as a list of column indices.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>If <code>True</code>, return only moves that do not allow the opponent to win immediately next turn (engine definition).</p> required <code>bool</code> <p>If <code>True</code>, order moves in an engine-defined heuristic order (typically center-first).</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: List of legal column indices.</p> Example <p>Get ordered legal moves (center-first): <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\ncols = board.legalMoves(nonLosing=False, orderMoves=True)\n\nassert all(0 &lt;= c &lt; 7 for c in cols)\nprint(cols)\n</code></pre> Expected output: <pre><code>[3, 2, 4, 1, 5, 0, 6]\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def legalMoves(self, nonLosing: bool, orderMoves: bool) -&gt; list[int]:\n    \"\"\"Return legal moves as a list of column indices.\n\n    Args:\n        nonLosing (bool): If ``True``, return only moves that do not allow the\n            opponent to win immediately next turn (engine definition).\n        orderMoves (bool): If ``True``, order moves in an engine-defined\n            heuristic order (typically center-first).\n\n    Returns:\n        list[int]: List of legal column indices.\n\n    Example:\n        Get ordered legal moves (center-first):\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        cols = board.legalMoves(nonLosing=False, orderMoves=True)\n\n        assert all(0 &lt;= c &lt; 7 for c in cols)\n        print(cols)\n        ```\n        Expected output:\n        ```text\n        [3, 2, 4, 1, 5, 0, 6]\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.legalMoves(nonLosing)","title":"<code>nonLosing</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.legalMoves(orderMoves)","title":"<code>orderMoves</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.legalMovesMask","title":"legalMovesMask","text":"<pre><code>legalMovesMask() -&gt; int\n</code></pre> <p>Return the legal moves as a bitmask.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Bitmask encoding the set of legal moves (engine bitboard format).</p> Example <p>Get the move mask and verify it is non-zero on non-full boards: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nmask = board.legalMovesMask()\nassert isinstance(mask, int)\nassert mask != 0\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def legalMovesMask(self) -&gt; int:\n    \"\"\"Return the legal moves as a bitmask.\n\n    Returns:\n        int: Bitmask encoding the set of legal moves (engine bitboard format).\n\n    Example:\n        Get the move mask and verify it is non-zero on non-full boards:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        mask = board.legalMovesMask()\n        assert isinstance(mask, int)\n        assert mask != 0\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.mirror","title":"mirror","text":"<pre><code>mirror() -&gt; BoardCore\n</code></pre> <p>Return the horizontally mirrored position.</p> <p>Returns:</p> Name Type Description <code>BoardCore</code> <code>BoardCore</code> <p>Mirrored board (column 0 &lt;-&gt; 6, 1 &lt;-&gt; 5, 2 &lt;-&gt; 4).</p> Example <p>Mirror twice returns the original position: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nassert board.setBoard([0, 1, 2])  # simple asymmetric position\n\nmirrored = board.mirror()\nassert mirrored != board\nassert mirrored.countTokens() == board.countTokens()\nassert mirrored.mirror() == board\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def mirror(self) -&gt; \"BoardCore\":\n    \"\"\"Return the horizontally mirrored position.\n\n    Returns:\n        BoardCore: Mirrored board (column 0 &lt;-&gt; 6, 1 &lt;-&gt; 5, 2 &lt;-&gt; 4).\n\n    Example:\n        Mirror twice returns the original position:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        assert board.setBoard([0, 1, 2])  # simple asymmetric position\n\n        mirrored = board.mirror()\n        assert mirrored != board\n        assert mirrored.countTokens() == board.countTokens()\n        assert mirrored.mirror() == board\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.movesLeft","title":"movesLeft","text":"<pre><code>movesLeft() -&gt; int\n</code></pre> <p>Return the number of empty cells remaining.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Remaining moves until the board is full (0-42).</p> Example <p>Confirm moves left after some moves: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nassert board.play(\"3344\")\nassert board.movesLeft() == 42 - 4\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def movesLeft(self) -&gt; int:\n    \"\"\"Return the number of empty cells remaining.\n\n    Returns:\n        int: Remaining moves until the board is full (0-42).\n\n    Example:\n        Confirm moves left after some moves:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        assert board.play(\"3344\")\n        assert board.movesLeft() == 42 - 4\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.playMoveOnCopy","title":"playMoveOnCopy","text":"<pre><code>playMoveOnCopy(mv: int) -&gt; BoardCore\n</code></pre> <p>Return a new board with <code>mv</code> applied, leaving the original unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>Column index (0-6).</p> required <p>Returns:</p> Name Type Description <code>BoardCore</code> <code>BoardCore</code> <p>New board after the move.</p> Example <p>Try a move without mutating the original board: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nboard2 = board.playMoveOnCopy(3)\n\nassert board.countTokens() == 0\nassert board2.countTokens() == 1\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def playMoveOnCopy(self, mv: int) -&gt; \"BoardCore\":\n    \"\"\"Return a new board with ``mv`` applied, leaving the original unchanged.\n\n    Args:\n        mv (int): Column index (0-6).\n\n    Returns:\n        BoardCore: New board after the move.\n\n    Example:\n        Try a move without mutating the original board:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        board2 = board.playMoveOnCopy(3)\n\n        assert board.countTokens() == 0\n        assert board2.countTokens() == 1\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.playMoveOnCopy(mv)","title":"<code>mv</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.popCountBoard","title":"popCountBoard","text":"<pre><code>popCountBoard() -&gt; int\n</code></pre> <p>Return the number of occupied cells (popcount of the token bitboard).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of occupied cells (0-42).</p> Example <p>Compare popCountBoard() with countTokens(): <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nassert board.play(\"334411\")\nassert board.popCountBoard() == board.countTokens()\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def popCountBoard(self) -&gt; int:\n    \"\"\"Return the number of occupied cells (popcount of the token bitboard).\n\n    Returns:\n        int: Number of occupied cells (0-42).\n\n    Example:\n        Compare popCountBoard() with countTokens():\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        assert board.play(\"334411\")\n        assert board.popCountBoard() == board.countTokens()\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.randomBoard","title":"randomBoard  <code>staticmethod</code>","text":"<pre><code>randomBoard(nPly: int, forbidDirectWin: bool) -&gt; tuple[BoardCore, list[int]]\n</code></pre> <p>Generate a random reachable position by playing random moves.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>Number of moves (tokens) to play (0-42).</p> required <code>bool</code> <p>If <code>True</code>, ensure the generated position does not contain an immediate winning move for the side to move.</p> required <p>Returns:</p> Type Description <code>tuple[BoardCore, list[int]]</code> <p>tuple[BoardCore, list[int]]: <code>(board, moves)</code> where <code>moves</code> is the move sequence used to generate the board.</p> Example <p>Create a random 8-ply position and show the move sequence: <pre><code>import bitbully.bitbully_core as bbc\n\nboard, moves = bbc.BoardCore.randomBoard(nPly=8, forbidDirectWin=True)\nassert len(moves) == 8\n\nprint(\"Moves:\", moves)\nprint(board)\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>@staticmethod\ndef randomBoard(nPly: int, forbidDirectWin: bool) -&gt; tuple[\"BoardCore\", list[int]]:\n    \"\"\"Generate a random reachable position by playing random moves.\n\n    Args:\n        nPly (int): Number of moves (tokens) to play (0-42).\n        forbidDirectWin (bool): If ``True``, ensure the generated position\n            does not contain an immediate winning move for the side to move.\n\n    Returns:\n        tuple[BoardCore, list[int]]: ``(board, moves)`` where ``moves`` is the\n            move sequence used to generate the board.\n\n    Example:\n        Create a random 8-ply position and show the move sequence:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board, moves = bbc.BoardCore.randomBoard(nPly=8, forbidDirectWin=True)\n        assert len(moves) == 8\n\n        print(\"Moves:\", moves)\n        print(board)\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.randomBoard(nPly)","title":"<code>nPly</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.randomBoard(forbidDirectWin)","title":"<code>forbidDirectWin</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.toArray","title":"toArray","text":"<pre><code>toArray() -&gt; list[list[int]]\n</code></pre> <p>Return the current position as a 7x6 column-major token grid.</p> <p>Returns:</p> Type Description <code>list[list[int]]</code> <p>list[list[int]]: Column-major grid (7 columns x 6 rows).</p> Example <p>Convert to an array and inspect dimensions: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nassert board.play(\"3\")\n\narr = board.toArray()\nassert len(arr) == 7\nassert len(arr[0]) == 6\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def toArray(\n    self,\n) -&gt; typing.Annotated[\n    list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(6)]],\n    pybind11_stubgen.typing_ext.FixedSize(7),\n]:\n    \"\"\"Return the current position as a 7x6 column-major token grid.\n\n    Returns:\n        list[list[int]]: Column-major grid (7 columns x 6 rows).\n\n    Example:\n        Convert to an array and inspect dimensions:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        assert board.play(\"3\")\n\n        arr = board.toArray()\n        assert len(arr) == 7\n        assert len(arr[0]) == 6\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.toHuffman","title":"toHuffman","text":"<pre><code>toHuffman() -&gt; int\n</code></pre> <p>Encode the current position into the engine's Huffman representation.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Huffman-encoded position key used by the opening books.</p> Example <p>Compute a Huffman key (only defined for certain positions): <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\n\n# Huffman encoding is only defined for some positions in this engine\n# (e.g., even number of tokens and &lt;= 12 ply in your C++ code).\nassert board.play(\"33331111\")  # 8 tokens\nkey = board.toHuffman()\nprint(\"Huffman key:\", key)\n</code></pre> Expected output: <pre><code>    Huffman key: 6133600\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def toHuffman(self) -&gt; int:\n    \"\"\"Encode the current position into the engine's Huffman representation.\n\n    Returns:\n        int: Huffman-encoded position key used by the opening books.\n\n    Example:\n        Compute a Huffman key (only defined for certain positions):\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n\n        # Huffman encoding is only defined for some positions in this engine\n        # (e.g., even number of tokens and &lt;= 12 ply in your C++ code).\n        assert board.play(\"33331111\")  # 8 tokens\n        key = board.toHuffman()\n        print(\"Huffman key:\", key)\n        ```\n        Expected output:\n        ```text\n            Huffman key: 6133600\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.toString","title":"toString","text":"<pre><code>toString() -&gt; str\n</code></pre> <p>Return a human-readable ASCII rendering of the board.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Multi-line 6x7 grid representation.</p> Example <p>Print a board: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nassert board.play(\"33333111\")\nprint(board.toString())\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def toString(self) -&gt; str:\n    \"\"\"Return a human-readable ASCII rendering of the board.\n\n    Returns:\n        str: Multi-line 6x7 grid representation.\n\n    Example:\n        Print a board:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        assert board.play(\"33333111\")\n        print(board.toString())\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.uid","title":"uid","text":"<pre><code>uid() -&gt; int\n</code></pre> <p>Return a deterministic unique identifier for the current position.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>UID derived from the position (tokens + side to move).</p> Example <p>Use <code>uid()</code> as a stable key for caching: <pre><code>import bitbully.bitbully_core as bbc\n\nboard = bbc.BoardCore()\nassert board.play(\"334411\")\n\ncache: dict[int, str] = {}\ncache[board.uid()] = board.toString()\nassert board.uid() in cache\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def uid(self) -&gt; int:\n    \"\"\"Return a deterministic unique identifier for the current position.\n\n    Returns:\n        int: UID derived from the position (tokens + side to move).\n\n    Example:\n        Use ``uid()`` as a stable key for caching:\n        ```python\n        import bitbully.bitbully_core as bbc\n\n        board = bbc.BoardCore()\n        assert board.play(\"334411\")\n\n        cache: dict[int, str] = {}\n        cache[board.uid()] = board.toString()\n        assert board.uid() in cache\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore","title":"OpeningBookCore","text":"<p>Opening book reader and lookup helper.</p> <p>Opening books map a compact position key (Huffman encoding) to an engine score, optionally including distance-to-win information.</p> Example <p>Load a book and check whether a position is contained: <pre><code>import bitbully.bitbully_core as bbc\nimport bitbully_databases as bbd\ndb_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\nboard = bbc.BoardCore()\nassert board.play(\"333331111555\")\n\nbook = bbc.OpeningBookCore(db_path)  # replace with your file\nassert book.isInBook(board)\n</code></pre></p> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0bitbully_core </li> </ul> <p>Methods:</p> Name Description <code>convertValue</code> <p>Convert a stored book value to an engine score for the given board.</p> <code>getBoardValue</code> <p>Lookup a board position in the opening book and return its value.</p> <code>getBook</code> <p>Return the raw opening book table.</p> <code>getBookSize</code> <p>Return the number of entries in the opening book.</p> <code>getEntry</code> <p>Return a single raw entry by index.</p> <code>getNPly</code> <p>Return the ply depth of the opening book.</p> <code>init</code> <p>Reinitialize the opening book with new settings.</p> <code>isInBook</code> <p>Check whether a position exists in the opening book.</p> <code>readBook</code> <p>Read an opening book file into a raw table.</p>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.convertValue","title":"convertValue","text":"<pre><code>convertValue(value: int, board: BoardCore) -&gt; int\n</code></pre> <p>Convert a stored book value to an engine score for the given board.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>Raw value stored in the book table.</p> required <code>BoardCore</code> <p>Board used to interpret the value.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Converted score in the engine's scoring convention.</p> Example <p>Convert a raw entry value using the current board context: <pre><code>import bitbully.bitbully_core as bbc\nimport bitbully_databases as bbd\ndb_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\nboard = bbc.BoardCore()\nbook = bbc.OpeningBookCore(db_path)  # replace with your file\n\nkey, raw_val = book.getEntry(0)\nscore = book.convertValue(raw_val, board)\nprint(\"Converted score:\", score)\n</code></pre> Expected output: <pre><code>    Converted score: 9\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def convertValue(self, value: int, board: \"BoardCore\") -&gt; int:\n    \"\"\"Convert a stored book value to an engine score for the given board.\n\n    Args:\n        value (int): Raw value stored in the book table.\n        board (BoardCore): Board used to interpret the value.\n\n    Returns:\n        int: Converted score in the engine's scoring convention.\n\n    Example:\n        Convert a raw entry value using the current board context:\n        ```python\n        import bitbully.bitbully_core as bbc\n        import bitbully_databases as bbd\n        db_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\n        board = bbc.BoardCore()\n        book = bbc.OpeningBookCore(db_path)  # replace with your file\n\n        key, raw_val = book.getEntry(0)\n        score = book.convertValue(raw_val, board)\n        print(\"Converted score:\", score)\n        ```\n        Expected output:\n        ```text\n            Converted score: 9\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.convertValue(value)","title":"<code>value</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.convertValue(board)","title":"<code>board</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.getBoardValue","title":"getBoardValue","text":"<pre><code>getBoardValue(board: BoardCore) -&gt; int\n</code></pre> <p>Lookup a board position in the opening book and return its value.</p> <p>Parameters:</p> Name Type Description Default <code>BoardCore</code> <p>Position to query.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Book value converted to the engine's scoring convention.</p> Example <p>Query a position's book value: <pre><code>import bitbully.bitbully_core as bbc\nimport bitbully_databases as bbd\ndb_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\nboard = bbc.BoardCore()\nassert board.play(\"333331111555\")\n\nbook = bbc.OpeningBookCore(db_path)  # replace with your file\nif book.isInBook(board):\n    print(\"Value:\", book.getBoardValue(board))\n</code></pre> Expected output: <pre><code>    Value: 1\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def getBoardValue(self, board: \"BoardCore\") -&gt; int:\n    \"\"\"Lookup a board position in the opening book and return its value.\n\n    Args:\n        board (BoardCore): Position to query.\n\n    Returns:\n        int: Book value converted to the engine's scoring convention.\n\n    Example:\n        Query a position's book value:\n        ```python\n        import bitbully.bitbully_core as bbc\n        import bitbully_databases as bbd\n        db_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\n        board = bbc.BoardCore()\n        assert board.play(\"333331111555\")\n\n        book = bbc.OpeningBookCore(db_path)  # replace with your file\n        if book.isInBook(board):\n            print(\"Value:\", book.getBoardValue(board))\n        ```\n        Expected output:\n        ```text\n            Value: 1\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.getBoardValue(board)","title":"<code>board</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.getBook","title":"getBook","text":"<pre><code>getBook() -&gt; list[tuple[int, int]]\n</code></pre> <p>Return the raw opening book table.</p> <p>Returns:</p> Type Description <code>list[tuple[int, int]]</code> <p>list[tuple[int, int]]: List of <code>(key, value)</code> entries.</p> Example <p>Access the raw table and inspect the first entry: <pre><code>import bitbully.bitbully_core as bbc\nimport bitbully_databases as bbd\ndb_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\nbook = bbc.OpeningBookCore(db_path)  # replace with your file\nraw = book.getBook()\n\nkey0, val0 = raw[0]\nprint(\"First entry:\", key0, val0)\n</code></pre> Expected output: <pre><code>    First entry: -2124988676 75\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def getBook(self) -&gt; list[tuple[int, int]]:\n    \"\"\"Return the raw opening book table.\n\n    Returns:\n        list[tuple[int, int]]: List of ``(key, value)`` entries.\n\n    Example:\n        Access the raw table and inspect the first entry:\n        ```python\n        import bitbully.bitbully_core as bbc\n        import bitbully_databases as bbd\n        db_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\n        book = bbc.OpeningBookCore(db_path)  # replace with your file\n        raw = book.getBook()\n\n        key0, val0 = raw[0]\n        print(\"First entry:\", key0, val0)\n        ```\n        Expected output:\n        ```text\n            First entry: -2124988676 75\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.getBookSize","title":"getBookSize","text":"<pre><code>getBookSize() -&gt; int\n</code></pre> <p>Return the number of entries in the opening book.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of stored positions.</p> Example <p>Print the number of stored positions: <pre><code>import bitbully.bitbully_core as bbc\nimport bitbully_databases as bbd\ndb_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\nbook = bbc.OpeningBookCore(db_path)  # replace with your file\nprint(book.getBookSize())\n</code></pre> Expected output: <pre><code>    4200899\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def getBookSize(self) -&gt; int:\n    \"\"\"Return the number of entries in the opening book.\n\n    Returns:\n        int: Number of stored positions.\n\n    Example:\n        Print the number of stored positions:\n        ```python\n        import bitbully.bitbully_core as bbc\n        import bitbully_databases as bbd\n        db_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\n        book = bbc.OpeningBookCore(db_path)  # replace with your file\n        print(book.getBookSize())\n        ```\n        Expected output:\n        ```text\n            4200899\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.getEntry","title":"getEntry","text":"<pre><code>getEntry(entryIdx: int) -&gt; tuple[int, int]\n</code></pre> <p>Return a single raw entry by index.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>Entry index (0-based).</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: The <code>(key, value)</code> pair at <code>entryIdx</code>.</p> Example <p>Read a single entry: <pre><code>import bitbully.bitbully_core as bbc\nimport bitbully_databases as bbd\ndb_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\nbook = bbc.OpeningBookCore(db_path)  # replace with your file\nkey, val = book.getEntry(0)\n\nprint(\"Entry 0:\", key, val)\n</code></pre> Expected output: <pre><code>    Entry 0: -2124988676 75\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def getEntry(self, entryIdx: int) -&gt; tuple[int, int]:\n    \"\"\"Return a single raw entry by index.\n\n    Args:\n        entryIdx (int): Entry index (0-based).\n\n    Returns:\n        tuple[int, int]: The ``(key, value)`` pair at ``entryIdx``.\n\n    Example:\n        Read a single entry:\n        ```python\n        import bitbully.bitbully_core as bbc\n        import bitbully_databases as bbd\n        db_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\n        book = bbc.OpeningBookCore(db_path)  # replace with your file\n        key, val = book.getEntry(0)\n\n        print(\"Entry 0:\", key, val)\n        ```\n        Expected output:\n        ```text\n            Entry 0: -2124988676 75\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.getEntry(entryIdx)","title":"<code>entryIdx</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.getNPly","title":"getNPly","text":"<pre><code>getNPly() -&gt; int\n</code></pre> <p>Return the ply depth of the opening book.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Ply depth (e.g., 8 or 12).</p> Example <p>Print the book depth: <pre><code>import bitbully.bitbully_core as bbc\nimport bitbully_databases as bbd\ndb_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\nbook = bbc.OpeningBookCore(db_path)  # replace with your file\nprint(\"NPly:\", book.getNPly())\n</code></pre> Expected output: <pre><code>    NPly: 12\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def getNPly(self) -&gt; int:\n    \"\"\"Return the ply depth of the opening book.\n\n    Returns:\n        int: Ply depth (e.g., 8 or 12).\n\n    Example:\n        Print the book depth:\n        ```python\n        import bitbully.bitbully_core as bbc\n        import bitbully_databases as bbd\n        db_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\n        book = bbc.OpeningBookCore(db_path)  # replace with your file\n        print(\"NPly:\", book.getNPly())\n        ```\n        Expected output:\n        ```text\n            NPly: 12\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.init","title":"init","text":"<pre><code>init(bookPath: PathLike, is_8ply: bool, with_distances: bool) -&gt; None\n</code></pre> <p>Reinitialize the opening book with new settings.</p> <p>Parameters:</p> Name Type Description Default <code>PathLike</code> <p>Path to the book file.</p> required <code>bool</code> <p>Whether this is an 8-ply book.</p> required <code>bool</code> <p>Whether values include distance-to-win information.</p> required Example <p>Reinitialize an existing instance: <pre><code>import bitbully.bitbully_core as bbc\nimport bitbully_databases as bbd\ndb_path = bbd.BitBullyDatabases.get_database_path(\"12-ply-dist\")\n\nbook = bbc.OpeningBookCore(db_path)  # replace with your file\nbook.init(db_path, is_8ply=False, with_distances=True)\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def init(self, bookPath: os.PathLike, is_8ply: bool, with_distances: bool) -&gt; None:\n    \"\"\"Reinitialize the opening book with new settings.\n\n    Args:\n        bookPath (os.PathLike): Path to the book file.\n        is_8ply (bool): Whether this is an 8-ply book.\n        with_distances (bool): Whether values include distance-to-win information.\n\n    Example:\n        Reinitialize an existing instance:\n        ```python\n        import bitbully.bitbully_core as bbc\n        import bitbully_databases as bbd\n        db_path = bbd.BitBullyDatabases.get_database_path(\"12-ply-dist\")\n\n        book = bbc.OpeningBookCore(db_path)  # replace with your file\n        book.init(db_path, is_8ply=False, with_distances=True)\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.init(bookPath)","title":"<code>bookPath</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.init(is_8ply)","title":"<code>is_8ply</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.init(with_distances)","title":"<code>with_distances</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.isInBook","title":"isInBook","text":"<pre><code>isInBook(board: BoardCore) -&gt; bool\n</code></pre> <p>Check whether a position exists in the opening book.</p> <p>Parameters:</p> Name Type Description Default <code>BoardCore</code> <p>Position to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the position (or its mirrored canonical form) is present in the book, otherwise <code>False</code>.</p> Example <p>Check membership before lookup: <pre><code>import bitbully.bitbully_core as bbc\nimport bitbully_databases as bbd\n\ndb_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\nboard = bbc.BoardCore()\nassert board.play(\"334411\")\n\nbook = bbc.OpeningBookCore(db_path)\n\nin_book = book.isInBook(board)\nif in_book:\n    _ = book.getBoardValue(board)\n\nassert isinstance(in_book, bool)\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def isInBook(self, board: \"BoardCore\") -&gt; bool:\n    \"\"\"Check whether a position exists in the opening book.\n\n    Args:\n        board (BoardCore): Position to check.\n\n    Returns:\n        bool: ``True`` if the position (or its mirrored canonical form) is present in the book, otherwise ``False``.\n\n    Example:\n        Check membership before lookup:\n        ```python\n        import bitbully.bitbully_core as bbc\n        import bitbully_databases as bbd\n\n        db_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\n        board = bbc.BoardCore()\n        assert board.play(\"334411\")\n\n        book = bbc.OpeningBookCore(db_path)\n\n        in_book = book.isInBook(board)\n        if in_book:\n            _ = book.getBoardValue(board)\n\n        assert isinstance(in_book, bool)\n        ```\n\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.isInBook(board)","title":"<code>board</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.readBook","title":"readBook  <code>staticmethod</code>","text":"<pre><code>readBook(filename: PathLike, with_distances: bool = True, is_8ply: bool = False) -&gt; list[tuple[int, int]]\n</code></pre> <p>Read an opening book file into a raw table.</p> <p>Parameters:</p> Name Type Description Default <code>PathLike</code> <p>Path to the book file.</p> required <code>bool</code> <p>If <code>True</code>, interpret values as including distance-to-win information (where supported).</p> <code>True</code> <code>bool</code> <p>If <code>True</code>, interpret the file as an 8-ply book.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[tuple[int, int]]</code> <p>list[tuple[int, int]]: List of <code>(key, value)</code> entries.</p> Example <p>Read the raw book table: <pre><code>import bitbully.bitbully_core as bbc\nimport bitbully_databases as bbd\ndb_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\ntable = bbc.OpeningBookCore.readBook(\n    db_path,\n    with_distances=True,\n    is_8ply=False,\n)\nprint(\"Entries:\", len(table))\n</code></pre> Expected output: <pre><code>    Entries: 4200899\n</code></pre></p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>@staticmethod\ndef readBook(\n    filename: os.PathLike,\n    with_distances: bool = True,\n    is_8ply: bool = False,\n) -&gt; list[tuple[int, int]]:\n    \"\"\"Read an opening book file into a raw table.\n\n    Args:\n        filename (os.PathLike): Path to the book file.\n        with_distances (bool): If ``True``, interpret values as including\n            distance-to-win information (where supported).\n        is_8ply (bool): If ``True``, interpret the file as an 8-ply book.\n\n    Returns:\n        list[tuple[int, int]]: List of ``(key, value)`` entries.\n\n    Example:\n        Read the raw book table:\n        ```python\n        import bitbully.bitbully_core as bbc\n        import bitbully_databases as bbd\n        db_path = bbd.BitBullyDatabases.get_database_path(\"default\")\n\n        table = bbc.OpeningBookCore.readBook(\n            db_path,\n            with_distances=True,\n            is_8ply=False,\n        )\n        print(\"Entries:\", len(table))\n        ```\n        Expected output:\n        ```text\n            Entries: 4200899\n        ```\n    \"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.readBook(filename)","title":"<code>filename</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.readBook(with_distances)","title":"<code>with_distances</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.readBook(is_8ply)","title":"<code>is_8ply</code>","text":""},{"location":"bitbully_core/#src.bitbully.bitbully_core.Player","title":"Player","text":"<pre><code>\n              flowchart TD\n              src.bitbully.bitbully_core.Player[Player]\n\n              \n\n              click src.bitbully.bitbully_core.Player href \"\" \"src.bitbully.bitbully_core.Player\"\n            </code></pre> <p>Player identifiers used by the engine.</p> Example <p>Inspect numeric values used by the engine: <pre><code>import bitbully.bitbully_core as bbc\n\nassert int(bbc.Player.P_EMPTY) == 0\nassert int(bbc.Player.P_YELLOW) == 1\nassert int(bbc.Player.P_RED) == 2\n</code></pre></p> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0bitbully_core </li> </ul> Used by: <ul> <li> BitBully API Reference <code></code>\u00a0board <code></code>\u00a0Board <code></code>\u00a0Player </li> </ul> <p>Attributes:</p> Name Type Description <code>P_EMPTY</code> <code>int</code> <p>Empty cell marker (no token).</p> <code>P_RED</code> <code>int</code> <p>Player 2 / Red token.</p> <code>P_YELLOW</code> <code>int</code> <p>Player 1 / Yellow token.</p>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.Player.P_EMPTY","title":"P_EMPTY  <code>instance-attribute</code>","text":"<pre><code>P_EMPTY: int\n</code></pre> <p>Empty cell marker (no token).</p>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.Player.P_RED","title":"P_RED  <code>instance-attribute</code>","text":"<pre><code>P_RED: int\n</code></pre> <p>Player 2 / Red token.</p>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.Player.P_YELLOW","title":"P_YELLOW  <code>instance-attribute</code>","text":"<pre><code>P_YELLOW: int\n</code></pre> <p>Player 1 / Yellow token.</p>"},{"location":"board/","title":"board","text":""},{"location":"board/#src.bitbully.board","title":"board","text":"<p>This module defines the Board class for managing the state of a Connect Four game.</p> <p>Classes:</p> Name Description <code>Board</code> <p>Represents the state of a Connect Four board. Mostly a thin wrapper around BoardCore.</p>"},{"location":"board/#src.bitbully.board.Board","title":"Board","text":"<pre><code>Board(init_with: Sequence[Sequence[int]] | Sequence[int] | str | None = None)\n</code></pre> <p>Represents the state of a Connect Four board. Mostly a thin wrapper around BoardCore.</p> <p>Parameters:</p> Name Type Description Default <code>Sequence[Sequence[int]] | Sequence[int] | str | None</code> <p>Optional initial board state. Accepts: - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7 - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3]) - String: A move sequence of columns as string (e.g., \"002233\") - None for an empty board</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided initial board state is invalid.</p> Example <p>You can initialize an empty board in multiple ways: <pre><code>import bitbully as bb\n\n# Create an empty board using the default constructor.\nboard = bb.Board()  # Starts with no tokens placed.\n\n# Alternatively, initialize the board explicitly from a 2D list.\n# Each inner list represents a column (7 columns total, 6 rows each).\n# A value of 0 indicates an empty cell; 1 and 2 would represent player tokens.\nboard = bb.Board([[0] * 6 for _ in range(7)])  # Equivalent to an empty board.\n\n# You can also set up a specific board position manually using a 6 x 7 layout,\n# where each inner list represents a row instead of a column.\n# (Both layouts are accepted by BitBully for convenience.)\n# For more complex examples using 2D arrays, see the examples below.\nboard = bb.Board([[0] * 7 for _ in range(6)])  # Also equivalent to an empty board.\n\n# Display the board in text form.\n# The __repr__ method shows the current state (useful for debugging or interactive use).\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n</code></pre></p> <p>The recommended way to initialize an empty board is simply <code>Board()</code>.</p> Example <p>You can also initialize a board with a sequence of moves: <pre><code>import bitbully as bb\n\n# Initialize a board with a sequence of moves played in the center column.\n\n# The list [3, 3, 3] represents three moves in column index 3 (zero-based).\n# Moves alternate automatically between Player 1 (yellow, X) and Player 2 (red, O).\n# After these three moves, the center column will contain:\n#   - Row 0: Player 1 token (bottom)\n#   - Row 1: Player 2 token\n#   - Row 2: Player 1 token\nboard = bb.Board([3, 3, 3])\n\n# Display the resulting board.\n# The textual output shows the tokens placed in the center column.\nboard\n</code></pre></p> <p>Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n</code></pre></p> Example <p>You can also initialize a board using a string containing a move sequence: <pre><code>import bitbully as bb\n\n# Initialize a board using a compact move string.\n\n# The string \"33333111\" represents a sequence of eight moves:\n#   3 3 3 3 3 \u2192 five moves in the center column (index 3)\n#   1 1 1 \u2192 three moves in the second column (index 1)\n#\n# Moves are applied in order, alternating automatically between Player 1 (yellow, X)\n# and Player 2 (red, O), just as if you had called `board.play()` repeatedly.\n#\n# This shorthand is convenient for reproducing board states or test positions\n# without having to provide long move lists.\n\nboard = bb.Board(\"33333111\")\n\n# Display the resulting board.\n# The printed layout shows how the tokens stack in each column.\nboard\n</code></pre></p> <p>Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Example <p>You can also initialize a board using a 2D array (list of lists): <pre><code>import bitbully as bb\n\n# Use a 6 x 7 list (rows x columns) to set up a specific board position manually.\n\n# Each inner list represents a row of the Connect-4 grid.\n# Convention:\n#   - 0 \u2192 empty cell\n#   - 1 \u2192 Player 1 token (yellow, X)\n#   - 2 \u2192 Player 2 token (red, O)\n#\n# The top list corresponds to the *top row* (row index 5),\n# and the bottom list corresponds to the *bottom row* (row index 0).\n# This layout matches the typical visual display of the board.\n\nboard_array = [\n    [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n    [0, 0, 0, 1, 0, 0, 0],  # Row 4: Player 1 token in column 3\n    [0, 0, 0, 2, 0, 0, 0],  # Row 3: Player 2 token in column 3\n    [0, 2, 0, 1, 0, 0, 0],  # Row 2: tokens in columns 1 and 3\n    [0, 1, 0, 2, 0, 0, 0],  # Row 1: tokens in columns 1 and 3\n    [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom): tokens stacked lowest\n]\n\n# Create a Board instance directly from the 2D list.\n# This allows reconstructing arbitrary positions (e.g., from test data or saved states)\n# without replaying the move sequence.\nboard = bb.Board(board_array)\n\n# Display the resulting board state in text form.\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Example <p>You can also initialize a board using a 2D (7 x 6) array with columns as inner lists: <pre><code>import bitbully as bb\n\n# Use a 7 x 6 list (columns x rows) to set up a specific board position manually.\n\n# Each inner list represents a **column** of the Connect-4 board, from left (index 0)\n# to right (index 6). Each column contains six entries \u2014 one for each row, from\n# bottom (index 0) to top (index 5).\n#\n# Convention:\n#   - 0 \u2192 empty cell\n#   - 1 \u2192 Player 1 token (yellow, X)\n#   - 2 \u2192 Player 2 token (red, O)\n#\n# This column-major layout matches the internal representation used by BitBully,\n# where tokens are dropped into columns rather than filled row by row.\n\nboard_array = [\n    [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)\n    [2, 1, 2, 0, 0, 0],  # Column 1\n    [0, 0, 0, 0, 0, 0],  # Column 2\n    [1, 2, 1, 2, 1, 0],  # Column 3 (center)\n    [0, 0, 0, 0, 0, 0],  # Column 4\n    [0, 0, 0, 0, 0, 0],  # Column 5\n    [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)\n]\n\n# Create a Board instance directly from the 2D list.\n# This allows reconstructing any arbitrary position (e.g., test cases, saved games)\n# without replaying all moves individually.\nboard = bb.Board(board_array)\n\n# Display the resulting board.\n# The text output shows tokens as they would appear in a real Connect-4 grid.\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Referenced by: <ul> <li> BitBully API Reference <ul> <li> <code></code>\u00a0board <code></code>\u00a0Board <ul> <li> <code></code>\u00a0from_array </li> <li> <code></code>\u00a0reset_board </li> </ul> </li> <li> <code></code>\u00a0solver <code></code>\u00a0BitBully </li> </ul> </li> </ul> Returned by: <ul> <li> BitBully API Reference <code></code>\u00a0board <code></code>\u00a0Board <ul> <li> <code></code>\u00a0all_positions </li> <li> <code></code>\u00a0copy </li> <li> <code></code>\u00a0from_array </li> <li> <code></code>\u00a0from_moves </li> <li> <code></code>\u00a0mirror </li> <li> <code></code>\u00a0play_on_copy </li> <li> <code></code>\u00a0random_board </li> </ul> </li> </ul> Used by: <ul> <li> BitBully API Reference <ul> <li> <code></code>\u00a0agent_interface <code></code>\u00a0Connect4Agent <ul> <li> <code></code>\u00a0best_move </li> <li> <code></code>\u00a0score_all_moves </li> <li> <code></code>\u00a0score_move </li> </ul> </li> <li> <code></code>\u00a0solver <code></code>\u00a0BitBully <ul> <li> <code></code>\u00a0best_move </li> <li> <code></code>\u00a0mtdf </li> <li> <code></code>\u00a0negamax </li> <li> <code></code>\u00a0null_window </li> <li> <code></code>\u00a0score_all_moves </li> <li> <code></code>\u00a0score_move </li> </ul> </li> </ul> </li> </ul> <p>Methods:</p> Name Description <code>__eq__</code> <p>Checks equality between two Board instances.</p> <code>__hash__</code> <p>Returns a hash of the Board instance for use in hash-based collections.</p> <code>__ne__</code> <p>Checks inequality between two Board instances.</p> <code>__repr__</code> <p>Returns a string representation of the Board instance.</p> <code>__str__</code> <p>Return a human-readable ASCII representation (same as to_string()).</p> <code>all_positions</code> <p>Find all positions reachable from the current position up to a given ply.</p> <code>can_win_next</code> <p>Checks if the current player can win in the next move.</p> <code>copy</code> <p>Creates a copy of the current Board instance.</p> <code>count_tokens</code> <p>Counts the total number of tokens currently placed on the board.</p> <code>current_player</code> <p>Returns the player whose turn it is to move.</p> <code>from_array</code> <p>Creates a board directly from a 2D array representation.</p> <code>from_moves</code> <p>Creates a board by replaying a sequence of moves from the empty position.</p> <code>get_column_height</code> <p>Returns the height of a specific column on the board.</p> <code>get_column_heights</code> <p>Returns a list of heights for each column on the board.</p> <code>has_win</code> <p>Checks if the current player has a winning position.</p> <code>is_full</code> <p>Checks whether the board has any empty cells left.</p> <code>is_game_over</code> <p>Checks whether the game has ended (win or draw).</p> <code>is_legal_move</code> <p>Checks if a move (column) is legal in the current position.</p> <code>legal_moves</code> <p>Returns a list of all legal moves (non-full columns) for the current board state.</p> <code>mirror</code> <p>Returns a new Board instance that is the mirror image of the current board.</p> <code>moves_left</code> <p>Returns the number of moves left until the board is full.</p> <code>play</code> <p>Plays one or more moves for the current player.</p> <code>play_on_copy</code> <p>Return a new board with the given move applied, leaving the current board unchanged.</p> <code>random_board</code> <p>Generates a random board state by playing a specified number of random moves.</p> <code>reset_board</code> <p>Resets the board or sets (overrides) the board to a specific state.</p> <code>to_array</code> <p>Returns the board state as a 2D array (list of lists).</p> <code>to_huffman</code> <p>Encode the current board position into a Huffman-compressed byte sequence.</p> <code>to_string</code> <p>Returns a human-readable ASCII representation of the board.</p> <code>uid</code> <p>Returns a unique identifier for the current board state.</p> <code>winner</code> <p>Returns the winning player, if the game has been won.</p> <p>Attributes:</p> Name Type Description <code>N_COLUMNS</code> <code>int</code> <code>N_ROWS</code> <code>int</code> <code>Player</code> <code>native</code> <code>BoardCore</code> <p>Return the underlying native board representation.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def __init__(self, init_with: Sequence[Sequence[int]] | Sequence[int] | str | None = None) -&gt; None:\n    \"\"\"Initializes a Board instance.\n\n    Args:\n        init_with (Sequence[Sequence[int]] | Sequence[int] | str | None):\n            Optional initial board state. Accepts:\n            - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7\n            - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3])\n            - String: A move sequence of columns as string (e.g., \"002233\")\n            - None for an empty board\n\n    Raises:\n        ValueError: If the provided initial board state is invalid.\n\n    Example:\n        You can initialize an empty board in multiple ways:\n        ```python\n        import bitbully as bb\n\n        # Create an empty board using the default constructor.\n        board = bb.Board()  # Starts with no tokens placed.\n\n        # Alternatively, initialize the board explicitly from a 2D list.\n        # Each inner list represents a column (7 columns total, 6 rows each).\n        # A value of 0 indicates an empty cell; 1 and 2 would represent player tokens.\n        board = bb.Board([[0] * 6 for _ in range(7)])  # Equivalent to an empty board.\n\n        # You can also set up a specific board position manually using a 6 x 7 layout,\n        # where each inner list represents a row instead of a column.\n        # (Both layouts are accepted by BitBully for convenience.)\n        # For more complex examples using 2D arrays, see the examples below.\n        board = bb.Board([[0] * 7 for _ in range(6)])  # Also equivalent to an empty board.\n\n        # Display the board in text form.\n        # The __repr__ method shows the current state (useful for debugging or interactive use).\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        ```\n\n    The recommended way to initialize an empty board is simply `Board()`.\n\n    Example:\n        You can also initialize a board with a sequence of moves:\n        ```python\n        import bitbully as bb\n\n        # Initialize a board with a sequence of moves played in the center column.\n\n        # The list [3, 3, 3] represents three moves in column index 3 (zero-based).\n        # Moves alternate automatically between Player 1 (yellow, X) and Player 2 (red, O).\n        # After these three moves, the center column will contain:\n        #   - Row 0: Player 1 token (bottom)\n        #   - Row 1: Player 2 token\n        #   - Row 2: Player 1 token\n        board = bb.Board([3, 3, 3])\n\n        # Display the resulting board.\n        # The textual output shows the tokens placed in the center column.\n        board\n        ```\n\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        ```\n\n    Example:\n        You can also initialize a board using a string containing a move sequence:\n        ```python\n        import bitbully as bb\n\n        # Initialize a board using a compact move string.\n\n        # The string \"33333111\" represents a sequence of eight moves:\n        #   3 3 3 3 3 \u2192 five moves in the center column (index 3)\n        #   1 1 1 \u2192 three moves in the second column (index 1)\n        #\n        # Moves are applied in order, alternating automatically between Player 1 (yellow, X)\n        # and Player 2 (red, O), just as if you had called `board.play()` repeatedly.\n        #\n        # This shorthand is convenient for reproducing board states or test positions\n        # without having to provide long move lists.\n\n        board = bb.Board(\"33333111\")\n\n        # Display the resulting board.\n        # The printed layout shows how the tokens stack in each column.\n        board\n        ```\n\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n\n    Example:\n        You can also initialize a board using a 2D array (list of lists):\n        ```python\n        import bitbully as bb\n\n        # Use a 6 x 7 list (rows x columns) to set up a specific board position manually.\n\n        # Each inner list represents a row of the Connect-4 grid.\n        # Convention:\n        #   - 0 \u2192 empty cell\n        #   - 1 \u2192 Player 1 token (yellow, X)\n        #   - 2 \u2192 Player 2 token (red, O)\n        #\n        # The top list corresponds to the *top row* (row index 5),\n        # and the bottom list corresponds to the *bottom row* (row index 0).\n        # This layout matches the typical visual display of the board.\n\n        board_array = [\n            [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n            [0, 0, 0, 1, 0, 0, 0],  # Row 4: Player 1 token in column 3\n            [0, 0, 0, 2, 0, 0, 0],  # Row 3: Player 2 token in column 3\n            [0, 2, 0, 1, 0, 0, 0],  # Row 2: tokens in columns 1 and 3\n            [0, 1, 0, 2, 0, 0, 0],  # Row 1: tokens in columns 1 and 3\n            [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom): tokens stacked lowest\n        ]\n\n        # Create a Board instance directly from the 2D list.\n        # This allows reconstructing arbitrary positions (e.g., from test data or saved states)\n        # without replaying the move sequence.\n        board = bb.Board(board_array)\n\n        # Display the resulting board state in text form.\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n\n    Example:\n        You can also initialize a board using a 2D (7 x 6) array with columns as inner lists:\n        ```python\n        import bitbully as bb\n\n        # Use a 7 x 6 list (columns x rows) to set up a specific board position manually.\n\n        # Each inner list represents a **column** of the Connect-4 board, from left (index 0)\n        # to right (index 6). Each column contains six entries \u2014 one for each row, from\n        # bottom (index 0) to top (index 5).\n        #\n        # Convention:\n        #   - 0 \u2192 empty cell\n        #   - 1 \u2192 Player 1 token (yellow, X)\n        #   - 2 \u2192 Player 2 token (red, O)\n        #\n        # This column-major layout matches the internal representation used by BitBully,\n        # where tokens are dropped into columns rather than filled row by row.\n\n        board_array = [\n            [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)\n            [2, 1, 2, 0, 0, 0],  # Column 1\n            [0, 0, 0, 0, 0, 0],  # Column 2\n            [1, 2, 1, 2, 1, 0],  # Column 3 (center)\n            [0, 0, 0, 0, 0, 0],  # Column 4\n            [0, 0, 0, 0, 0, 0],  # Column 5\n            [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)\n        ]\n\n        # Create a Board instance directly from the 2D list.\n        # This allows reconstructing any arbitrary position (e.g., test cases, saved games)\n        # without replaying all moves individually.\n        board = bb.Board(board_array)\n\n        # Display the resulting board.\n        # The text output shows tokens as they would appear in a real Connect-4 grid.\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n    \"\"\"\n    self._board = BoardCore()\n    if init_with is not None and not self.reset_board(init_with):\n        raise ValueError(\n            \"Invalid initial board state provided. Check the examples in the docstring for valid formats.\"\n        )\n</code></pre>"},{"location":"board/#src.bitbully.board.Board(init_with)","title":"<code>init_with</code>","text":""},{"location":"board/#src.bitbully.board.Board.N_COLUMNS","title":"N_COLUMNS  <code>class-attribute</code>","text":"<pre><code>N_COLUMNS: int = N_COLUMNS\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.N_ROWS","title":"N_ROWS  <code>class-attribute</code>","text":"<pre><code>N_ROWS: int = N_ROWS\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.Player","title":"Player  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Player = Player\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.native","title":"native  <code>property</code>","text":"<pre><code>native: BoardCore\n</code></pre> <p>Return the underlying native board representation.</p> <p>This is intended for internal engine integrations and wrappers. Users should treat this as read-only.</p> <p>Returns:</p> Name Type Description <code>BoardCore</code> <code>BoardCore</code> <p>The underlying native <code>BoardCore</code> instance representing the board state.</p> <p>Notes: - The <code>native</code> property exposes the underlying engine representation. - This is intended for engine wrappers (e.g. BitBully) and should be treated as read-only by users.</p>"},{"location":"board/#src.bitbully.board.Board.__eq__","title":"__eq__","text":"<pre><code>__eq__(value: object) -&gt; bool\n</code></pre> <p>Checks equality between two Board instances.</p> Notes <ul> <li>Equality checks in BitBully compare the exact board state (bit patterns),   not just the move history.</li> <li>Two different move sequences can still yield the same position if they   result in identical token configurations.</li> <li>This is useful for comparing solver states, verifying test positions,   or detecting transpositions in search algorithms.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>object</code> <p>The other Board instance to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if both boards are equal, False otherwise.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the other value is not a Board instance.</p> Example <pre><code>import bitbully as bb\n\n# Create two boards that should represent *identical* game states.\nboard1 = bb.Board()\nassert board1.play(\"33333111\")\n\nboard2 = bb.Board()\n# Play the same position step by step using a different but equivalent sequence.\n# Internally, the final bitboard state will match `board1`.\nassert board2.play(\"31133331\")\n\n# Boards with identical token placements are considered equal.\n# Equality (`==`) and inequality (`!=`) operators are overloaded for convenience.\nassert board1 == board2\nassert not (board1 != board2)\n\n# ------------------------------------------------------------------------------\n\n# Create two boards that differ by one move.\nboard1 = bb.Board(\"33333111\")\nboard2 = bb.Board(\"33333112\")  # One extra move in the last column (index 2)\n\n# Since the token layout differs, equality no longer holds.\nassert board1 != board2\nassert not (board1 == board2)\n</code></pre> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0board <code></code>\u00a0Board <code></code>\u00a0__ne__ </li> </ul> Source code in <code>src/bitbully/board.py</code> <pre><code>def __eq__(self, value: object) -&gt; bool:\n    \"\"\"Checks equality between two Board instances.\n\n    Notes:\n        - Equality checks in BitBully compare the *exact board state* (bit patterns),\n          not just the move history.\n        - Two different move sequences can still yield the same position if they\n          result in identical token configurations.\n        - This is useful for comparing solver states, verifying test positions,\n          or detecting transpositions in search algorithms.\n\n    Args:\n        value (object): The other Board instance to compare against.\n\n    Returns:\n        bool: True if both boards are equal, False otherwise.\n\n    Raises:\n        NotImplementedError: If the other value is not a Board instance.\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        # Create two boards that should represent *identical* game states.\n        board1 = bb.Board()\n        assert board1.play(\"33333111\")\n\n        board2 = bb.Board()\n        # Play the same position step by step using a different but equivalent sequence.\n        # Internally, the final bitboard state will match `board1`.\n        assert board2.play(\"31133331\")\n\n        # Boards with identical token placements are considered equal.\n        # Equality (`==`) and inequality (`!=`) operators are overloaded for convenience.\n        assert board1 == board2\n        assert not (board1 != board2)\n\n        # ------------------------------------------------------------------------------\n\n        # Create two boards that differ by one move.\n        board1 = bb.Board(\"33333111\")\n        board2 = bb.Board(\"33333112\")  # One extra move in the last column (index 2)\n\n        # Since the token layout differs, equality no longer holds.\n        assert board1 != board2\n        assert not (board1 == board2)\n        ```\n    \"\"\"\n    if not isinstance(value, Board):\n        raise NotImplementedError(\"Can only compare with another Board instance.\")\n    return bool(self._board == value._board)\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.__eq__(value)","title":"<code>value</code>","text":""},{"location":"board/#src.bitbully.board.Board.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Returns a hash of the Board instance for use in hash-based collections.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The hash value of the Board instance.</p> Example <p><pre><code>import bitbully as bb\n\n# Create two boards that represent the same final position.\n# The first board is initialized directly from a move string.\nboard1 = bb.Board(\"33333111\")\n\n# The second board is built incrementally by playing an equivalent sequence of moves.\n# Even though the order of intermediate plays differs, the final layout of tokens\n# (and thus the internal bitboard state) will be identical to `board1`.\nboard2 = bb.Board()\nboard2.play(\"31133331\")\n\n# Boards with identical configurations produce the same hash value.\n# This allows them to be used efficiently as keys in dictionaries or members of sets.\nassert hash(board1) == hash(board2)\n\n# Display the board's hash value.\nhash(board1)\n</code></pre> Expected output: <pre><code>971238920548618160\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Returns a hash of the Board instance for use in hash-based collections.\n\n    Returns:\n        int: The hash value of the Board instance.\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        # Create two boards that represent the same final position.\n        # The first board is initialized directly from a move string.\n        board1 = bb.Board(\"33333111\")\n\n        # The second board is built incrementally by playing an equivalent sequence of moves.\n        # Even though the order of intermediate plays differs, the final layout of tokens\n        # (and thus the internal bitboard state) will be identical to `board1`.\n        board2 = bb.Board()\n        board2.play(\"31133331\")\n\n        # Boards with identical configurations produce the same hash value.\n        # This allows them to be used efficiently as keys in dictionaries or members of sets.\n        assert hash(board1) == hash(board2)\n\n        # Display the board's hash value.\n        hash(board1)\n        ```\n        Expected output:\n        ```text\n        971238920548618160\n        ```\n    \"\"\"\n    return self._board.hash()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.__ne__","title":"__ne__","text":"<pre><code>__ne__(value: object) -&gt; bool\n</code></pre> <p>Checks inequality between two Board instances.</p> <p>See the documentation for Board.eq for details.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <p>The other Board instance to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if both boards are not equal, False otherwise.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def __ne__(self, value: object) -&gt; bool:\n    \"\"\"Checks inequality between two Board instances.\n\n    See the documentation for [Board.__eq__][src.bitbully.board.Board.__eq__] for details.\n\n    Args:\n        value (object): The other Board instance to compare against.\n\n    Returns:\n        bool: True if both boards are not equal, False otherwise.\n    \"\"\"\n    return not self.__eq__(value)\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.__ne__(value)","title":"<code>value</code>","text":""},{"location":"board/#src.bitbully.board.Board.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Returns a string representation of the Board instance.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Returns a string representation of the Board instance.\"\"\"\n    return f\"{self._board}\"\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a human-readable ASCII representation (same as to_string()).</p> <p>See the documentation for Board.to_string for details.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a human-readable ASCII representation (same as to_string()).\n\n    See the documentation for [Board.to_string][src.bitbully.board.Board.to_string] for details.\n    \"\"\"\n    return self.to_string()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.all_positions","title":"all_positions","text":"<pre><code>all_positions(up_to_n_ply: int, exactly_n: bool) -&gt; list[Board]\n</code></pre> <p>Find all positions reachable from the current position up to a given ply.</p> <p>This is a high-level wrapper around <code>bitbully_core.BoardCore.allPositions</code>.</p> <p>Starting from the current board, it generates all positions that can be reached by playing additional moves such that the resulting position has:</p> <ul> <li>At most <code>up_to_n_ply</code> tokens on the board, if <code>exactly_n</code> is <code>False</code>.</li> <li>Exactly <code>up_to_n_ply</code> tokens on the board, if <code>exactly_n</code> is <code>True</code>.</li> </ul> Note <p>The number of tokens already present in the current position is taken into account. If <code>up_to_n_ply</code> is smaller than <code>self.count_tokens()</code>, the result is typically empty.</p> <p>This function can grow combinatorially with <code>up_to_n_ply</code> and the current position, so use it with care for large depths.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The maximum total number of tokens (ply) for generated positions. Must be between 0 and 42 (inclusive).</p> required <code>bool</code> <p>If <code>True</code>, only positions with exactly <code>up_to_n_ply</code> tokens are returned. If <code>False</code>, all positions with a token count between the current number of tokens and <code>up_to_n_ply</code> are included.</p> required <p>Returns:</p> Type Description <code>list[Board]</code> <p>list[Board]: A list of :class:<code>Board</code> instances representing all</p> <code>list[Board]</code> <p>reachable positions that satisfy the ply constraint.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>up_to_n_ply</code> is outside the range <code>[0, 42]</code>.</p> Example <p>Compute all positions at exactly 3 ply from the empty board:</p> <pre><code>import bitbully as bb\n\n# Start from an empty board.\nboard = bb.Board()\n\n# Generate all positions that contain exactly 3 tokens.\npositions = board.all_positions(3, exactly_n=True)\n\n# According to OEIS A212693, there are exactly 238 distinct\n# reachable positions with 3 played moves in standard Connect-4.\nassert len(positions) == 238\n</code></pre> <p>Reference:     - Number of distinct positions at ply n:       https://oeis.org/A212693</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def all_positions(self, up_to_n_ply: int, exactly_n: bool) -&gt; list[Board]:\n    \"\"\"Find all positions reachable from the current position up to a given ply.\n\n    This is a high-level wrapper around\n    `bitbully_core.BoardCore.allPositions`.\n\n    Starting from the **current** board, it generates all positions that can be\n    reached by playing additional moves such that the resulting position has:\n\n    - At most ``up_to_n_ply`` tokens on the board, if ``exactly_n`` is ``False``.\n    - Exactly ``up_to_n_ply`` tokens on the board, if ``exactly_n`` is ``True``.\n\n    Note:\n        The number of tokens already present in the current position is taken\n        into account. If ``up_to_n_ply`` is smaller than\n        ``self.count_tokens()``, the result is typically empty.\n\n        This function can grow combinatorially with ``up_to_n_ply`` and the\n        current position, so use it with care for large depths.\n\n    Args:\n        up_to_n_ply (int):\n            The maximum total number of tokens (ply) for generated positions.\n            Must be between 0 and 42 (inclusive).\n        exactly_n (bool):\n            If ``True``, only positions with exactly ``up_to_n_ply`` tokens\n            are returned. If ``False``, all positions with a token count\n            between the current number of tokens and ``up_to_n_ply`` are\n            included.\n\n    Returns:\n        list[Board]: A list of :class:`Board` instances representing all\n        reachable positions that satisfy the ply constraint.\n\n    Raises:\n        ValueError: If ``up_to_n_ply`` is outside the range ``[0, 42]``.\n\n    Example:\n        Compute all positions at exactly 3 ply from the empty board:\n\n        ```python\n        import bitbully as bb\n\n        # Start from an empty board.\n        board = bb.Board()\n\n        # Generate all positions that contain exactly 3 tokens.\n        positions = board.all_positions(3, exactly_n=True)\n\n        # According to OEIS A212693, there are exactly 238 distinct\n        # reachable positions with 3 played moves in standard Connect-4.\n        assert len(positions) == 238\n        ```\n\n        Reference:\n            - Number of distinct positions at ply *n*:\n              https://oeis.org/A212693\n\n    \"\"\"\n    if not 0 &lt;= up_to_n_ply &lt;= 42:\n        raise ValueError(f\"up_to_n_ply must be between 0 and 42 (inclusive), got {up_to_n_ply}.\")\n\n    # Delegate to the C++ core, which returns a list of BoardCore objects.\n    core_positions = self._board.allPositions(up_to_n_ply, exactly_n)\n\n    # Wrap each BoardCore in a high-level Board instance.\n    positions: list[Board] = []\n    for core_board in core_positions:\n        b = Board()  # start with an empty high-level Board\n        b._board = core_board  # replace its internal BoardCore\n        positions.append(b)\n\n    return positions\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.all_positions(up_to_n_ply)","title":"<code>up_to_n_ply</code>","text":""},{"location":"board/#src.bitbully.board.Board.all_positions(exactly_n)","title":"<code>exactly_n</code>","text":""},{"location":"board/#src.bitbully.board.Board.can_win_next","title":"can_win_next","text":"<pre><code>can_win_next(move: int | None = None) -&gt; bool\n</code></pre> <p>Checks if the current player can win in the next move.</p> <p>Parameters:</p> Name Type Description Default <code>int | None</code> <p>Optional column to check for an immediate win. If None, checks all columns.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the current player can win next, False otherwise.</p> <p>See also: <code>Board.has_win</code>.</p> Example <p><pre><code>import bitbully as bb\n\n# Create a board from a move string.\n# The string \"332311\" represents a short sequence of alternating moves\n# that results in a nearly winning position for Player 1 (yellow, X).\nboard = bb.Board(\"332311\")\n\n# Display the current board state (see below)\nprint(board)\n\n# Player 1 (yellow, X) \u2014 who is next to move \u2014 can win immediately\n# by placing a token in either column 0 or column 4.\nassert board.can_win_next(0)\nassert board.can_win_next(4)\n\n# However, playing in other columns does not result in an instant win.\nassert not board.can_win_next(2)\nassert not board.can_win_next(3)\n\n# You can also call `can_win_next()` without arguments to perform a general check.\n# It returns True if the current player has *any* winning move available.\nassert board.can_win_next()\n</code></pre> The board we created above looks like this: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  O  _  _  _\n_  O  _  O  _  _  _\n_  X  X  X  _  _  _\n</code></pre></p> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0board <code></code>\u00a0Board <code></code>\u00a0has_win </li> </ul> Source code in <code>src/bitbully/board.py</code> <pre><code>def can_win_next(self, move: int | None = None) -&gt; bool:\n    \"\"\"Checks if the current player can win in the next move.\n\n    Args:\n        move (int | None): Optional column to check for an immediate win. If None, checks all columns.\n\n    Returns:\n        bool: True if the current player can win next, False otherwise.\n\n    See also: [`Board.has_win`][src.bitbully.board.Board.has_win].\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        # Create a board from a move string.\n        # The string \"332311\" represents a short sequence of alternating moves\n        # that results in a nearly winning position for Player 1 (yellow, X).\n        board = bb.Board(\"332311\")\n\n        # Display the current board state (see below)\n        print(board)\n\n        # Player 1 (yellow, X) \u2014 who is next to move \u2014 can win immediately\n        # by placing a token in either column 0 or column 4.\n        assert board.can_win_next(0)\n        assert board.can_win_next(4)\n\n        # However, playing in other columns does not result in an instant win.\n        assert not board.can_win_next(2)\n        assert not board.can_win_next(3)\n\n        # You can also call `can_win_next()` without arguments to perform a general check.\n        # It returns True if the current player has *any* winning move available.\n        assert board.can_win_next()\n        ```\n        The board we created above looks like this:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  O  _  _  _\n        _  X  X  X  _  _  _\n        ```\n    \"\"\"\n    if move is None:\n        return self._board.canWin()\n    return bool(self._board.canWin(move))\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.can_win_next(move)","title":"<code>move</code>","text":""},{"location":"board/#src.bitbully.board.Board.copy","title":"copy","text":"<pre><code>copy() -&gt; Board\n</code></pre> <p>Creates a copy of the current Board instance.</p> <p>The <code>copy()</code> method returns a new <code>Board</code> object that represents the same position as the original at the time of copying. Subsequent changes to one board do not affect the other \u2014 they are completely independent.</p> <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>A new Board instance that is a copy of the current one.</p> Example <p>Create a board, copy it, and verify that both represent the same position: <pre><code>import bitbully as bb\n\n# Create a board from a compact move string.\nboard = bb.Board(\"33333111\")\n\n# Create an independent copy of the current position.\nboard_copy = board.copy()\n\n# Both boards represent the same position and are considered equal.\nassert board == board_copy\nassert hash(board) == hash(board_copy)\nassert board.to_string() == board_copy.to_string()\n\n# Display the board state.\nprint(board)\n</code></pre> Expected output (both boards print the same position): <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Example <p>Modifying the copy does not affect the original: <pre><code>import bitbully as bb\n\nboard = bb.Board(\"33333111\")\n\n# Create a copy of the current position.\nboard_copy = board.copy()\n\n# Play an additional move on the copied board only.\nassert board_copy.play(0)  # Drop a token into the leftmost column.\n\n# Now the boards represent different positions.\nassert board != board_copy\n\n# The original board remains unchanged.\nprint(\"Original:\")\nprint(board)\n\nprint(\"Modified copy:\")\nprint(board_copy)\n</code></pre> Expected output: <pre><code>Original:\n\n_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n\nModified copy:\n\n_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\nX  O  _  X  _  _  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def copy(self) -&gt; Board:\n    \"\"\"Creates a copy of the current Board instance.\n\n    The `copy()` method returns a new `Board` object that represents the\n    *same position* as the original at the time of copying. Subsequent\n    changes to one board do **not** affect the other \u2014 they are completely\n    independent.\n\n    Returns:\n        Board: A new Board instance that is a copy of the current one.\n\n    Example:\n        Create a board, copy it, and verify that both represent the same position:\n        ```python\n        import bitbully as bb\n\n        # Create a board from a compact move string.\n        board = bb.Board(\"33333111\")\n\n        # Create an independent copy of the current position.\n        board_copy = board.copy()\n\n        # Both boards represent the same position and are considered equal.\n        assert board == board_copy\n        assert hash(board) == hash(board_copy)\n        assert board.to_string() == board_copy.to_string()\n\n        # Display the board state.\n        print(board)\n        ```\n        Expected output (both boards print the same position):\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n\n    Example:\n        Modifying the copy does not affect the original:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board(\"33333111\")\n\n        # Create a copy of the current position.\n        board_copy = board.copy()\n\n        # Play an additional move on the copied board only.\n        assert board_copy.play(0)  # Drop a token into the leftmost column.\n\n        # Now the boards represent different positions.\n        assert board != board_copy\n\n        # The original board remains unchanged.\n        print(\"Original:\")\n        print(board)\n\n        print(\"Modified copy:\")\n        print(board_copy)\n        ```\n        Expected output:\n        ```text\n        Original:\n\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n\n        Modified copy:\n\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        X  O  _  X  _  _  _\n        ```\n    \"\"\"\n    new_board = Board()\n    new_board._board = self._board.copy()\n    return new_board\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.count_tokens","title":"count_tokens","text":"<pre><code>count_tokens() -&gt; int\n</code></pre> <p>Counts the total number of tokens currently placed on the board.</p> <p>This method simply returns how many moves have been played so far in the current position \u2014 that is, the number of occupied cells on the 7x6 grid.</p> <p>It does not distinguish between players; it only reports the total number of tokens, regardless of whether they belong to Player 1 or Player 2.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The total number of tokens on the board (between 0 and 42).</p> Example <p>Count tokens on an empty board: <pre><code>import bitbully as bb\n\nboard = bb.Board()  # No moves played yet.\nassert board.count_tokens() == 0\n\n# The board is completely empty.\nprint(board)\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n</code></pre></p> Example <p>Count tokens after a few moves: <pre><code>import bitbully as bb\n\n# Play three moves in the center column (index 3).\nboard = bb.Board()\nassert board.play([3, 3, 3])\n\n# Three tokens have been placed on the board.\nassert board.count_tokens() == 3\n\nprint(board)\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n</code></pre></p> Example <p>Relation to the length of a move sequence: <pre><code>import bitbully as bb\n\nmoves = \"33333111\"  # 8 moves in total\nboard = bb.Board(moves)\n\n# The number of tokens on the board always matches\n# the number of moves that have been played.\n# (as long as the input was valid)\nassert board.count_tokens() == len(moves)\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def count_tokens(self) -&gt; int:\n    \"\"\"Counts the total number of tokens currently placed on the board.\n\n    This method simply returns how many moves have been played so far in the\n    current position \u2014 that is, the number of occupied cells on the 7x6 grid.\n\n    It does **not** distinguish between players; it only reports the total\n    number of tokens, regardless of whether they belong to Player 1 or Player 2.\n\n    Returns:\n        int: The total number of tokens on the board (between 0 and 42).\n\n    Example:\n        Count tokens on an empty board:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()  # No moves played yet.\n        assert board.count_tokens() == 0\n\n        # The board is completely empty.\n        print(board)\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        ```\n\n    Example:\n        Count tokens after a few moves:\n        ```python\n        import bitbully as bb\n\n        # Play three moves in the center column (index 3).\n        board = bb.Board()\n        assert board.play([3, 3, 3])\n\n        # Three tokens have been placed on the board.\n        assert board.count_tokens() == 3\n\n        print(board)\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        ```\n\n    Example:\n        Relation to the length of a move sequence:\n        ```python\n        import bitbully as bb\n\n        moves = \"33333111\"  # 8 moves in total\n        board = bb.Board(moves)\n\n        # The number of tokens on the board always matches\n        # the number of moves that have been played.\n        # (as long as the input was valid)\n        assert board.count_tokens() == len(moves)\n        ```\n    \"\"\"\n    return self._board.countTokens()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.current_player","title":"current_player","text":"<pre><code>current_player() -&gt; int\n</code></pre> <p>Returns the player whose turn it is to move.</p> <p>The current player is derived from the parity of the number of tokens on the board:</p> <ul> <li>Player 1 (yellow, <code>X</code>) moves first on an empty board.</li> <li>After an even number of moves \u2192 it is Player 1's turn.</li> <li>After an odd  number of moves \u2192 it is Player 2's turn.</li> </ul> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The player to move:</p> <ul> <li><code>1</code> \u2192 Player 1 (yellow, <code>X</code>)</li> <li><code>2</code> \u2192 Player 2 (red, <code>O</code>)</li> </ul> Example <pre><code>import bitbully as bb\n\n# Empty board \u2192 Player 1 starts.\nboard = bb.Board()\nassert board.current_player() == 1\nassert board.count_tokens() == 0\n\n# After one move, it's Player 2's turn.\nassert board.play(3)\nassert board.count_tokens() == 1\nassert board.current_player() == 2\n\n# After a second move, it's again Player 1's turn.\nassert board.play(4)\nassert board.count_tokens() == 2\nassert board.current_player() == 1\n</code></pre> Source code in <code>src/bitbully/board.py</code> <pre><code>def current_player(self) -&gt; int:\n    \"\"\"Returns the player whose turn it is to move.\n\n    The current player is derived from the **parity** of the number of tokens\n    on the board:\n\n    - Player 1 (yellow, ``X``) moves first on an empty board.\n    - After an even number of moves \u2192 it is Player 1's turn.\n    - After an odd  number of moves \u2192 it is Player 2's turn.\n\n    Returns:\n        int:\n            The player to move:\n\n            - ``1`` \u2192 Player 1 (yellow, ``X``)\n            - ``2`` \u2192 Player 2 (red, ``O``)\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        # Empty board \u2192 Player 1 starts.\n        board = bb.Board()\n        assert board.current_player() == 1\n        assert board.count_tokens() == 0\n\n        # After one move, it's Player 2's turn.\n        assert board.play(3)\n        assert board.count_tokens() == 1\n        assert board.current_player() == 2\n\n        # After a second move, it's again Player 1's turn.\n        assert board.play(4)\n        assert board.count_tokens() == 2\n        assert board.current_player() == 1\n        ```\n    \"\"\"\n    # Empty board: Player 1\n    return 1 if self.count_tokens() % 2 == 0 else 2\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.from_array","title":"from_array  <code>classmethod</code>","text":"<pre><code>from_array(arr: Sequence[Sequence[int]]) -&gt; Board\n</code></pre> <p>Creates a board directly from a 2D array representation.</p> <p>This is a convenience wrapper around the main constructor board.Board and accepts the same array formats:</p> <ul> <li>Row-major: 6 x 7 (<code>[row][column]</code>), top row first.</li> <li>Column-major: 7 x 6 (<code>[column][row]</code>), left column first.</li> </ul> <p>Values must follow the usual convention:</p> <ul> <li><code>0</code> \u2192 empty cell</li> <li><code>1</code> \u2192 Player 1 token (yellow, <code>X</code>)</li> <li><code>2</code> \u2192 Player 2 token (red, <code>O</code>)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>Sequence[Sequence[int]]</code> <p>A 2D array describing the board state, either in row-major or column-major layout. See the examples in Board for details.</p> required <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>A new <code>Board</code> instance representing the given layout.</p> Example <p>Using a 6 x 7 row-major layout: <pre><code>import bitbully as bb\n\nboard_array = [\n    [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n    [0, 0, 0, 1, 0, 0, 0],  # Row 4\n    [0, 0, 0, 2, 0, 0, 0],  # Row 3\n    [0, 2, 0, 1, 0, 0, 0],  # Row 2\n    [0, 1, 0, 2, 0, 0, 0],  # Row 1\n    [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom)\n]\n\nboard = bb.Board.from_array(board_array)\nprint(board)\n</code></pre></p> Example <p>Using a 7 x 6 column-major layout: <pre><code>import bitbully as bb\n\nboard_array = [\n    [0, 0, 0, 0, 0, 0],  # Column 0\n    [2, 1, 2, 1, 0, 0],  # Column 1\n    [0, 0, 0, 0, 0, 0],  # Column 2\n    [1, 2, 1, 2, 1, 0],  # Column 3\n    [0, 0, 0, 0, 0, 0],  # Column 4\n    [2, 1, 2, 0, 0, 0],  # Column 5\n    [0, 0, 0, 0, 0, 0],  # Column 6\n]\n\nboard = bb.Board.from_array(board_array)\n\n# Round-trip via to_array:\nassert board.to_array() == board_array\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>@classmethod\ndef from_array(cls, arr: Sequence[Sequence[int]]) -&gt; Board:\n    \"\"\"Creates a board directly from a 2D array representation.\n\n    This is a convenience wrapper around the main constructor [board.Board][src.bitbully.board.Board]\n    and accepts the same array formats:\n\n    - **Row-major**: 6 x 7 (``[row][column]``), top row first.\n    - **Column-major**: 7 x 6 (``[column][row]``), left column first.\n\n    Values must follow the usual convention:\n\n    - ``0`` \u2192 empty cell\n    - ``1`` \u2192 Player 1 token (yellow, ``X``)\n    - ``2`` \u2192 Player 2 token (red, ``O``)\n\n    Args:\n        arr (Sequence[Sequence[int]]):\n            A 2D array describing the board state, either in row-major or\n            column-major layout. See the examples in\n            [Board][src.bitbully.board.Board] for details.\n\n    Returns:\n        Board:\n            A new `Board` instance representing the given layout.\n\n    Example:\n        Using a 6 x 7 row-major layout:\n        ```python\n        import bitbully as bb\n\n        board_array = [\n            [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n            [0, 0, 0, 1, 0, 0, 0],  # Row 4\n            [0, 0, 0, 2, 0, 0, 0],  # Row 3\n            [0, 2, 0, 1, 0, 0, 0],  # Row 2\n            [0, 1, 0, 2, 0, 0, 0],  # Row 1\n            [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom)\n        ]\n\n        board = bb.Board.from_array(board_array)\n        print(board)\n        ```\n\n    Example:\n        Using a 7 x 6 column-major layout:\n        ```python\n        import bitbully as bb\n\n        board_array = [\n            [0, 0, 0, 0, 0, 0],  # Column 0\n            [2, 1, 2, 1, 0, 0],  # Column 1\n            [0, 0, 0, 0, 0, 0],  # Column 2\n            [1, 2, 1, 2, 1, 0],  # Column 3\n            [0, 0, 0, 0, 0, 0],  # Column 4\n            [2, 1, 2, 0, 0, 0],  # Column 5\n            [0, 0, 0, 0, 0, 0],  # Column 6\n        ]\n\n        board = bb.Board.from_array(board_array)\n\n        # Round-trip via to_array:\n        assert board.to_array() == board_array\n        ```\n    \"\"\"\n    return cls(arr)\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.from_array(arr)","title":"<code>arr</code>","text":""},{"location":"board/#src.bitbully.board.Board.from_moves","title":"from_moves  <code>classmethod</code>","text":"<pre><code>from_moves(moves: Sequence[int] | str) -&gt; Board\n</code></pre> <p>Creates a board by replaying a sequence of moves from the empty position.</p> <p>This is a convenience constructor around Board.play. It starts from an empty board and applies the given move sequence, assuming it is legal (no out-of-range columns, no moves in full columns, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>Sequence[int] | str</code> <p>The move sequence to replay from the starting position. Accepts:</p> <ul> <li>A sequence of integers (e.g. <code>[3, 3, 3, 1]</code>)</li> <li>A string of digits (e.g. <code>\"3331\"</code>)</li> </ul> <p>Each value represents a column index (0-6). Players alternate automatically between moves.</p> required <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>A new <code>Board</code> instance representing the final position after all moves have been applied.</p> Example <pre><code>import bitbully as bb\n\n# Create a position directly from a compact move string.\nboard = bb.Board.from_moves(\"33333111\")\n\n# Equivalent to:\n# board = bb.Board()\n# assert board.play(\"33333111\")\n\nprint(board)\nassert board.count_tokens() == 8\nassert not board.has_win()\n</code></pre> Source code in <code>src/bitbully/board.py</code> <pre><code>@classmethod\ndef from_moves(cls, moves: Sequence[int] | str) -&gt; Board:\n    \"\"\"Creates a board by replaying a sequence of moves from the empty position.\n\n    This is a convenience constructor around [Board.play][src.bitbully.board.Board.play].\n    It starts from an empty board and applies the given move sequence, assuming\n    it is **legal** (no out-of-range columns, no moves in full columns, etc.).\n\n    Args:\n        moves (Sequence[int] | str):\n            The move sequence to replay from the starting position. Accepts:\n\n            - A sequence of integers (e.g. ``[3, 3, 3, 1]``)\n            - A string of digits (e.g. ``\"3331\"``)\n\n            Each value represents a column index (0-6). Players alternate\n            automatically between moves.\n\n    Returns:\n        Board:\n            A new `Board` instance representing the final position\n            after all moves have been applied.\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        # Create a position directly from a compact move string.\n        board = bb.Board.from_moves(\"33333111\")\n\n        # Equivalent to:\n        # board = bb.Board()\n        # assert board.play(\"33333111\")\n\n        print(board)\n        assert board.count_tokens() == 8\n        assert not board.has_win()\n        ```\n    \"\"\"\n    board = cls()\n    assert board.play(moves)\n    return board\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.from_moves(moves)","title":"<code>moves</code>","text":""},{"location":"board/#src.bitbully.board.Board.get_column_height","title":"get_column_height","text":"<pre><code>get_column_height(column: int) -&gt; int\n</code></pre> <p>Returns the height of a specific column on the board.</p> <p>The height of a column is defined as the number of tokens currently present in that column.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The column index (0-6) for which to retrieve the height.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The height of the specified column (0-6).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the <code>column</code> index is outside the valid range [0, 6].</p> Example <pre><code>import bitbully as bb\n\nboard = bb.Board(\"0011223\")\nheight = board.get_column_height(2)\nassert height == 2\n</code></pre> Source code in <code>src/bitbully/board.py</code> <pre><code>def get_column_height(self, column: int) -&gt; int:\n    \"\"\"Returns the height of a specific column on the board.\n\n    The height of a column is defined as the number of tokens currently\n    present in that column.\n\n    Args:\n        column (int): The column index (0-6) for which to retrieve the height.\n\n    Returns:\n        int: The height of the specified column (0-6).\n\n    Raises:\n        ValueError: If the `column` index is outside the valid range [0, 6].\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board(\"0011223\")\n        height = board.get_column_height(2)\n        assert height == 2\n        ```\n    \"\"\"\n    if not (0 &lt;= column &lt;= 6):\n        raise ValueError(f\"Column index must be between 0 and 6, got {column}.\")\n    return self._board.getColumnHeight(column)\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.get_column_height(column)","title":"<code>column</code>","text":""},{"location":"board/#src.bitbully.board.Board.get_column_heights","title":"get_column_heights","text":"<pre><code>get_column_heights() -&gt; list[int]\n</code></pre> <p>Returns a list of heights for each column on the board.</p> <p>The height of a column is defined as the number of tokens currently present in that column.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: A list of 7 integers, where each integer represents</p> <code>list[int]</code> <p>the height of the corresponding column (0-6).</p> Example <pre><code>import bitbully as bb\n\nboard = bb.Board(\"0011223\")\nheights = board.get_column_heights()\nassert heights == [2, 2, 2, 1, 0, 0, 0]\n</code></pre> Source code in <code>src/bitbully/board.py</code> <pre><code>def get_column_heights(self) -&gt; list[int]:\n    \"\"\"Returns a list of heights for each column on the board.\n\n    The height of a column is defined as the number of tokens currently\n    present in that column.\n\n    Returns:\n        list[int]: A list of 7 integers, where each integer represents\n        the height of the corresponding column (0-6).\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board(\"0011223\")\n        heights = board.get_column_heights()\n        assert heights == [2, 2, 2, 1, 0, 0, 0]\n        ```\n    \"\"\"\n    return [self._board.getColumnHeight(col) for col in range(7)]\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.has_win","title":"has_win","text":"<pre><code>has_win() -&gt; bool\n</code></pre> <p>Checks if the current player has a winning position.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the current player has a winning position (4-in-a-row), False otherwise.</p> <p>Unlike <code>can_win_next()</code>, which checks whether the current player could win on their next move, the <code>has_win()</code> method determines whether a winning condition already exists on the board. This method is typically used right after a move to verify whether the game has been won.</p> <p>See also: <code>Board.can_win_next</code>.</p> Example <p><pre><code>import bitbully as bb\n\n# Initialize a board from a move sequence.\n# The string \"332311\" represents a position where Player 1 (yellow, X)\n# is one move away from winning.\nboard = bb.Board(\"332311\")\n\n# At this stage, Player 1 has not yet won, but can win immediately\n# by placing a token in either column 0 or column 4.\nassert not board.has_win()\nassert board.can_win_next(0)  # Check column 0\nassert board.can_win_next(4)  # Check column 4\nassert board.can_win_next()  # General check (any winning move)\n\n# Simulate Player 1 playing in column 4 \u2014 this completes\n# a horizontal line of four tokens and wins the game.\nassert board.play(4)\n\n# Display the updated board to visualize the winning position.\nprint(board)\n\n# The board now contains a winning configuration:\n# Player 1 (yellow, X) has achieved a Connect-4.\nassert board.has_win()\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  O  _  _  _\n_  O  _  O  _  _  _\n_  X  X  X  X  _  _\n</code></pre></p> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0board <code></code>\u00a0Board <ul> <li> <code></code>\u00a0can_win_next </li> <li> <code></code>\u00a0is_game_over </li> <li> <code></code>\u00a0is_legal_move </li> <li> <code></code>\u00a0winner </li> </ul> </li> </ul> Source code in <code>src/bitbully/board.py</code> <pre><code>def has_win(self) -&gt; bool:\n    \"\"\"Checks if the current player has a winning position.\n\n    Returns:\n        bool: True if the current player has a winning position (4-in-a-row), False otherwise.\n\n    Unlike `can_win_next()`, which checks whether the current player *could* win\n    on their next move, the `has_win()` method determines whether a winning\n    condition already exists on the board.\n    This method is typically used right after a move to verify whether the game\n    has been won.\n\n    See also: [`Board.can_win_next`][src.bitbully.board.Board.can_win_next].\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        # Initialize a board from a move sequence.\n        # The string \"332311\" represents a position where Player 1 (yellow, X)\n        # is one move away from winning.\n        board = bb.Board(\"332311\")\n\n        # At this stage, Player 1 has not yet won, but can win immediately\n        # by placing a token in either column 0 or column 4.\n        assert not board.has_win()\n        assert board.can_win_next(0)  # Check column 0\n        assert board.can_win_next(4)  # Check column 4\n        assert board.can_win_next()  # General check (any winning move)\n\n        # Simulate Player 1 playing in column 4 \u2014 this completes\n        # a horizontal line of four tokens and wins the game.\n        assert board.play(4)\n\n        # Display the updated board to visualize the winning position.\n        print(board)\n\n        # The board now contains a winning configuration:\n        # Player 1 (yellow, X) has achieved a Connect-4.\n        assert board.has_win()\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  O  _  _  _\n        _  X  X  X  X  _  _\n        ```\n    \"\"\"\n    return self._board.hasWin()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.is_full","title":"is_full","text":"<pre><code>is_full() -&gt; bool\n</code></pre> <p>Checks whether the board has any empty cells left.</p> <p>A Connect Four board has 42 cells in total (7 columns x 6 rows). This method returns <code>True</code> if all cells are occupied, i.e. when  Board.moves_left returns <code>0</code>.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the board is completely full (no more legal moves possible), otherwise <code>False</code>.</p> Example <pre><code>import bitbully as bb\n\nboard = bb.Board()\nassert not board.is_full()\nassert board.moves_left() == 42\nassert board.count_tokens() == 0\n\n# Fill the board column by column.\nfor _ in range(6):\n    assert board.play(\"0123456\")  # one token per column, per row\n\n# Now every cell is occupied.\nassert board.is_full()\nassert board.moves_left() == 0\nassert board.count_tokens() == 42\n</code></pre> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0board <code></code>\u00a0Board <code></code>\u00a0is_game_over </li> </ul> Source code in <code>src/bitbully/board.py</code> <pre><code>def is_full(self) -&gt; bool:\n    \"\"\"Checks whether the board has any empty cells left.\n\n    A Connect Four board has 42 cells in total (7 columns x 6 rows).\n    This method returns ``True`` if **all** cells are occupied, i.e.\n    when  [Board.moves_left][src.bitbully.board.Board.moves_left] returns ``0``.\n\n    Returns:\n        bool:\n            ``True`` if the board is completely full\n            (no more legal moves possible), otherwise ``False``.\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        assert not board.is_full()\n        assert board.moves_left() == 42\n        assert board.count_tokens() == 0\n\n        # Fill the board column by column.\n        for _ in range(6):\n            assert board.play(\"0123456\")  # one token per column, per row\n\n        # Now every cell is occupied.\n        assert board.is_full()\n        assert board.moves_left() == 0\n        assert board.count_tokens() == 42\n        ```\n    \"\"\"\n    return self.moves_left() == 0\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.is_game_over","title":"is_game_over","text":"<pre><code>is_game_over() -&gt; bool\n</code></pre> <p>Checks whether the game has ended (win or draw).</p> <p>A game of Connect Four is considered over if:</p> <ul> <li>One of the players has a winning position   (see Board.has_win), or</li> <li>The board is completely full and no further moves can be played   (see Board.is_full).</li> </ul> <p>This method does not indicate who won; for that, use Board.winner.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the game is over (win or draw), otherwise <code>False</code>.</p> Example <p>Game over by a win: <pre><code>import bitbully as bb\n\n# Player 1 (X) wins horizontally on the bottom row.\nboard = bb.Board()\nassert board.play(\"0101010\")\n\nassert board.has_win()\nassert board.is_game_over()\nassert board.winner() == 1\n</code></pre></p> Example <p>Game over by a draw (full board, no winner): <pre><code>import bitbully as bb\n\nboard, _ = bb.Board.random_board(42, forbid_direct_win=False)\n\nassert board.is_full()\nassert not board.has_win()\nassert board.is_game_over()\nassert board.winner() is None\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def is_game_over(self) -&gt; bool:\n    \"\"\"Checks whether the game has ended (win or draw).\n\n    A game of Connect Four is considered **over** if:\n\n    - One of the players has a winning position\n      (see [Board.has_win][src.bitbully.board.Board.has_win]), **or**\n    - The board is completely full and no further moves can be played\n      (see [Board.is_full][src.bitbully.board.Board.is_full]).\n\n    This method does **not** indicate *who* won; for that, use\n    [Board.winner][src.bitbully.board.Board.winner].\n\n    Returns:\n        bool:\n            ``True`` if the game is over (win or draw), otherwise ``False``.\n\n    Example:\n        Game over by a win:\n        ```python\n        import bitbully as bb\n\n        # Player 1 (X) wins horizontally on the bottom row.\n        board = bb.Board()\n        assert board.play(\"0101010\")\n\n        assert board.has_win()\n        assert board.is_game_over()\n        assert board.winner() == 1\n        ```\n\n    Example:\n        Game over by a draw (full board, no winner):\n        ```python\n        import bitbully as bb\n\n        board, _ = bb.Board.random_board(42, forbid_direct_win=False)\n\n        assert board.is_full()\n        assert not board.has_win()\n        assert board.is_game_over()\n        assert board.winner() is None\n        ```\n    \"\"\"\n    return self.has_win() or self.is_full()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.is_legal_move","title":"is_legal_move","text":"<pre><code>is_legal_move(move: int) -&gt; bool\n</code></pre> <p>Checks if a move (column) is legal in the current position.</p> <p>A move is considered legal if:</p> <ul> <li>The column index is within the valid range (0-6), and</li> <li>The column is not full (i.e. it still has at least one empty cell).</li> </ul> <p>This method does not check for tactical consequences such as leaving an immediate win to the opponent, nor does it stop being usable once a player has already won. It purely validates whether a token can be dropped into the given column according to the basic rules of Connect Four. You have to check for wins separately using Board.has_win.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The column index (0-6) to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the move is legal, False otherwise.</p> Example <p>All moves are legal on an empty board: <pre><code>import bitbully as bb\n\nboard = bb.Board()  # Empty 7x6 board\n\n# Every column index from 0 to 6 is a valid move.\nfor col in range(7):\n    assert board.is_legal_move(col)\n\n# Out-of-range indices are always illegal.\nassert not board.is_legal_move(-1)\nassert not board.is_legal_move(7)\n</code></pre></p> Example <p>Detecting an illegal move in a full column: <pre><code>import bitbully as bb\n\n# Fill the center column (index 3) with six tokens.\nboard = bb.Board()\nassert board.play([3, 3, 3, 3, 3, 3])\n\n# The center column is now full, so another move in column 3 is illegal.\nassert not board.is_legal_move(3)\n\n# Other columns are still available (as long as they are not full).\nassert board.is_legal_move(0)\nassert board.is_legal_move(6)\n\nprint(board)\n</code></pre> Expected output: <pre><code>_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n</code></pre></p> Example <p>This function only checks legality, not for situations where a player has won: <pre><code>import bitbully as bb\n\n# Player 1 (yellow, X) wins  the game.\nboard = bb.Board()\nassert board.play(\"1122334\")\n\n# Even though Player 1 has already won, moves in non-full columns are still legal.\nfor col in range(7):\n    assert board.is_legal_move(col)\n\nprint(board)\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  O  O  O  _  _  _\n_  X  X  X  X  _  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def is_legal_move(self, move: int) -&gt; bool:\n    \"\"\"Checks if a move (column) is legal in the current position.\n\n    A move is considered *legal* if:\n\n    - The column index is within the valid range (0-6), **and**\n    - The column is **not full** (i.e. it still has at least one empty cell).\n\n    This method does **not** check for tactical consequences such as\n    leaving an immediate win to the opponent, nor does it stop being\n    usable once a player has already won. It purely validates whether a\n    token can be dropped into the given column according to the basic\n    rules of Connect Four. You have to check for wins separately using\n    [Board.has_win][src.bitbully.board.Board.has_win].\n\n\n    Args:\n        move (int): The column index (0-6) to check.\n\n    Returns:\n        bool: True if the move is legal, False otherwise.\n\n    Example:\n        All moves are legal on an empty board:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()  # Empty 7x6 board\n\n        # Every column index from 0 to 6 is a valid move.\n        for col in range(7):\n            assert board.is_legal_move(col)\n\n        # Out-of-range indices are always illegal.\n        assert not board.is_legal_move(-1)\n        assert not board.is_legal_move(7)\n        ```\n\n    Example:\n        Detecting an illegal move in a full column:\n        ```python\n        import bitbully as bb\n\n        # Fill the center column (index 3) with six tokens.\n        board = bb.Board()\n        assert board.play([3, 3, 3, 3, 3, 3])\n\n        # The center column is now full, so another move in column 3 is illegal.\n        assert not board.is_legal_move(3)\n\n        # Other columns are still available (as long as they are not full).\n        assert board.is_legal_move(0)\n        assert board.is_legal_move(6)\n\n        print(board)\n        ```\n        Expected output:\n        ```text\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        ```\n\n    Example:\n        This function only checks legality, not for situations where a player has won:\n        ```python\n        import bitbully as bb\n\n        # Player 1 (yellow, X) wins  the game.\n        board = bb.Board()\n        assert board.play(\"1122334\")\n\n        # Even though Player 1 has already won, moves in non-full columns are still legal.\n        for col in range(7):\n            assert board.is_legal_move(col)\n\n        print(board)\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  O  O  O  _  _  _\n        _  X  X  X  X  _  _\n        ```\n    \"\"\"\n    return self._board.isLegalMove(move)\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.is_legal_move(move)","title":"<code>move</code>","text":""},{"location":"board/#src.bitbully.board.Board.legal_moves","title":"legal_moves","text":"<pre><code>legal_moves(non_losing: bool = False, order_moves: bool = False) -&gt; list[int]\n</code></pre> <p>Returns a list of all legal moves (non-full columns) for the current board state.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>If <code>True</code>, only returns moves that do not allow the opponent to win immediately on their next turn. The list might be empty If <code>False</code>, all legal moves are returned.</p> <code>False</code> <code>bool</code> <p>If <code>True</code>, the returned list is ordered to prioritize moves (potentially more promising first).</p> <code>False</code> <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: A list of column indices (0-6) where a token can be legally dropped.</p> Example <pre><code>import bitbully as bb\n\nboard = bb.Board()\nlegal_moves = board.legal_moves()\nassert set(legal_moves) == set(range(7))  # All columns are initially legal\nassert set(legal_moves) == set(board.legal_moves(order_moves=True))\nboard.legal_moves(order_moves=True) == [3, 2, 4, 1, 5, 0, 6]  # Center column prioritized\n</code></pre> Example <pre><code>import bitbully as bb\n\nboard = bb.Board()\nboard.play(\"3322314\")\nprint(board)\nassert board.legal_moves() == list(range(7))\nassert board.legal_moves(non_losing=True) == [5]\n</code></pre> <p>Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  O  O  _  _  _\n_  O  X  X  X  _  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def legal_moves(self, non_losing: bool = False, order_moves: bool = False) -&gt; list[int]:\n    \"\"\"Returns a list of all legal moves (non-full columns) for the current board state.\n\n    Args:\n        non_losing (bool):\n            If ``True``, only returns moves that do **not** allow the opponent\n            to win immediately on their next turn. The list might be empty\n            If ``False``, all legal moves are returned.\n        order_moves (bool):\n            If ``True``, the returned list is ordered to prioritize moves (potentially more promising first).\n\n    Returns:\n        list[int]: A list of column indices (0-6) where a token can be legally dropped.\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        legal_moves = board.legal_moves()\n        assert set(legal_moves) == set(range(7))  # All columns are initially legal\n        assert set(legal_moves) == set(board.legal_moves(order_moves=True))\n        board.legal_moves(order_moves=True) == [3, 2, 4, 1, 5, 0, 6]  # Center column prioritized\n        ```\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        board.play(\"3322314\")\n        print(board)\n        assert board.legal_moves() == list(range(7))\n        assert board.legal_moves(non_losing=True) == [5]\n        ```\n\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  O  O  _  _  _\n        _  O  X  X  X  _  _\n        ```\n    \"\"\"\n    return self._board.legalMoves(nonLosing=non_losing, orderMoves=order_moves)\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.legal_moves(non_losing)","title":"<code>non_losing</code>","text":""},{"location":"board/#src.bitbully.board.Board.legal_moves(order_moves)","title":"<code>order_moves</code>","text":""},{"location":"board/#src.bitbully.board.Board.mirror","title":"mirror","text":"<pre><code>mirror() -&gt; Board\n</code></pre> <p>Returns a new Board instance that is the mirror image of the current board.</p> <p>This method reflects the board horizontally around its vertical center column: - Column 0 &lt;-&gt; Column 6 - Column 1 &lt;-&gt; Column 5 - Column 2 &lt;-&gt; Column 4 - Column 3 stays in the center</p> <p>The player to move is not changed - only the spatial arrangement of the tokens is mirrored. The original board remains unchanged; <code>mirror()</code> always returns a new <code>Board</code> instance.</p> <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>A new Board instance that is the mirror image of the current one.</p> Example <p>Mirroring a simple asymmetric position: <pre><code>import bitbully as bb\n\n# Play four moves along the bottom row.\nboard = bb.Board()\nassert board.play(\"0123\")  # Columns: 0, 1, 2, 3\n\n# Create a mirrored copy of the board.\nmirrored = board.mirror()\n\nprint(\"Original:\")\nprint(board)\n\nprint(\"Mirrored:\")\nprint(mirrored)\n</code></pre></p> <p>Expected output: <pre><code>Original:\n\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\nX  O  X  O  _  _  _\n\nMirrored:\n\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  O  X  O  X\n</code></pre></p> Example <p>Mirroring a position that is already symmetric: <pre><code>import bitbully as bb\n\n# Central symmetry: one token in each outer column and in the center.\nboard = bb.Board([1, 3, 5])\n\nmirrored = board.mirror()\n\n# The mirrored position is identical to the original.\nassert board == mirrored\nassert hash(board) == hash(mirrored)\n\nprint(board)\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  X  _  O  _  X  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def mirror(self) -&gt; Board:\n    \"\"\"Returns a new Board instance that is the mirror image of the current board.\n\n    This method reflects the board **horizontally** around its vertical center column:\n    - Column 0 &lt;-&gt; Column 6\n    - Column 1 &lt;-&gt; Column 5\n    - Column 2 &lt;-&gt; Column 4\n    - Column 3 stays in the center\n\n    The player to move is not changed - only the spatial\n    arrangement of the tokens is mirrored. The original board remains unchanged;\n    `mirror()` always returns a **new** `Board` instance.\n\n    Returns:\n        Board: A new Board instance that is the mirror image of the current one.\n\n    Example:\n        Mirroring a simple asymmetric position:\n        ```python\n        import bitbully as bb\n\n        # Play four moves along the bottom row.\n        board = bb.Board()\n        assert board.play(\"0123\")  # Columns: 0, 1, 2, 3\n\n        # Create a mirrored copy of the board.\n        mirrored = board.mirror()\n\n        print(\"Original:\")\n        print(board)\n\n        print(\"Mirrored:\")\n        print(mirrored)\n        ```\n\n        Expected output:\n        ```text\n        Original:\n\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        X  O  X  O  _  _  _\n\n        Mirrored:\n\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  O  X  O  X\n        ```\n\n    Example:\n        Mirroring a position that is already symmetric:\n        ```python\n        import bitbully as bb\n\n        # Central symmetry: one token in each outer column and in the center.\n        board = bb.Board([1, 3, 5])\n\n        mirrored = board.mirror()\n\n        # The mirrored position is identical to the original.\n        assert board == mirrored\n        assert hash(board) == hash(mirrored)\n\n        print(board)\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  X  _  O  _  X  _\n        ```\n    \"\"\"\n    new_board = Board()\n    new_board._board = self._board.mirror()\n    return new_board\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.moves_left","title":"moves_left","text":"<pre><code>moves_left() -&gt; int\n</code></pre> <p>Returns the number of moves left until the board is full.</p> <p>This is simply the number of empty cells remaining on the 7x6 grid. On an empty board there are 42 free cells, so:</p> <ul> <li>At the start of the game: <code>moves_left() == 42</code></li> <li>After <code>n</code> valid moves: <code>moves_left() == 42 - n</code></li> <li>On a completely full board: <code>moves_left() == 0</code></li> </ul> <p>This method is equivalent to: <pre><code>42 - board.count_tokens()\n</code></pre> but implemented efficiently in the underlying C++ core.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of moves left (0-42).</p> Example <p>Moves left on an empty board: <pre><code>import bitbully as bb\n\nboard = bb.Board()  # No tokens placed yet.\nassert board.moves_left() == 42\nassert board.count_tokens() == 0\n</code></pre></p> Example <p>Relation to the number of moves played: <pre><code>import bitbully as bb\n\n# Play five moves in various columns.\nmoves = [3, 3, 1, 4, 6]\nboard = bb.Board()\nassert board.play(moves)\n\n# Five tokens have been placed, so 42 - 5 = 37 moves remain.\nassert board.count_tokens() == 5\nassert board.moves_left() == 37\nassert board.moves_left() + board.count_tokens() == 42\n</code></pre></p> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0board <code></code>\u00a0Board <code></code>\u00a0is_full </li> </ul> Source code in <code>src/bitbully/board.py</code> <pre><code>def moves_left(self) -&gt; int:\n    \"\"\"Returns the number of moves left until the board is full.\n\n    This is simply the number of *empty* cells remaining on the 7x6 grid.\n    On an empty board there are 42 free cells, so:\n\n    - At the start of the game: `moves_left() == 42`\n    - After `n` valid moves: `moves_left() == 42 - n`\n    - On a completely full board: `moves_left() == 0`\n\n    This method is equivalent to:\n    ```\n    42 - board.count_tokens()\n    ```\n    but implemented efficiently in the underlying C++ core.\n\n    Returns:\n        int: The number of moves left (0-42).\n\n    Example:\n        Moves left on an empty board:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()  # No tokens placed yet.\n        assert board.moves_left() == 42\n        assert board.count_tokens() == 0\n        ```\n\n    Example:\n        Relation to the number of moves played:\n        ```python\n        import bitbully as bb\n\n        # Play five moves in various columns.\n        moves = [3, 3, 1, 4, 6]\n        board = bb.Board()\n        assert board.play(moves)\n\n        # Five tokens have been placed, so 42 - 5 = 37 moves remain.\n        assert board.count_tokens() == 5\n        assert board.moves_left() == 37\n        assert board.moves_left() + board.count_tokens() == 42\n        ```\n    \"\"\"\n    return self._board.movesLeft()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.play","title":"play","text":"<pre><code>play(move: int | Sequence[int] | str) -&gt; bool\n</code></pre> <p>Plays one or more moves for the current player.</p> <p>The method updates the internal board state by dropping tokens into the specified columns. Input can be: - a single integer (column index 0 to 6), - an iterable sequence of integers (e.g., <code>[3, 1, 3]</code> or <code>range(7)</code>), - or a string of digits (e.g., <code>\"33333111\"</code>) representing the move order.</p> <p>Parameters:</p> Name Type Description Default <code>int | Sequence[int] | str</code> <p>The column index or sequence of column indices where tokens should be placed.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the move was played successfully, False if the move was illegal.</p> Example <p>Play a sequence of moves into the center column (column index 3): <pre><code>import bitbully as bb\n\nboard = bb.Board()\nassert board.play([3, 3, 3])  # returns True on successful move\nboard\n</code></pre></p> <p>Expected output:</p> <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n</code></pre> Example <p>Play a sequence of moves across all columns: <pre><code>import bitbully as bb\n\nboard = bb.Board()\nassert board.play(range(7))  # returns True on successful move\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\nX  O  X  O  X  O  X\n</code></pre></p> Example <p>Play a sequence using a string: <pre><code>import bitbully as bb\n\nboard = bb.Board()\nassert board.play(\"33333111\")  # returns True on successful move\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0board <code></code>\u00a0Board <code></code>\u00a0from_moves </li> </ul> Source code in <code>src/bitbully/board.py</code> <pre><code>def play(self, move: int | Sequence[int] | str) -&gt; bool:\n    \"\"\"Plays one or more moves for the current player.\n\n    The method updates the internal board state by dropping tokens\n    into the specified columns. Input can be:\n    - a single integer (column index 0 to 6),\n    - an iterable sequence of integers (e.g., `[3, 1, 3]` or `range(7)`),\n    - or a string of digits (e.g., `\"33333111\"`) representing the move order.\n\n    Args:\n        move (int | Sequence[int] | str):\n            The column index or sequence of column indices where tokens should be placed.\n\n    Returns:\n        bool: True if the move was played successfully, False if the move was illegal.\n\n\n    Example:\n        Play a sequence of moves into the center column (column index 3):\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        assert board.play([3, 3, 3])  # returns True on successful move\n        board\n        ```\n\n        Expected output:\n\n        ```\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        ```\n\n    Example:\n        Play a sequence of moves across all columns:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        assert board.play(range(7))  # returns True on successful move\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        X  O  X  O  X  O  X\n        ```\n\n    Example:\n        Play a sequence using a string:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        assert board.play(\"33333111\")  # returns True on successful move\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n    \"\"\"\n    # Case 1: string -&gt; pass through directly\n    if isinstance(move, str):\n        return self._board.play(move)\n\n    # Case 2: int -&gt; pass through directly\n    if isinstance(move, int):\n        return self._board.play(move)\n\n    # From here on, move is a Sequence[...] (but not str or int).\n    move_list: list[int] = [int(v) for v in cast(Sequence[Any], move)]\n    return self._board.play(move_list)\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.play(move)","title":"<code>move</code>","text":""},{"location":"board/#src.bitbully.board.Board.play_on_copy","title":"play_on_copy","text":"<pre><code>play_on_copy(move: int) -&gt; Board\n</code></pre> <p>Return a new board with the given move applied, leaving the current board unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The column index (0-6) in which to play the move.</p> required <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>A new Board instance representing the position after the move.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the move is illegal (e.g. column is full or out of range).</p> Example <pre><code>import bitbully as bb\n\nboard = bb.Board(\"333\")  # Some existing position\nnew_board = board.play_on_copy(4)\n\n# The original board is unchanged.\nassert board.count_tokens() == 3\n\n# The returned board includes the new move.\nassert new_board.count_tokens() == 4\nassert new_board != board\n</code></pre> Source code in <code>src/bitbully/board.py</code> <pre><code>def play_on_copy(self, move: int) -&gt; Board:\n    \"\"\"Return a new board with the given move applied, leaving the current board unchanged.\n\n    Args:\n        move (int):\n            The column index (0-6) in which to play the move.\n\n    Returns:\n        Board:\n            A new Board instance representing the position after the move.\n\n    Raises:\n        ValueError: If the move is illegal (e.g. column is full or out of range).\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board(\"333\")  # Some existing position\n        new_board = board.play_on_copy(4)\n\n        # The original board is unchanged.\n        assert board.count_tokens() == 3\n\n        # The returned board includes the new move.\n        assert new_board.count_tokens() == 4\n        assert new_board != board\n        ```\n    \"\"\"\n    # Delegate to C++ (this returns a BoardCore instance)\n    core_new = self._board.playMoveOnCopy(move)\n\n    if core_new is None:\n        # C++ signals illegal move by returning a null board\n        raise ValueError(f\"Illegal move: column {move}\")\n\n    # Wrap in a new high-level Board object\n    new_board = Board()\n    new_board._board = core_new\n    return new_board\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.play_on_copy(move)","title":"<code>move</code>","text":""},{"location":"board/#src.bitbully.board.Board.random_board","title":"random_board  <code>staticmethod</code>","text":"<pre><code>random_board(n_ply: int, forbid_direct_win: bool) -&gt; tuple[Board, list[int]]\n</code></pre> <p>Generates a random board state by playing a specified number of random moves.</p> <p>If <code>forbid_direct_win</code> is <code>True</code>, the generated position is guaranteed not to contain an immediate winning move for the player to move.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>Number of random moves to simulate (0-42).</p> required <code>bool</code> <p>If <code>True</code>, ensures the resulting board has no immediate winning move.</p> required <p>Returns:</p> Type Description <code>tuple[Board, list[int]]</code> <p>tuple[Board, list[int]]: A pair <code>(board, moves)</code> where <code>board</code> is the generated position and <code>moves</code> are the exact random moves performed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>n_ply</code> is outside the valid range [0, 42].</p> Example <p>Basic usage: <pre><code>import bitbully as bb\n\nboard, moves = bb.Board.random_board(10, forbid_direct_win=True)\n\nprint(\"Moves:\", moves)\nprint(\"Board:\")\nprint(board)\n\n# The move list must match the requested ply.\nassert len(moves) == 10\n\n# No immediate winning move when forbid_direct_win=True.\nassert not board.can_win_next()\n</code></pre></p> Example <p>Using random boards in tests or simulations: <pre><code>import bitbully as bb\n\n# Generate 50 random 10-ply positions.\nfor _ in range(50):\n    board, moves = bb.Board.random_board(10, forbid_direct_win=True)\n    assert len(moves) == 10\n    assert not board.has_win()  # Game should not be over\n    assert board.count_tokens() == 10  # All generated boards contain exactly 10 tokens\n    assert not board.can_win_next()  # Since `forbid_direct_win=True`, no immediate threat\n</code></pre></p> Example <p>Reconstructing the board manually from the move list: <pre><code>import bitbully as bb\n\nb1, moves = bb.Board.random_board(8, forbid_direct_win=True)\n\n# Recreate the board using the move sequence:\nb2 = bb.Board(moves)\n\nassert b1 == b2\nassert b1.to_string() == b2.to_string()\nassert b1.uid() == b2.uid()\n</code></pre></p> Example <p>Ensure randomness by generating many distinct sequences: <pre><code>import bitbully as bb\n\nseen = set()\nfor _ in range(20):\n    _, moves = bb.Board.random_board(5, False)\n    seen.add(tuple(moves))\n\n# Very likely to see more than one unique sequence.\nassert len(seen) &gt; 1\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>@staticmethod\ndef random_board(n_ply: int, forbid_direct_win: bool) -&gt; tuple[Board, list[int]]:\n    \"\"\"Generates a random board state by playing a specified number of random moves.\n\n    If ``forbid_direct_win`` is ``True``, the generated position is guaranteed\n    **not** to contain an immediate winning move for the player to move.\n\n    Args:\n        n_ply (int):\n            Number of random moves to simulate (0-42).\n        forbid_direct_win (bool):\n            If ``True``, ensures the resulting board has **no immediate winning move**.\n\n    Returns:\n        tuple[Board, list[int]]:\n            A pair ``(board, moves)`` where ``board`` is the generated position\n            and ``moves`` are the exact random moves performed.\n\n    Raises:\n        ValueError: If `n_ply` is outside the valid range [0, 42].\n\n    Example:\n        Basic usage:\n        ```python\n        import bitbully as bb\n\n        board, moves = bb.Board.random_board(10, forbid_direct_win=True)\n\n        print(\"Moves:\", moves)\n        print(\"Board:\")\n        print(board)\n\n        # The move list must match the requested ply.\n        assert len(moves) == 10\n\n        # No immediate winning move when forbid_direct_win=True.\n        assert not board.can_win_next()\n        ```\n\n    Example:\n        Using random boards in tests or simulations:\n        ```python\n        import bitbully as bb\n\n        # Generate 50 random 10-ply positions.\n        for _ in range(50):\n            board, moves = bb.Board.random_board(10, forbid_direct_win=True)\n            assert len(moves) == 10\n            assert not board.has_win()  # Game should not be over\n            assert board.count_tokens() == 10  # All generated boards contain exactly 10 tokens\n            assert not board.can_win_next()  # Since `forbid_direct_win=True`, no immediate threat\n        ```\n\n    Example:\n        Reconstructing the board manually from the move list:\n        ```python\n        import bitbully as bb\n\n        b1, moves = bb.Board.random_board(8, forbid_direct_win=True)\n\n        # Recreate the board using the move sequence:\n        b2 = bb.Board(moves)\n\n        assert b1 == b2\n        assert b1.to_string() == b2.to_string()\n        assert b1.uid() == b2.uid()\n        ```\n\n    Example:\n        Ensure randomness by generating many distinct sequences:\n        ```python\n        import bitbully as bb\n\n        seen = set()\n        for _ in range(20):\n            _, moves = bb.Board.random_board(5, False)\n            seen.add(tuple(moves))\n\n        # Very likely to see more than one unique sequence.\n        assert len(seen) &gt; 1\n        ```\n    \"\"\"\n    if not 0 &lt;= n_ply &lt;= 42:\n        raise ValueError(f\"n_ply must be between 0 and 42 (inclusive), got {n_ply}.\")\n    board_, moves = BoardCore.randomBoard(n_ply, forbid_direct_win)\n    board = Board()\n    board._board = board_\n\n    return board, moves\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.random_board(n_ply)","title":"<code>n_ply</code>","text":""},{"location":"board/#src.bitbully.board.Board.random_board(forbid_direct_win)","title":"<code>forbid_direct_win</code>","text":""},{"location":"board/#src.bitbully.board.Board.reset_board","title":"reset_board","text":"<pre><code>reset_board(board: Sequence[int] | Sequence[Sequence[int]] | str | None = None) -&gt; bool\n</code></pre> <p>Resets the board or sets (overrides) the board to a specific state.</p> <p>Parameters:</p> Name Type Description Default <code>Sequence[int] | Sequence[Sequence[int]] | str | None</code> <p>The new board state. Accepts: - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7 - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3]) - String: A move sequence of columns as string (e.g., \"002233...\") - None: to reset to an empty board</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the board was set successfully, False otherwise.</p> Example <p>Reset the board to an empty state: <pre><code>import bitbully as bb\n\n# Create a temporary board position from a move string.\n# The string \"0123456\" plays one token in each column (0-6) in sequence.\nboard = bb.Board(\"0123456\")\n\n# Reset the board to an empty state.\n# Calling `reset_board()` clears all tokens and restores the starting position.\n# No moves \u2192 an empty board.\nassert board.reset_board()\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n</code></pre></p> Example <p>(Re-)Set the board using a move sequence string: <pre><code>import bitbully as bb\n\n# This is just a temporary setup; it will be replaced below.\nboard = bb.Board(\"0123456\")\n\n# Set the board state directly from a move sequence.\n# The list [3, 3, 3] represents three consecutive moves in the center column (index 3).\n# Moves alternate automatically between Player 1 (yellow) and Player 2 (red).\n#\n# The `reset_board()` method clears the current position and replays the given moves\n# from an empty board \u2014 effectively overriding any existing board state.\nassert board.reset_board([3, 3, 3])\n\n# Display the updated board to verify the new position.\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n</code></pre></p> Example <p>You can also set the board using other formats, such as a 2D array or a string. See the examples in the Board docstring for details.</p> <pre><code># Briefly demonstrate the different input formats accepted by `reset_board()`.\nimport bitbully as bb\n\n# Create an empty board instance\nboard = bb.Board()\n\n# Variant 1: From a list of moves (integers)\n# Each number represents a column index (0-6); moves alternate between players.\nassert board.reset_board([3, 3, 3])\n\n# Variant 2: From a compact move string\n# Equivalent to the list above \u2014 useful for quick testing or serialization.\nassert board.reset_board(\"33333111\")\n\n# Variant 3: From a 2D list in row-major format (6 x 7)\n# Each inner list represents a row (top to bottom).\n# 0 = empty, 1 = Player 1, 2 = Player 2.\nboard_array = [\n    [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n    [0, 0, 0, 1, 0, 0, 0],  # Row 4\n    [0, 0, 0, 2, 0, 0, 0],  # Row 3\n    [0, 2, 0, 1, 0, 0, 0],  # Row 2\n    [0, 1, 0, 2, 0, 0, 0],  # Row 1\n    [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom)\n]\nassert board.reset_board(board_array)\n\n# Variant 4: From a 2D list in column-major format (7 x 6)\n# Each inner list represents a column (left to right); this matches BitBully's internal layout.\nboard_array = [\n    [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)\n    [2, 1, 2, 1, 0, 0],  # Column 1\n    [0, 0, 0, 0, 0, 0],  # Column 2\n    [1, 2, 1, 2, 1, 0],  # Column 3 (center)\n    [0, 0, 0, 0, 0, 0],  # Column 4\n    [2, 1, 2, 0, 0, 0],  # Column 5\n    [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)\n]\nassert board.reset_board(board_array)\n\n# Display the final board state in text form\nboard\n</code></pre> <p>Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  O  _\n_  X  _  O  _  X  _\n_  O  _  X  _  O  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def reset_board(self, board: Sequence[int] | Sequence[Sequence[int]] | str | None = None) -&gt; bool:\n    \"\"\"Resets the board or sets (overrides) the board to a specific state.\n\n    Args:\n        board (Sequence[int] | Sequence[Sequence[int]] | str | None):\n            The new board state. Accepts:\n            - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7\n            - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3])\n            - String: A move sequence of columns as string (e.g., \"002233...\")\n            - None: to reset to an empty board\n\n    Returns:\n        bool: True if the board was set successfully, False otherwise.\n\n    Example:\n        Reset the board to an empty state:\n        ```python\n        import bitbully as bb\n\n        # Create a temporary board position from a move string.\n        # The string \"0123456\" plays one token in each column (0-6) in sequence.\n        board = bb.Board(\"0123456\")\n\n        # Reset the board to an empty state.\n        # Calling `reset_board()` clears all tokens and restores the starting position.\n        # No moves \u2192 an empty board.\n        assert board.reset_board()\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        ```\n\n    Example:\n        (Re-)Set the board using a move sequence string:\n        ```python\n        import bitbully as bb\n\n        # This is just a temporary setup; it will be replaced below.\n        board = bb.Board(\"0123456\")\n\n        # Set the board state directly from a move sequence.\n        # The list [3, 3, 3] represents three consecutive moves in the center column (index 3).\n        # Moves alternate automatically between Player 1 (yellow) and Player 2 (red).\n        #\n        # The `reset_board()` method clears the current position and replays the given moves\n        # from an empty board \u2014 effectively overriding any existing board state.\n        assert board.reset_board([3, 3, 3])\n\n        # Display the updated board to verify the new position.\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        ```\n\n    Example:\n        You can also set the board using other formats, such as a 2D array or a string.\n        See the examples in the [Board][src.bitbully.board.Board] docstring for details.\n\n        ```python\n        # Briefly demonstrate the different input formats accepted by `reset_board()`.\n        import bitbully as bb\n\n        # Create an empty board instance\n        board = bb.Board()\n\n        # Variant 1: From a list of moves (integers)\n        # Each number represents a column index (0-6); moves alternate between players.\n        assert board.reset_board([3, 3, 3])\n\n        # Variant 2: From a compact move string\n        # Equivalent to the list above \u2014 useful for quick testing or serialization.\n        assert board.reset_board(\"33333111\")\n\n        # Variant 3: From a 2D list in row-major format (6 x 7)\n        # Each inner list represents a row (top to bottom).\n        # 0 = empty, 1 = Player 1, 2 = Player 2.\n        board_array = [\n            [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n            [0, 0, 0, 1, 0, 0, 0],  # Row 4\n            [0, 0, 0, 2, 0, 0, 0],  # Row 3\n            [0, 2, 0, 1, 0, 0, 0],  # Row 2\n            [0, 1, 0, 2, 0, 0, 0],  # Row 1\n            [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom)\n        ]\n        assert board.reset_board(board_array)\n\n        # Variant 4: From a 2D list in column-major format (7 x 6)\n        # Each inner list represents a column (left to right); this matches BitBully's internal layout.\n        board_array = [\n            [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)\n            [2, 1, 2, 1, 0, 0],  # Column 1\n            [0, 0, 0, 0, 0, 0],  # Column 2\n            [1, 2, 1, 2, 1, 0],  # Column 3 (center)\n            [0, 0, 0, 0, 0, 0],  # Column 4\n            [2, 1, 2, 0, 0, 0],  # Column 5\n            [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)\n        ]\n        assert board.reset_board(board_array)\n\n        # Display the final board state in text form\n        board\n        ```\n\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  O  _\n        _  X  _  O  _  X  _\n        _  O  _  X  _  O  _\n        ```\n    \"\"\"\n    if board is None:\n        return self._board.setBoard([])\n    if isinstance(board, str):\n        return self._board.setBoard(board)\n\n    # From here on, board is a Sequence[...] (but not str).\n    # Distinguish 2D vs 1D by inspecting the first element.\n    if len(board) &gt; 0 and isinstance(board[0], Sequence) and not isinstance(board[0], (str, bytes)):\n        # Case 2: 2D -&gt; list[list[int]]\n        # Convert inner sequences to lists of ints\n        grid: list[list[int]] = [[int(v) for v in row] for row in cast(Sequence[Sequence[Any]], board)]\n        return self._board.setBoard(grid)\n\n    # Case 3: 1D -&gt; list[int]\n    moves: list[int] = [int(v) for v in cast(Sequence[Any], board)]\n    return self._board.setBoard(moves)\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.reset_board(board)","title":"<code>board</code>","text":""},{"location":"board/#src.bitbully.board.Board.to_array","title":"to_array","text":"<pre><code>to_array(column_major_layout: bool = True) -&gt; list[list[int]]\n</code></pre> <p>Returns the board state as a 2D array (list of lists).</p> <p>This layout is convenient for printing, serialization, or converting to a NumPy array for further analysis.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Use column-major format if set to <code>True</code>, otherwise the row-major-layout is used.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[list[int]]</code> <p>list[list[int]]: A 7x6 2D list representing the board state.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If <code>column_major_layout</code> is set to <code>False</code>.</p> Example Column-major Format:Row-major Format: <p>The returned array is in column-major format with shape <code>7 x 6</code> (<code>[column][row]</code>):</p> <ul> <li>There are 7 inner lists, one for each column of the board.</li> <li>Each inner list has 6 integers, one for each row.</li> <li>Row index <code>0</code> corresponds to the bottom row, row index <code>5</code> to the top row.</li> <li>Convention:</li> <li><code>0</code> -&gt; empty cell</li> <li><code>1</code> -&gt; Player 1 token (yellow, X)</li> <li><code>2</code> -&gt; Player 2 token (red, O)</li> </ul> <p><pre><code>import bitbully as bb\nfrom pprint import pprint\n\n# Create a position from a move sequence.\nboard = bb.Board(\"33333111\")\n\n# Extract the board as a 2D list (rows x columns).\narr = board.to_array()\n\n# Reconstruct the same position from the 2D array.\nboard2 = bb.Board(arr)\n\n# Both boards represent the same position.\nassert board == board2\nassert board.to_array() == board2.to_array()\n\n# print ther result of `board.to_array()`:\npprint(board.to_array())\n</code></pre> Expected output: <pre><code>[[0, 0, 0, 0, 0, 0],\n[2, 1, 2, 0, 0, 0],\n[0, 0, 0, 0, 0, 0],\n[1, 2, 1, 2, 1, 0],\n[0, 0, 0, 0, 0, 0],\n[0, 0, 0, 0, 0, 0],\n[0, 0, 0, 0, 0, 0]]\n</code></pre></p> <pre><code>TODO: This is not supported yet\n</code></pre> Source code in <code>src/bitbully/board.py</code> <pre><code>def to_array(self, column_major_layout: bool = True) -&gt; list[list[int]]:\n    \"\"\"Returns the board state as a 2D array (list of lists).\n\n    This layout is convenient for printing, serialization, or converting\n    to a NumPy array for further analysis.\n\n    Args:\n        column_major_layout (bool): Use column-major format if set to `True`,\n            otherwise the row-major-layout is used.\n\n    Returns:\n        list[list[int]]: A 7x6 2D list representing the board state.\n\n    Raises:\n        NotImplementedError: If `column_major_layout` is set to `False`.\n\n    Example:\n        === \"Column-major Format:\"\n\n            The returned array is in **column-major** format with shape `7 x 6`\n            (`[column][row]`):\n\n            - There are 7 inner lists, one for each column of the board.\n            - Each inner list has 6 integers, one for each row.\n            - Row index `0` corresponds to the **bottom row**,\n            row index `5` to the **top row**.\n            - Convention:\n            - `0` -&gt; empty cell\n            - `1` -&gt; Player 1 token (yellow, X)\n            - `2` -&gt; Player 2 token (red, O)\n\n            ```python\n            import bitbully as bb\n            from pprint import pprint\n\n            # Create a position from a move sequence.\n            board = bb.Board(\"33333111\")\n\n            # Extract the board as a 2D list (rows x columns).\n            arr = board.to_array()\n\n            # Reconstruct the same position from the 2D array.\n            board2 = bb.Board(arr)\n\n            # Both boards represent the same position.\n            assert board == board2\n            assert board.to_array() == board2.to_array()\n\n            # print ther result of `board.to_array()`:\n            pprint(board.to_array())\n            ```\n            Expected output:\n            ```text\n            [[0, 0, 0, 0, 0, 0],\n            [2, 1, 2, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [1, 2, 1, 2, 1, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0]]\n            ```\n\n        === \"Row-major Format:\"\n\n            ``` markdown\n            TODO: This is not supported yet\n            ```\n    \"\"\"\n    if not column_major_layout:\n        # TODO: Implement in C++\n        raise NotImplementedError(\"Row-major Layout is yet to be implemented\")\n\n    return self._board.toArray()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.to_array(column_major_layout)","title":"<code>column_major_layout</code>","text":""},{"location":"board/#src.bitbully.board.Board.to_huffman","title":"to_huffman","text":"<pre><code>to_huffman() -&gt; int\n</code></pre> <p>Encode the current board position into a Huffman-compressed byte sequence.</p> <p>This is a high-level wrapper around <code>bitbully_core.BoardCore.toHuffman</code>. The returned int encodes the exact token layout and the side to move using the same format as the BitBully opening databases.</p> <p>The encoding is:</p> <ul> <li>Deterministic: the same position always yields the same byte sequence.</li> <li>Compact: suitable for storage (of positions with little number of tokens),   or lookups in the BitBully database format.</li> </ul> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>A Huffman-compressed representation of the current board</p> <code>int</code> <p>state.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the position does not contain exactly 8 or 12 tokens, as the   Huffman encoding is only defined for these cases.</p> Example <p>Encode a position and verify that equivalent positions have the same Huffman code:</p> <p><pre><code>import bitbully as bb\n\n# Two different move sequences leading to the same final position.\nb1 = bb.Board(\"01234444\")\nb2 = bb.Board(\"44440123\")\n\nh1 = b1.to_huffman()\nh2 = b2.to_huffman()\n\n# Huffman encoding is purely position-based.\nassert h1 == h2\n\nprint(f\"Huffman code: {h1}\")\n</code></pre> Expected output: <pre><code>Huffman code: 10120112\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def to_huffman(self) -&gt; int:\n    \"\"\"Encode the current board position into a Huffman-compressed byte sequence.\n\n    This is a high-level wrapper around\n    `bitbully_core.BoardCore.toHuffman`. The returned int encodes the\n    exact token layout **and** the side to move using the same format as\n    the BitBully opening databases.\n\n    The encoding is:\n\n    - Deterministic: the same position always yields the same byte sequence.\n    - Compact: suitable for storage (of positions with little number of tokens),\n      or lookups in the BitBully database format.\n\n    Returns:\n        int: A Huffman-compressed representation of the current board\n        state.\n\n    Raises:\n        NotImplementedError:\n            If the position does not contain exactly 8 or 12 tokens, as the\n              Huffman encoding is only defined for these cases.\n\n    Example:\n        Encode a position and verify that equivalent positions have the\n        same Huffman code:\n\n        ```python\n        import bitbully as bb\n\n        # Two different move sequences leading to the same final position.\n        b1 = bb.Board(\"01234444\")\n        b2 = bb.Board(\"44440123\")\n\n        h1 = b1.to_huffman()\n        h2 = b2.to_huffman()\n\n        # Huffman encoding is purely position-based.\n        assert h1 == h2\n\n        print(f\"Huffman code: {h1}\")\n        ```\n        Expected output:\n        ```text\n        Huffman code: 10120112\n        ```\n    \"\"\"\n    token_count = self.count_tokens()\n    if token_count != 8 and token_count != 12:\n        raise NotImplementedError(\"to_huffman() is only implemented for positions with 8 or 12 tokens.\")\n    return self._board.toHuffman()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.to_string","title":"to_string","text":"<pre><code>to_string() -&gt; str\n</code></pre> <p>Returns a human-readable ASCII representation of the board.</p> <p>The returned string shows the current board position as a 6x7 grid, laid out exactly as it would appear when you print a <code>Board</code> instance:</p> <ul> <li>6 lines of text, one per row (top row first, bottom row last)</li> <li>7 entries per row, separated by two spaces</li> <li><code>_</code> represents an empty cell</li> <li><code>X</code> represents a token from Player 1 (yellow)</li> <li><code>O</code> represents a token from Player 2 (red)</li> </ul> <p>This is useful when you want to explicitly capture the board as a string (e.g., for logging, debugging, or embedding into error messages) instead of relying on <code>print(board)</code> or <code>repr(board)</code>.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A multi-line ASCII string representing the board state.</p> Example <p>Using <code>to_string()</code> on an empty board: <pre><code>import bitbully as bb\n\nboard = bb.Board(\"33333111\")\n\ns = board.to_string()\nprint(s)\n</code></pre></p> <p>Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0board <code></code>\u00a0Board <code></code>\u00a0__str__ </li> </ul> Source code in <code>src/bitbully/board.py</code> <pre><code>def to_string(self) -&gt; str:\n    \"\"\"Returns a human-readable ASCII representation of the board.\n\n    The returned string shows the **current board position** as a 6x7 grid,\n    laid out exactly as it would appear when you print a `Board` instance:\n\n    - 6 lines of text, one per row (top row first, bottom row last)\n    - 7 entries per row, separated by two spaces\n    - `_` represents an empty cell\n    - `X` represents a token from Player 1 (yellow)\n    - `O` represents a token from Player 2 (red)\n\n    This is useful when you want to explicitly capture the board as a string\n    (e.g., for logging, debugging, or embedding into error messages) instead\n    of relying on `print(board)` or `repr(board)`.\n\n    Returns:\n        str: A multi-line ASCII string representing the board state.\n\n    Example:\n        Using `to_string()` on an empty board:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board(\"33333111\")\n\n        s = board.to_string()\n        print(s)\n        ```\n\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n    \"\"\"\n    return self._board.toString()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.uid","title":"uid","text":"<pre><code>uid() -&gt; int\n</code></pre> <p>Returns a unique identifier for the current board state.</p> <p>The UID is a deterministic integer computed from the internal bitboard representation of the position. It is stable, position-based, and uniquely tied to the exact token layout and the side to move.</p> <p>Key properties:</p> <ul> <li>Boards with the same configuration (tokens + player to move) always   produce the same UID.</li> <li>Any change to the board (e.g., after a legal move) will almost always   result in a different UID.</li> <li>Copies of a board created via the copy constructor or <code>Board.copy()</code>   naturally share the same UID as long as their states remain identical.</li> </ul> <p>Unlike <code>__hash__()</code>, the UID is not optimized for hash-table dispersion. For use in transposition tables, caching, or dictionary/set keys, prefer <code>__hash__()</code> since it provides a higher-quality hash distribution.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>A unique integer identifier for the board state.</p> Example <p>UID is an integer and not None: <pre><code>import bitbully as bb\n\nboard = bb.Board()\nu = board.uid()\n\nassert isinstance(u, int)\n# Empty board has a well-defined, stable UID.\nassert board.uid() == u\n</code></pre></p> Example <p>UID changes when the position changes: <pre><code>import bitbully as bb\n\nboard = bb.Board()\nuid_before = board.uid()\n\nassert board.play(1)  # Make a move in column 1.\n\nuid_after = board.uid()\nassert uid_after != uid_before\n</code></pre></p> Example <p>Copies share the same UID while they are identical: <pre><code>import bitbully as bb\n\nboard = bb.Board(\"0123\")\n\n# Create an independent copy of the same position.\nboard_copy = board.copy()\n\nassert board is not board_copy  # Different objects\nassert board == board_copy  # Same position\nassert board.uid() == board_copy.uid()  # Same UID\n\n# After modifying the copy, they diverge.\nassert board_copy.play(4)\nassert board != board_copy\nassert board.uid() != board_copy.uid()\n</code></pre></p> Example <p>Different move sequences leading to the same position share the same UID: <pre><code>import bitbully as bb\n\nboard_1 = bb.Board(\"01234444\")\nboard_2 = bb.Board(\"44440123\")\n\nassert board_1 is not board_2  # Different objects\nassert board_1 == board_2  # Same position\nassert board_1.uid() == board_2.uid()  # Same UID\n\n# After modifying the copy, they diverge.\nassert board_1.play(4)\nassert board_1 != board_2\nassert board_1.uid() != board_2.uid()\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def uid(self) -&gt; int:\n    \"\"\"Returns a unique identifier for the current board state.\n\n    The UID is a deterministic integer computed from the internal bitboard\n    representation of the position. It is **stable**, **position-based**, and\n    uniquely tied to the exact token layout **and** the side to move.\n\n    Key properties:\n\n    - Boards with the **same** configuration (tokens + player to move) always\n      produce the **same** UID.\n    - Any change to the board (e.g., after a legal move) will almost always\n      result in a **different** UID.\n    - Copies of a board created via the copy constructor or `Board.copy()`\n      naturally share the same UID as long as their states remain identical.\n\n    Unlike `__hash__()`, the UID is not optimized for hash-table dispersion.\n    For use in transposition tables, caching, or dictionary/set keys,\n    prefer `__hash__()` since it provides a higher-quality hash distribution.\n\n    Returns:\n        int: A unique integer identifier for the board state.\n\n    Example:\n        UID is an integer and not None:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        u = board.uid()\n\n        assert isinstance(u, int)\n        # Empty board has a well-defined, stable UID.\n        assert board.uid() == u\n        ```\n\n    Example:\n        UID changes when the position changes:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        uid_before = board.uid()\n\n        assert board.play(1)  # Make a move in column 1.\n\n        uid_after = board.uid()\n        assert uid_after != uid_before\n        ```\n\n    Example:\n        Copies share the same UID while they are identical:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board(\"0123\")\n\n        # Create an independent copy of the same position.\n        board_copy = board.copy()\n\n        assert board is not board_copy  # Different objects\n        assert board == board_copy  # Same position\n        assert board.uid() == board_copy.uid()  # Same UID\n\n        # After modifying the copy, they diverge.\n        assert board_copy.play(4)\n        assert board != board_copy\n        assert board.uid() != board_copy.uid()\n        ```\n\n    Example:\n        Different move sequences leading to the same position share the same UID:\n        ```python\n        import bitbully as bb\n\n        board_1 = bb.Board(\"01234444\")\n        board_2 = bb.Board(\"44440123\")\n\n        assert board_1 is not board_2  # Different objects\n        assert board_1 == board_2  # Same position\n        assert board_1.uid() == board_2.uid()  # Same UID\n\n        # After modifying the copy, they diverge.\n        assert board_1.play(4)\n        assert board_1 != board_2\n        assert board_1.uid() != board_2.uid()\n        ```\n    \"\"\"\n    return self._board.uid()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.winner","title":"winner","text":"<pre><code>winner() -&gt; int | None\n</code></pre> <p>Returns the winning player, if the game has been won.</p> <p>This helper interprets the current board under the assumption that Board.has_win indicates the last move created a winning configuration. In that case, the winner is the previous player:</p> <ul> <li>If it is currently Player 1's turn, then Player 2 must have just won.</li> <li>If it is currently Player 2's turn, then Player 1 must have just won.</li> </ul> <p>If there is no winner (i.e. Board.has_win is <code>False</code>), this method returns <code>None</code>.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>int | None: The winning player, or <code>None</code> if there is no winner.</p> <ul> <li><code>1</code> \u2192 Player 1 (yellow, <code>X</code>)</li> <li><code>2</code> \u2192 Player 2 (red, <code>O</code>)</li> <li><code>None</code> \u2192 No winner (game still ongoing or draw)</li> </ul> Example <p>Detecting a winner: <pre><code>import bitbully as bb\n\n# Player 1 wins with a horizontal line at the bottom.\nboard = bb.Board()\nassert board.play(\"1122334\")\n\nassert board.has_win()\nassert board.is_game_over()\n\n# It is now Player 2's turn to move next...\nassert board.current_player() == 2\n\n# ...which implies Player 1 must be the winner.\nassert board.winner() == 1\n</code></pre></p> Example <p>No winner yet: <pre><code>import bitbully as bb\n\nboard = bb.Board()\nassert board.play(\"112233\")  # no connect-four yet\n\nassert not board.has_win()\nassert not board.is_game_over()\nassert board.winner() is None\n</code></pre></p> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0board <code></code>\u00a0Board <code></code>\u00a0is_game_over </li> </ul> Source code in <code>src/bitbully/board.py</code> <pre><code>def winner(self) -&gt; int | None:\n    \"\"\"Returns the winning player, if the game has been won.\n\n    This helper interprets the current board under the assumption that\n    [Board.has_win][src.bitbully.board.Board.has_win] indicates **the last move** created a\n    winning configuration. In that case, the winner is the *previous* player:\n\n    - If it is currently Player 1's turn, then Player 2 must have just won.\n    - If it is currently Player 2's turn, then Player 1 must have just won.\n\n    If there is no winner (i.e. [Board.has_win][src.bitbully.board.Board.has_win] is ``False``),\n    this method returns ``None``.\n\n    Returns:\n        int | None:\n            The winning player, or ``None`` if there is no winner.\n\n            - ``1`` \u2192 Player 1 (yellow, ``X``)\n            - ``2`` \u2192 Player 2 (red, ``O``)\n            - ``None`` \u2192 No winner (game still ongoing or draw)\n\n    Example:\n        Detecting a winner:\n        ```python\n        import bitbully as bb\n\n        # Player 1 wins with a horizontal line at the bottom.\n        board = bb.Board()\n        assert board.play(\"1122334\")\n\n        assert board.has_win()\n        assert board.is_game_over()\n\n        # It is now Player 2's turn to move next...\n        assert board.current_player() == 2\n\n        # ...which implies Player 1 must be the winner.\n        assert board.winner() == 1\n        ```\n\n    Example:\n        No winner yet:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        assert board.play(\"112233\")  # no connect-four yet\n\n        assert not board.has_win()\n        assert not board.is_game_over()\n        assert board.winner() is None\n        ```\n    \"\"\"\n    if not self.has_win():\n        return None\n    # Previous player = opposite of current_player\n    return 2 if self.current_player() == 1 else 1\n</code></pre>"},{"location":"develop/","title":"Development (Basic)","text":""},{"location":"develop/#1-clone-the-repository","title":"1. Clone the repository","text":"<pre><code>git clone https://github.com/MarkusThill/BitBully.git\ncd BitBully\ngit submodule update --init --recursive   # Initialize and update submodules\n</code></pre> <p>BitBully uses submodules, so make sure to always clone with them initialized. If you already cloned earlier without them, run:</p> <pre><code>git submodule update --remote --merge\n</code></pre>"},{"location":"develop/#2-create-and-activate-a-virtual-environment-recommended","title":"2. Create and activate a virtual environment (recommended)","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate      # Linux/Mac\n# or\n.\\.venv\\Scripts\\activate       # Windows\n</code></pre>"},{"location":"develop/#3-install-development-dependencies","title":"3. Install development dependencies","text":"<pre><code>pip install -e .[dev]\n</code></pre> <p>This installs BitBully in editable mode plus all development tooling (ruff, mypy, pytest, coverage, commitizen, pre-commit, etc.).</p>"},{"location":"develop/#4-install-git-hooks-pre-commit","title":"4. Install Git hooks (pre-commit)","text":"<pre><code>pre-commit install --hook-type pre-commit --hook-type commit-msg --hook-type pre-push\n</code></pre> <p>This activates:</p> <ul> <li>pre-commit: formatting, linting, static checks before each commit</li> <li>commit-msg: Commitizen / conventional commit message validation</li> <li>pre-push: optional checks before pushing (e.g., running tests)</li> </ul> <p>To run all hooks manually:</p> <pre><code>pre-commit run --all-files\n</code></pre>"},{"location":"develop/#5-running-tests","title":"5. Running tests","text":"<pre><code>pytest tests/ -vv\n</code></pre>"},{"location":"develop/#6-building-wheels-locally-optional","title":"6. Building wheels locally (optional)","text":"<pre><code>python -m build\n</code></pre>"},{"location":"develop/#testing-and-ci","title":"Testing and CI","text":""},{"location":"develop/#running-tests","title":"Running Tests","text":"<p>Run unit tests using <code>pytest</code>:</p> <pre><code>pytest tests/\n</code></pre> <p>For more detailed output:</p> <pre><code>pytest tests/ -v          # verbose: show each test\npytest tests/ -vv         # very verbose: show full node IDs\n</code></pre> <p>Run only tests matching a pattern:</p> <pre><code># A boolean expression that selects tests:\n#   - containing the substring board\n#   - but not containing the substring slow\npytest tests/ -k \"board and not slow\"\n</code></pre> <pre><code>pytest tests/test_opening_book_core.py\n</code></pre> <p>Run a specific test case:</p> <pre><code>pytest tests/test_board_core_basic.py::test_can_win_1\n</code></pre> <p>Stop after the first failure:</p> <pre><code>pytest tests/ -x\n</code></pre> <p>Run with coverage (requires <code>pytest-cov</code>):</p> <pre><code>pytest tests/ --cov=bitbully --cov-report=term-missing\n</code></pre>"},{"location":"develop/#github-actions","title":"GitHub Actions","text":"<p>This project uses GitHub Actions to build and test the library. The CI workflow includes:</p> <ul> <li>Building wheels for Linux and Windows using <code>cibuildwheel</code>.</li> <li>Building source distributions (<code>sdist</code>).</li> <li>Optionally uploading artifacts to PyPI.</li> </ul> <p>The workflows are found under <code>.github/workflows/</code>.</p>"},{"location":"develop/#contributing","title":"Contributing","text":"<p>Contributions are welcome! Follow these steps:</p> <ol> <li>Fork the repository.</li> <li>Create a new branch for your changes:    <pre><code>git checkout -b feature-name\n</code></pre></li> <li>Install <code>dev</code> dependencies:    <pre><code>pip install -e .[dev]\n</code></pre></li> <li>Install pre-commit hooks:    <pre><code>pre-commit install --hook-type pre-commit --hook-type commit-msg --hook-type pre-push\n</code></pre></li> <li>Commit your changes:    <pre><code>git commit -m \"feat: Add feature or fix description\"\n</code></pre></li> <li>Push to your branch:    <pre><code>git push origin feature-name\n</code></pre></li> <li>Open a pull request.</li> </ol>"},{"location":"develop/#development","title":"Development","text":""},{"location":"develop/#usual-push-procedure","title":"Usual Push Procedure","text":"<p>If possible, also try the build on a windows-native machine since there are some subtle differences in the build process:</p> <pre><code>pytest tests/ # ensure that tests run through\nmv dist/ dist.old # if applicable\npython -m build # local build should pass\ncibuildwheel --output-dir dist # now build for the other specified platforms\ntwine check dist/* # Check package metadata in dist folder\ntwine check dist/* --strict # Check package metadata in dist folder (strict)\ngit add -u # or add whatever you want to commit\npre-commit run # make sure that this passes\ngit commit -m \"fix|feat|docs|...: message\" # commit using semantic versioning\ncz bump --dry-run\ncz bump\ngit push --atomic origin master vx.x.x # make sure that you set the correct version\n# build will now be performed on GitHub Runners\n</code></pre> <p>In case you run into an error during <code>cibuildwheel</code>, like</p> <pre><code>CMake Error: The current CMakeCache.txt directory /project/build/temp.linux-x86_64-cpython-312/CMakeCache.txt is different than the directory /workspaces/BitBully/build/temp.linux-x86_64-cpython-312 where CMakeCache.txt was created. This may result in binaries being created in the wrong place. If you are not sure, reedit the CMakeCache.txt\nCMake Error: The source \"/project/CMakeLists.txt\" does not match the source \"/workspaces/BitBully/CMakeLists.txt\" used to generate cache.  Re-run cmake with a different source directory.\n</code></pre> <p>it might help to clean up old builds:</p> <pre><code>rm -rf build/ dist/ src/bitbully/*.so src/bitbully/assets/*.so\n</code></pre> <p>You can also build pre-release versions like this.</p> <pre><code>cz bump --prerelease alpha   # Creates 1.2.3a0 if current is 1.2.3\ncz bump --prerelease beta\ncz bump --prerelease rc\ncz bump --prerelease rc --increment minor # To bump the minor version and start a pre-release\n</code></pre> <p>In this case, after pushing to the repository, only a small build for Python3.11 is performed and the results wheels are pushed to Test-PyPI instead of the real PyPi.</p>"},{"location":"develop/#generating-python-type-stubs-for-pybind11-modules","title":"Generating Python Type Stubs for Pybind11 Modules","text":"<p>To enable type checking with tools like <code>mypy</code> for Pybind11 compiled modules, you can generate a <code>.pyi</code> stub file using <code>pybind11-stubgen</code>. For example:</p> <pre><code>pip install pybind11-stubgen\npybind11-stubgen bitbully.bitbully_core -o src/\n</code></pre> <p>Notes</p> <p>The generated .pyi file contains function and class signatures with type hints, which helps <code>mypy</code> and other type checkers.</p>"},{"location":"develop/#compiler","title":"Compiler","text":"<p>The code was compiled with: gcc 13.1.0</p>"},{"location":"develop/#configure-gov-13-to-match-g-13gcc-13","title":"Configure gov-13 to match g++-13/gcc-13","text":"<p>The version of gcov has to match our compiler version, in order to be able to produce coverage reports:</p> <pre><code>sudo update-alternatives --install /usr/bin/gcov gcov /usr/bin/gcov-11 50 # for compiler version 11\nsudo update-alternatives --install /usr/bin/gcov gcov /usr/bin/gcov-13 100 # for compiler version 13 (as we have here)\nsudo update-alternatives --config gcov\n</code></pre>"},{"location":"develop/#development-debian-based-systems","title":"Development (Debian-based Systems)","text":""},{"location":"develop/#install-python-3","title":"Install Python 3","text":"<pre><code>sudo apt install python3.11\nsudo apt install python3.11-venv\n</code></pre> <p>Configure alternatives, if you have other versions of python installed:</p> <pre><code>sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.10 1\nsudo update-alternatives --install /usr/bin/python python /usr/bin/python3.11 2\nsudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.10 1\nsudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.11 2\n\nsudo update-alternatives --config python\n\nsudo update-alternatives --config python3\n</code></pre>"},{"location":"develop/#install-activate-virtualenv","title":"Install &amp; Activate virtualenv","text":"<pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre>"},{"location":"develop/#install-dependencies","title":"Install Dependencies","text":"<pre><code>pip install -e .[dev,ci]\n</code></pre> <pre><code>pre-commit install\npre-commit install --hook-type commit-msg --hook-type pre-push\n</code></pre> <p>You can run pre-commit before a commit with:</p> <pre><code>pre-commit run\n</code></pre>"},{"location":"develop/#commitizen","title":"Commitizen","text":""},{"location":"develop/#bump-version","title":"Bump Version","text":"<pre><code>cz bump --dry-run # first perform a dry run\ncz bump\ngit push origin tag x.x.x\n</code></pre>"},{"location":"develop/#push-commit-and-tag-atomically","title":"Push commit and tag atomically","text":"<pre><code>git push --atomic origin master v0.0.14\n</code></pre>"},{"location":"develop/#commit-types","title":"Commit types","text":"Commit Type Title Description Emoji <code>feat</code> Features A new feature \u2728 <code>fix</code> Bug Fixes A bug Fix \ud83d\udc1b <code>docs</code> Documentation Documentation only changes \ud83d\udcda <code>style</code> Styles Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) \ud83d\udc8e <code>refactor</code> Code Refactoring A code change that neither fixes a bug nor adds a feature \ud83d\udce6 <code>perf</code> Performance Improvements A code change that improves performance \ud83d\ude80 <code>test</code> Tests Adding missing tests or correcting existing tests \ud83d\udea8 <code>build</code> Builds Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm) \ud83d\udee0 <code>ci</code> Continuous Integrations Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs) \u2699\ufe0f <code>chore</code> Chores Other changes that don't modify src or test files \u267b\ufe0f <code>revert</code> Reverts Reverts a previous commit \ud83d\uddd1"},{"location":"develop/#publish-to-pypi","title":"Publish to PyPI","text":"<ol> <li> <p>Create a PyPi Test Account</p> </li> <li> <p>Log in to Test PyPI or create a new account.</p> </li> <li>Navigate to \"Account Settings\" \u2192 \"API Tokens\".</li> <li> <p>Generate a new API token if needed.</p> </li> <li> <p>Create a PyPI Account:</p> </li> <li> <p>Sign up on PyPI.</p> </li> <li>Set up 2FA (Two-Factor Authentication) for enhanced security.</li> <li>Install Required Tools: Ensure you have build and twine installed for building and publishing:</li> </ol> <pre><code>pip install build twine\n</code></pre> <ol> <li>Update your <code>~/.pypirc File</code>:</li> </ol> <pre><code>[ distutils ]\n  index-servers =\n  pypi\n  testpypi\n\n  [ testpypi ]\n  repository = https://test.pypi.org/legacy/\n  username = __token__\n  password = &lt;your_api_token&gt;\n\n  [ pypi ]\n  repository = https://upload.pypi.org/legacy/\n  username = __token__\n  password = &lt;your_api_token&gt;\n</code></pre>"},{"location":"develop/#build-the-package","title":"Build the Package","text":""},{"location":"develop/#check-the-readme","title":"Check the Readme","text":"<pre><code>pip install readme_renderer[md]\npython -m readme_renderer README.md\npython -m build\n</code></pre>"},{"location":"develop/#build","title":"Build","text":"<pre><code>cd /path/to/project\npython -m build\n</code></pre>"},{"location":"develop/#upload-to-test-pypi","title":"Upload to Test PyPI","text":"<p>Upload to Test pypi first:</p> <pre><code>twine upload --repository testpypi dist/*\n</code></pre> <p>Test installation:</p> <pre><code>pip install --index-url https://test.pypi.org/simple/ bitbully\n</code></pre>"},{"location":"develop/#publish-to-pypi_1","title":"Publish to PyPI","text":"<pre><code>twine upload dist/*\n</code></pre> <p>Test installation from PyPI:</p> <pre><code>pip install bitbully\n</code></pre>"},{"location":"develop/#compile-libs-using-cmake","title":"Compile Libs using CMake","text":""},{"location":"develop/#compile-and-run-google-tests","title":"Compile and run Google Tests","text":"<pre><code>cmake -B build -S . -DCMAKE_BUILD_TYPE=Release # run in project root\ncmake --build build --target gtest_run --config Release\ncd build # navigate into build directory\n./gtests/gtest_run # run tests\n</code></pre>"},{"location":"develop/#updates","title":"Updates","text":""},{"location":"develop/#update-pybind11-submodule","title":"Update pybind11 Submodule","text":"<pre><code>git -C thirdParty/pybind11 rev-parse --abbrev-ref HEAD &amp;&amp; git -C thirdParty/pybind11 describe --tags --always &amp;&amp; git -C thirdParty/pybind11 remote -v\ngit -C thirdParty/pybind11 fetch --tags origin &amp;&amp; git -C thirdParty/pybind11 tag --list \"v3.*\" | tail -n 200 # adapt to v4.* etc., depending on your needs\ngit -C thirdParty/pybind11 status --porcelain\ngit -C thirdParty/pybind11 fetch --tags origin\ngit -C thirdParty/pybind11 tag --list\ngit -C thirdParty/pybind11 checkout v3.0.1 # adapt to the version that you wish to checkout\ngit add thirdParty/pybind11\ngit commit -m \"fix: update pybind11 submodule to vx.x.x\" # adapt the version in the message\n</code></pre>"},{"location":"develop/#update-googletests-submodule","title":"Update GoogleTests Submodule","text":"<pre><code>git -C thirdParty/googletest rev-parse --abbrev-ref HEAD &amp;&amp; git -C thirdParty/googletest describe --tags --always &amp;&amp; git -C thirdParty/googletest remote -v\ngit -C thirdParty/googletest fetch --tags origin &amp;&amp; git -C thirdParty/googletest tag --list | sort -V | tail -n 20\ngit -C thirdParty/googletest status --porcelain # check status\ngit -C thirdParty/googletest fetch --tags origin # fetch remote tags (if not done already)\ngit -C thirdParty/googletest checkout vx.x.x # select a tag you want to check out\ngit add thirdParty/googletest\ngit commit -m \"fix: update googletest submodule to vx.x.x\" # adapt the tag here\n</code></pre>"},{"location":"develop/#update-doxygen-awesome-css-submodule","title":"Update doxygen-awesome-css Submodule","text":"<pre><code>git -C thirdParty/doxygen-awesome-css rev-parse --abbrev-ref HEAD &amp;&amp; git -C thirdParty/doxygen-awesome-css describe --tags --always &amp;&amp; git -C thirdParty/doxygen-awesome-css remote -v\ngit -C thirdParty/doxygen-awesome-css fetch --tags origin &amp;&amp; git -C thirdParty/doxygen-awesome-css tag --list | sort -V | tail -n 20\n\n\ngit -C thirdParty/doxygen-awesome-css status --porcelain # 1. Check status\ngit -C thirdParty/doxygen-awesome-css fetch --tags origin # 2. Fetch remote tags (if not already done)\ngit -C thirdParty/doxygen-awesome-css checkout vx.x.x # 3. Checkout a tag (e.g., v2.4.1 for the latest)\ngit add thirdParty/doxygen-awesome-css # 4. Update superproject reference\ngit commit -m \"fix: update doxygen-awesome-css submodule to vx.x.x\"\ngit push origin HEAD # 5. Push\n</code></pre>"},{"location":"develop/#cheatsheet-most-useful-commands","title":"Cheatsheet: Most Useful Commands","text":""},{"location":"develop/#version-control-git","title":"Version Control (Git)","text":"<ol> <li><code>git status</code> \u2013 Check repository status.</li> <li><code>git add -u</code> \u2013 Stage all changes.</li> <li><code>git add &lt;files&gt;</code> \u2013 Stage specific files.</li> <li><code>git commit -m \"&lt;message&gt;\"</code> \u2013 Commit changes with a message.</li> <li><code>git commit --amend</code> \u2013 Modify the last commit.</li> <li><code>git push --atomic origin master v&lt;version&gt;</code> \u2013 Atomically pushes master branch and tags</li> <li><code>git push</code> \u2013 Push changes to the remote repository.</li> <li><code>git tag -l</code>, <code>git tag --list</code> \u2013 List tags.</li> <li><code>git tag -d &lt;tag&gt;</code> \u2013 Delete a local tag.</li> <li><code>git push origin --delete &lt;tag&gt;</code> \u2013 Delete a remote tag.</li> <li><code>git diff</code> \u2013 Show differences between changes.</li> <li><code>git fetch</code> \u2013 Fetch changes from the remote repository.</li> <li><code>git fetch upstream</code> \u2013 Fetches changes from the upstream repository</li> <li><code>git rebase &lt;branch&gt;</code> \u2013 Rebase the current branch.</li> <li><code>git merge &lt;branch&gt;</code> \u2013 Merge a branch into the current branch.</li> <li><code>git merge upstream/main</code> \u2013 Merge changes from upstream/main branch</li> <li><code>git checkout &lt;file&gt;</code> \u2013 Revert changes in a specific file</li> </ol>"},{"location":"develop/#git-submodule-commands","title":"Git Submodule Commands","text":"<ol> <li><code>git submodule status</code> \u2013 Show the status of submodules.</li> <li><code>git submodule add &lt;repo-url&gt; &lt;path&gt;</code> \u2013 Add a new submodule.</li> <li><code>git submodule update --init --recursive</code> \u2013 Initialize and update submodules.</li> <li><code>git submodule add -b &lt;branch&gt; &lt;repo-url&gt; &lt;path&gt;</code> \u2013 Add a submodule tracking a specific branch.</li> </ol>"},{"location":"develop/#formatting-and-linting","title":"Formatting and Linting","text":"<ol> <li><code>ruff format &lt;file&gt;</code> \u2013 Format Python code using Ruff.</li> <li><code>ruff format .</code> \u2013 Format all files using Ruff</li> <li><code>ruff check --fix</code> \u2013 Run Ruff checks and apply automatic fixes</li> <li><code>ruff check --unsafe-fixes --fix</code> \u2013 Run Ruff checks with unsafe fixes</li> <li><code>ruff format notebooks/*</code> \u2013 Format Jupyter notebook files</li> <li><code>ruff clean</code> \u2013 Clean Ruff cache and temporary files</li> <li><code>clang-format &lt;file&gt;</code> \u2013 Format C++ code using Clang-Format.</li> </ol>"},{"location":"develop/#cmake-commands","title":"CMake Commands","text":"<ol> <li><code>cmake --version</code> \u2013 Check the version of CMake.</li> <li><code>cmake &lt;options&gt;</code> \u2013 Generate build files based on <code>CMakeLists.txt</code>.</li> </ol>"},{"location":"develop/#testing-and-debugging","title":"Testing and Debugging","text":"<ol> <li><code>gdb --version</code> \u2013 Check the version of GDB (GNU Debugger).</li> <li><code>gdb &lt;program&gt;</code> \u2013 Debug a program.</li> </ol>"},{"location":"develop/#python-environment-management","title":"Python Environment Management","text":"<ol> <li><code>python3 --version</code> \u2013 Check Python version.</li> <li><code>python3 -m venv &lt;name&gt;</code> \u2013 Create a virtual environment.</li> <li><code>source &lt;venv&gt;/bin/activate</code> \u2013 Activate a virtual environment.</li> <li><code>deactivate</code> \u2013 Deactivate the virtual environment.</li> </ol>"},{"location":"develop/#dependency-and-package-management","title":"Dependency and Package Management","text":"<ol> <li><code>pip install &lt;package&gt;</code> \u2013 Install a Python package.</li> <li><code>pip install -e .</code> \u2013 Install the package in editable mode.</li> <li><code>pip uninstall &lt;package&gt;</code> \u2013 Uninstall a Python package.</li> <li><code>pip freeze</code> \u2013 List installed packages.</li> <li><code>gem install &lt;gem&gt;</code> \u2013 Install a Ruby gem.</li> <li><code>bundle install</code> \u2013 Install Ruby gem dependencies.</li> <li><code>pip install /path/to/&lt;package.whl&gt;</code> \u2013 Install a locally built wheel.</li> <li><code>pip uninstall &lt;package&gt;</code> \u2013 Uninstall a Python package.</li> </ol>"},{"location":"develop/#building-and-publishing-python-packages","title":"Building and Publishing Python Packages","text":"<ol> <li><code>python -m build</code> \u2013 Build a Python package.</li> <li><code>twine upload dist/*</code> \u2013 Upload the package to PyPI.</li> <li><code>twine check dist/*</code> \u2013 Check package metadata in dist folder</li> <li><code>twine check dist/* --strict</code> \u2013 Strictly check package metadata in dist fol</li> <li><code>python -m build --wheel</code> \u2013 Build only the wheel package.</li> <li><code>python -m build --sdist</code> \u2013 Build only the source distribution.</li> <li><code>python -m build --platform-tag</code> \u2013 Add a specific platform tag to the build.</li> </ol>"},{"location":"develop/#cibuildwheel","title":"CIBuildWheel","text":"<ol> <li><code>cibuildwheel --output-dir &lt;dir&gt;</code> \u2013 Build Python wheels for multiple platforms.</li> <li><code>cibuildwheel --output-dir &lt;dir&gt; --verbose</code> \u2013 Build wheels with detailed output.</li> <li><code>cibuildwheel --output-dir &lt;dir&gt; --platform &lt;platform&gt;</code> \u2013 Specify a platform for the build (e.g., <code>linux</code>, <code>macos</code>,    or <code>windows</code>). However, usually, defined in the <code>pyproject.toml</code>.</li> </ol>"},{"location":"develop/#pre-commit-commands","title":"Pre-Commit Commands","text":"<ol> <li><code>pre-commit install --hook-type &lt;type&gt;</code> \u2013 Install specific pre-commit hooks (e.g., <code>commit-msg</code>, <code>pre-push</code>).</li> <li><code>pre-commit migrate-config</code> \u2013 Migrate <code>.pre-commit-config.yaml</code> to the latest format.</li> <li><code>pre-commit autoupdate</code> \u2013 Update all pre-commit hooks to their latest versions.</li> <li><code>pre-commit run --all-files</code> \u2013 Run hooks on all files.</li> </ol>"},{"location":"develop/#testing-and-cicd","title":"Testing and CI/CD","text":"<ol> <li><code>pre-commit install</code> \u2013 Install pre-commit hooks.</li> <li><code>pre-commit run</code> \u2013 Run all pre-commit hooks.</li> <li><code>ctest</code> \u2013 Run CMake-based tests.</li> <li><code>cibuildwheel --output-dir dist</code> \u2013 Build Python wheels.</li> </ol>"},{"location":"develop/#commitizen-cz","title":"Commitizen (cz)","text":"<ol> <li><code>cz init</code> \u2013 Initialize Commitizen configuration.</li> <li><code>cz bump</code> \u2013 Automate version bump.</li> <li><code>cz bump --dry-run</code> \u2013 Simulate version bump.</li> </ol>"},{"location":"develop/#doxygen","title":"Doxygen","text":"<ol> <li><code>sudo apt install doxygen</code>  \u2013 Install Doxygen using APT</li> <li><code>apt show doxygen</code> \u2013 displays detailed information about the doxygen package</li> <li><code>doxygen -g Doxyfile</code> \u2013 generates a default configuration file named Doxyfile for Doxygen</li> <li><code>doxygen Doxyfile</code> \u2013 Generate Doxgen Docs based on configuration in <code>Doxyfile</code></li> <li><code>python3 -m http.server 8000 --directory docs/html/</code> \u2013 Serve documentation locally on port <code>8000</code></li> <li><code>doxygen -w html header.html footer.html style.css</code> \u2013 Generate template files for customizing Doxygen's output.</li> <li><code>doxygen --version</code> - get version</li> </ol> <p>Installation script (used in <code>doxygen.yml</code>):</p> <pre><code>export DOXY_VERSION=1.13.1\necho \"Installing doxgen v$DOXY_VERSION\"\nsudo apt-get update &amp;&amp; sudo apt-get install -y graphviz\nmkdir doxygen-installer\nwget \"https://www.doxygen.nl/files/doxygen-${DOXY_VERSION}.linux.bin.tar.gz\"\nmv \"doxygen-${DOXY_VERSION}.linux.bin.tar.gz\" doxygen-installer\ncd doxygen-installer\ngunzip \"doxygen-${DOXY_VERSION}.linux.bin.tar.gz\"\ntar xf \"doxygen-${DOXY_VERSION}.linux.bin.tar\"\ncd \"doxygen-${DOXY_VERSION}\"\nls -laht\nsudo make install\n</code></pre>"},{"location":"develop/#configuration-and-logs","title":"Configuration and Logs","text":"<ol> <li><code>nano ~/.bashrc</code> \u2013 Edit the bash configuration file.</li> <li><code>cat &lt;file&gt;</code> \u2013 View file contents.</li> <li><code>pip show &lt;package&gt;</code> \u2013 Display package details.</li> <li><code>sudo apt install &lt;package&gt;</code> \u2013 Install a package using APT.</li> </ol>"},{"location":"develop/#mkdocs","title":"mkdocs","text":"<ol> <li><code>pip install mkdocs-material mkdocstrings[python] pymdown-extensions</code> - mkdocs extensions</li> <li><code>mkdocs build</code></li> <li><code>mkdocs serve</code></li> </ol>"},{"location":"develop/#nodejs-and-npm","title":"Node.js and NPM","text":"<ol> <li><code>nvm install &lt;version&gt;</code> \u2013 Install a specific Node.js version.</li> <li><code>node -v</code> \u2013 Check Node.js version.</li> <li><code>npm -v</code> \u2013 Check NPM version.</li> <li><code>npm install --save-dev &lt;package&gt;</code> \u2013 Install a development dependency.</li> <li><code>npx prettier . --check</code> \u2013 Check code formatting with Prettier.</li> <li><code>npx prettier . --write</code> \u2013 Format code with Prettier.</li> </ol>"},{"location":"develop/#docker","title":"Docker","text":"<ol> <li><code>docker compose pull</code> \u2013 Pull updated images for the services.</li> <li><code>docker compose up</code> \u2013 Start Docker Compose services.</li> <li><code>docker compose up --help</code> \u2013 Display help for Docker Compose.</li> </ol>"},{"location":"develop/#ruby-and-rbenv","title":"Ruby and Rbenv","text":"<ol> <li><code>rbenv install &lt;version&gt;</code> \u2013 Install a specific Ruby version.</li> <li><code>rbenv local &lt;version&gt;</code> \u2013 Set a local Ruby version for a project.</li> <li><code>gem install bundle</code> \u2013 Install the Bundler gem.</li> <li><code>bundle install</code> \u2013 Install Ruby project dependencies.</li> </ol>"},{"location":"develop/#jekyll","title":"Jekyll","text":"<ol> <li><code>bundle exec jekyll serve --incremental</code> \u2013 Run a Jekyll server incrementally.</li> <li><code>bundle exec jekyll serve --lsi</code> \u2013 Run Jekyll with LSI (Latent Semantic Indexing).</li> <li><code>bundle install</code> \u2013 Install dependencies from the Gemfile.</li> </ol>"},{"location":"develop/#miscellaneous","title":"Miscellaneous","text":"<ol> <li><code>ls</code> \u2013 List directory contents.</li> <li><code>cd &lt;path&gt;</code> \u2013 Change directory.</li> <li><code>history | grep &lt;keyword&gt;</code> \u2013 Search command history.</li> <li><code>htop</code> \u2013 Display interactive process viewer.</li> <li><code>tmux</code> \u2013 Start a new tmux session.</li> </ol>"},{"location":"develop/#github-snake","title":"GitHub Snake","text":""},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installing-bitbully","title":"Installing BitBully","text":"<p>Install BitBully via pip:</p> LatestWith GUI Support (Jupyter Notebboks)Version x.y.z <pre><code>pip install bitbully\n</code></pre> <pre><code>pip install bitbully[gui]\n</code></pre> <pre><code>pip install bitbully==x.y.z\n</code></pre>"},{"location":"getting_started/#usage","title":"Usage","text":""},{"location":"getting_started/#minimal-example-create-a-board-and-let-bitbully-pick-a-move","title":"Minimal Example: create a board and let BitBully pick a move","text":"<pre><code>import bitbully as bb\n\n# Create an empty Connect-4 board\nboard = bb.Board()\n\n# Create the BitBully AI (loads the default opening book)\nagent = bb.BitBully()\n\nprint(board)\n\n# Ask the AI to evaluate all legal moves\nscores = agent.score_all_moves(board)\nprint(\"Move scores:\", scores)\n\n# Pick the best move and play it\nbest_col = agent.best_move(board)\nboard.play(best_col)\n\nprint(\"After best move:\")\nprint(board)\n</code></pre>"},{"location":"getting_started/#play-a-few-moves-manually","title":"Play a few moves manually","text":"<pre><code>import bitbully as bb\n\nboard = bb.Board()\n\n# Moves can be played as:\nboard.play(3)          # single column\nboard.play([2, 4, 3])  # list of columns\nboard.play(\"001122\")   # compact move string\n\nprint(board)\n</code></pre>"},{"location":"getting_started/#simple-example-with-a-concrete-position","title":"Simple example with a concrete position","text":"<pre><code>import bitbully as bb\n\n# Create a position from a move sequence\n# Players alternate automatically\nboard = bb.Board(\"33331\")\n\nprint(board)\n\nagent = bb.BitBully()\n\nscores = agent.score_all_moves(board)\nprint(\"Move scores:\", scores)\n\nbest_col = agent.best_move(board)\nprint(\"Best move:\", best_col)\n</code></pre>"},{"location":"getting_started/#let-the-ai-play-a-full-game-against-itself","title":"Let the AI play a full game against itself","text":"<pre><code>import bitbully as bb\n\nboard = bb.Board()\nagent = bb.BitBully()\n\nwhile not board.is_game_over():\n    col = agent.best_move(board, tie_break=\"random\")\n    board.play(col)\n\nprint(board)\nprint(\"Winner:\", board.winner())  # 1, 2, or None (draw)\n</code></pre>"},{"location":"getting_started/#understanding-the-board-state","title":"Understanding the board state","text":"<pre><code>import bitbully as bb\n\nboard = bb.Board(\"332311\")\n\nprint(board)\n\nprint(\"Current player:\", board.current_player())\nprint(\"Legal moves:\", board.legal_moves())\nprint(\"Can win next:\", board.can_win_next())\nprint(\"Has win:\", board.has_win())\nprint(\"Game over:\", board.is_game_over())\n</code></pre>"},{"location":"getting_started/#notes-for-beginners","title":"Notes for beginners","text":"<ul> <li>Column indices range from <code>0</code> to <code>6</code> (left to right).</li> <li><code>Board.play(...)</code> automatically alternates between players.</li> <li><code>BitBully.best_move(...)</code> returns the selected column index.</li> <li>The default <code>BitBully</code> agent plays optimal (perfect) Connect-4.</li> </ul>"},{"location":"gui_c4/","title":"gui_c4","text":""},{"location":"gui_c4/#src.bitbully.gui_c4","title":"gui_c4","text":"<p>GUI module for the BitBully Connect-4 interactive widget.</p> <p>Classes:</p> Name Description <code>GuiC4</code> <p>A class which allows to create an interactive Connect-4 widget.</p>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4","title":"GuiC4","text":"<pre><code>GuiC4(agents: dict[str, Connect4Agent] | Sequence[Connect4Agent] | None = None, *, autoplay: bool = False)\n</code></pre> <p>A class which allows to create an interactive Connect-4 widget.</p> <p>GuiC4 is an interactive Connect-4 graphical user interface (GUI) implemented using Matplotlib, IPython widgets, and a backend agent from the BitBully engine. It provides the following main features:</p> <ul> <li>Interactive Game Board: Presents a dynamic 6-row by 7-column     Connect-4 board with clickable board cells.</li> <li>Matplotlib Integration: Utilizes Matplotlib figures     to render high-quality game visuals directly within Jupyter notebook environments.</li> <li>User Interaction: Captures and processes mouse clicks and button events, enabling     intuitive gameplay via either direct board interaction or button controls.</li> <li>Undo/Redo Moves: Supports undo and redo functionalities, allowing users to     navigate through their move history during gameplay.</li> <li>Automated Agent Moves: Incorporates BitBully, a Connect-4 backend engine, enabling     computer-generated moves and board evaluations.</li> <li>Game State Handling: Detects game-over scenarios, including win/draw conditions,     and provides immediate user feedback through popup alerts.</li> </ul> <p>Attributes:</p> Name Type Description <code>notify_output</code> <code>Output</code> <p>Output widget for notifications and popups.</p> <p>Examples:</p> <p>Generally, you should this method to retreive and display the widget.</p> <pre><code>&gt;&gt;&gt; %matplotlib ipympl\n&gt;&gt;&gt; c4gui = GuiC4()\n&gt;&gt;&gt; display(c4gui.get_widget())\n</code></pre> <p>Methods:</p> Name Description <code>destroy</code> <p>Destroy and release the acquired resources.</p> <code>get_widget</code> <p>Get the widget.</p> Source code in <code>src/bitbully/gui_c4.py</code> <pre><code>def __init__(\n    self,\n    agents: dict[str, Connect4Agent] | Sequence[Connect4Agent] | None = None,\n    *,\n    autoplay: bool = False,\n) -&gt; None:\n    \"\"\"Init the GuiC4 widget.\"\"\"\n    # Create a logger with the class name\n    self.m_logger = logging.getLogger(self.__class__.__name__)\n    self.m_logger.setLevel(logging.DEBUG)  # Set the logging level\n\n    # Create a console handler (optional)\n    ch = logging.StreamHandler()\n    ch.setLevel(logging.INFO)  # Set level for the handler\n\n    # Create a formatter and add it to the handler\n    formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n    ch.setFormatter(formatter)\n\n    # Add the handler to the logger\n    if not self.m_logger.handlers:\n        self.m_logger.addHandler(ch)\n\n    # Avoid adding handlers multiple times\n    self.m_logger.propagate = False\n    assets_pth = Path(str(importlib.resources.files(\"bitbully\").joinpath(\"assets\")))\n    png_empty = plt.imread(assets_pth.joinpath(\"empty.png\"), format=None)\n    png_empty_m = plt.imread(assets_pth.joinpath(\"empty_m.png\"), format=None)\n    png_empty_r = plt.imread(assets_pth.joinpath(\"empty_r.png\"), format=None)\n    png_red = plt.imread(assets_pth.joinpath(\"red.png\"), format=None)\n    png_red_m = plt.imread(assets_pth.joinpath(\"red_m.png\"), format=None)\n    png_yellow = plt.imread(assets_pth.joinpath(\"yellow.png\"), format=None)\n    png_yellow_m = plt.imread(assets_pth.joinpath(\"yellow_m.png\"), format=None)\n    self.m_png = {\n        0: {\"plain\": png_empty, \"corner\": png_empty_m, \"underline\": png_empty_r},\n        1: {\"plain\": png_yellow, \"corner\": png_yellow_m},\n        2: {\"plain\": png_red, \"corner\": png_red_m},\n    }\n\n    self.m_n_row, self.m_n_col = 6, 7\n\n    # TODO: probably not needed:\n    self.m_height = np.zeros(7, dtype=np.int32)\n\n    self.m_board_size = 3.5\n    # self.m_player = 1\n    self.is_busy = False\n\n    # ---------------- multi-agent support ----------------\n    self.autoplay = bool(autoplay)\n\n    # Normalize `agents` into a dict[str, Connect4Agent]\n    if agents is None:\n        self.agents: dict[str, Connect4Agent] = {}\n    elif isinstance(agents, dict):\n        self.agents = dict(agents)\n    else:\n        self.agents = {f\"agent{i + 1}\": a for i, a in enumerate(agents)}\n\n    self._agent_names: list[str] = list(self.agents.keys())\n\n    # Which controller plays which color\n    # values are either \"human\" or one of self._agent_names\n    self.yellow_player: str = \"human\"\n    self.red_player: str = self._agent_names[0] if self._agent_names else \"human\"\n\n    # Which agent should be used for the \"Evaluate\" button.\n    # Values: \"auto\" or one of self._agent_names (if any exist)\n    self.eval_agent_choice: str = \"auto\"\n\n    # Create board first\n    self._create_board()\n\n    # timing row (must exist before get_widget())\n    self._create_status_bar()\n\n    # Generate buttons for inserting the tokens:\n    self._create_buttons()\n\n    # Create control buttons\n    self._create_control_buttons()\n\n    # player selection dropdowns (must exist before get_widget())\n    self._create_player_selectors()\n\n    # evaluation row widget (must exist before get_widget())\n    self._create_eval_row()\n\n    # Capture clicks on the field\n    _ = self.m_fig.canvas.mpl_connect(\"button_press_event\", self._on_field_click)\n\n    # Movelist\n    self.m_movelist: list[tuple[int, int, int]] = []\n\n    # Redo list\n    self.m_redolist: list[tuple[int, int, int]] = []\n\n    # Gameover flag:\n    self.m_gameover = False\n\n    # NEW: move list + copy position UI\n    self._create_move_list_ui()\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.agents","title":"agents  <code>instance-attribute</code>","text":"<pre><code>agents: dict[str, Connect4Agent] = {}\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.autoplay","title":"autoplay  <code>instance-attribute</code>","text":"<pre><code>autoplay = bool(autoplay)\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.eval_agent_choice","title":"eval_agent_choice  <code>instance-attribute</code>","text":"<pre><code>eval_agent_choice: str = 'auto'\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.is_busy","title":"is_busy  <code>instance-attribute</code>","text":"<pre><code>is_busy = False\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.m_board_size","title":"m_board_size  <code>instance-attribute</code>","text":"<pre><code>m_board_size = 3.5\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.m_gameover","title":"m_gameover  <code>instance-attribute</code>","text":"<pre><code>m_gameover = False\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.m_height","title":"m_height  <code>instance-attribute</code>","text":"<pre><code>m_height = zeros(7, dtype=int32)\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.m_logger","title":"m_logger  <code>instance-attribute</code>","text":"<pre><code>m_logger = getLogger(__name__)\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.m_movelist","title":"m_movelist  <code>instance-attribute</code>","text":"<pre><code>m_movelist: list[tuple[int, int, int]] = []\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.m_png","title":"m_png  <code>instance-attribute</code>","text":"<pre><code>m_png = {0: {'plain': png_empty, 'corner': png_empty_m, 'underline': png_empty_r}, 1: {'plain': png_yellow, 'corner': png_yellow_m}, 2: {'plain': png_red, 'corner': png_red_m}}\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.m_redolist","title":"m_redolist  <code>instance-attribute</code>","text":"<pre><code>m_redolist: list[tuple[int, int, int]] = []\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.notify_output","title":"notify_output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>notify_output: Output = Output()\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.red_player","title":"red_player  <code>instance-attribute</code>","text":"<pre><code>red_player: str = _agent_names[0] if _agent_names else 'human'\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.yellow_player","title":"yellow_player  <code>instance-attribute</code>","text":"<pre><code>yellow_player: str = 'human'\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.destroy","title":"destroy","text":"<pre><code>destroy() -&gt; None\n</code></pre> <p>Destroy and release the acquired resources.</p> Source code in <code>src/bitbully/gui_c4.py</code> <pre><code>def destroy(self) -&gt; None:\n    \"\"\"Destroy and release the acquired resources.\"\"\"\n    plt.close(self.m_fig)\n    del self.agents\n    del self.m_axs\n    del self.m_fig\n    del self.output\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.get_widget","title":"get_widget","text":"<pre><code>get_widget() -&gt; AppLayout\n</code></pre> <p>Get the widget.</p> <p>Examples:</p> <p>Generally, you should this method to retreive and display the widget.</p> <pre><code>&gt;&gt;&gt; %matplotlib ipympl\n&gt;&gt;&gt; c4gui = GuiC4()\n&gt;&gt;&gt; display(c4gui.get_widget())\n</code></pre> <p>Returns:</p> Name Type Description <code>AppLayout</code> <code>AppLayout</code> <p>the widget.</p> Source code in <code>src/bitbully/gui_c4.py</code> <pre><code>def get_widget(self) -&gt; AppLayout:\n    \"\"\"Get the widget.\n\n    Examples:\n        Generally, you should this method to retreive and display the widget.\n\n        ```pycon\n        &gt;&gt;&gt; %matplotlib ipympl\n        &gt;&gt;&gt; c4gui = GuiC4()\n        &gt;&gt;&gt; display(c4gui.get_widget())\n        ```\n\n    Returns:\n        AppLayout: the widget.\n    \"\"\"\n    # Arrange buttons in a row\n    insert_button_row = HBox(\n        [VBox(layout=Layout(padding=\"0px 0px 0px 6px\")), *self.m_insert_buttons],\n        layout=Layout(\n            display=\"flex\",\n            flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n            justify_content=\"center\",  # Left alignment\n            align_items=\"center\",  # Top alignment\n        ),\n    )\n    control_buttons_col = HBox(\n        [VBox(list(self.m_control_buttons.values()))],\n        layout=Layout(\n            display=\"flex\",\n            flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n            justify_content=\"flex-end\",\n            align_items=\"center\",  # bottom alignment\n        ),\n    )\n\n    # deactivate for now\n    # tb = self._create_column_labels()\n\n    right = VBox(\n        [self.move_list_row],\n        layout=Layout(\n            display=\"flex\",\n            flex_flow=\"column\",\n            justify_content=\"flex-start\",\n            align_items=\"stretch\",\n            width=\"200px\",\n            height=\"90%\",  # NEW: fill AppLayout height\n            flex=\"1 1 auto\",  # NEW: allow it to grow\n        ),\n    )\n\n    main = HBox(\n        [\n            VBox(\n                [\n                    self.player_select_row,\n                    insert_button_row,\n                    self.output,\n                    self.m_eval_row,\n                    self.m_time_row,\n                ],\n                layout=Layout(\n                    display=\"flex\",\n                    flex_flow=\"column\",\n                    align_items=\"flex-start\",\n                ),\n            ),\n            right,\n        ],\n        layout=Layout(\n            display=\"flex\",\n            flex_flow=\"row\",\n            align_items=\"flex-start\",\n            justify_content=\"flex-start\",\n            gap=\"5px\",  # space between board and sidebar\n            width=\"100%\",\n        ),\n    )\n\n    return AppLayout(\n        header=None,\n        left_sidebar=control_buttons_col,\n        center=main,\n        right_sidebar=None,  # &lt;= important\n        footer=None,\n        layout=Layout(grid_gap=\"0px\"),\n    )\n</code></pre>"},{"location":"interface/","title":"agent interface","text":""},{"location":"interface/#src.bitbully.agent_interface","title":"agent_interface","text":"<p>Agent interface definitions for Connect-4.</p> <p>This module defines the minimal, structural interface that Connect-4 agents must implement in order to be compatible with the interactive GUI and other high-level components. The interface is expressed using <code>typing.Protocol</code> to enable static type checking without requiring inheritance or tight coupling between agents and consumers.</p> <p>Classes:</p> Name Description <code>Connect4Agent</code> <p>Minimal interface a Connect-4 agent must implement to work with <code>GuiC4</code>.</p>"},{"location":"interface/#src.bitbully.agent_interface.Connect4Agent","title":"Connect4Agent","text":"<pre><code>\n              flowchart TD\n              src.bitbully.agent_interface.Connect4Agent[Connect4Agent]\n\n              \n\n              click src.bitbully.agent_interface.Connect4Agent href \"\" \"src.bitbully.agent_interface.Connect4Agent\"\n            </code></pre> <p>Minimal interface a Connect-4 agent must implement to work with <code>GuiC4</code>.</p> <p>This interface is intentionally aligned with the public <code>BitBully</code> API, but excludes BitBully-specific engine features such as opening-book handling, node counters, transposition tables, and specialized search entry points.</p> Required methods <ul> <li><code>score_all_moves</code>: Provide integer evaluations for all legal moves.</li> <li><code>best_move</code>: Select one legal move using BitBully-compatible   tie-breaking semantics.</li> </ul> Notes on scoring <ul> <li>Scores are integers where larger values are better for the side to move.</li> <li>The absolute scale is agent-defined.</li> <li>The GUI only relies on relative ordering and legality.</li> </ul> Example <p>Minimal agent compatible with the <code>Connect4Agent</code> protocol:</p> <pre><code>import random\nfrom bitbully import Board\n\n# Importing the Protocol is optional at runtime, but useful for:\n#  - static type checking (mypy / pyright)\n#  - documenting that this class satisfies the agent interface\nfrom bitbully.agent_protocols import Connect4Agent\n\n\nclass RandomAgent:\n    '''Agent that plays a random legal move.\n\n    This class does NOT inherit from ``Connect4Agent``.\n    It is compatible because it implements the required methods\n    with matching signatures (structural typing).\n    '''\n\n    def score_all_moves(self, board: Board) -&gt; dict[int, int]:\n        # Only legal columns may appear in the result.\n        # The GUI and other consumers rely on this contract.\n        return {c: 0 for c in board.legal_moves()}\n\n    def best_move(self, board: Board) -&gt; int:\n        # Consumers may call only ``best_move`` if they are\n        # not interested in individual move scores.\n        return random.choice(board.legal_moves())\n\n\nboard = Board(\"332311\")\n\n# The variable annotation enforces the protocol at type-check time.\nagent: Connect4Agent = RandomAgent()\n\nmove = agent.best_move(board)\nboard.play(move)\n</code></pre> Returned by: <ul> <li> BitBully API Reference <code></code>\u00a0gui_c4 <code></code>\u00a0GuiC4 <code></code>\u00a0agents </li> </ul> Used by: <ul> <li> BitBully API Reference <code></code>\u00a0gui_c4 <code></code>\u00a0GuiC4 </li> </ul> <p>Methods:</p> Name Description <code>best_move</code> <p>Return the best legal move (column index) for the side to move.</p> <code>score_all_moves</code> <p>Score all legal moves for the given board state.</p> <code>score_move</code> <p>Evaluate a single legal move for the given board state.</p>"},{"location":"interface/#src.bitbully.agent_interface.Connect4Agent.best_move","title":"best_move","text":"<pre><code>best_move(board: Board) -&gt; int\n</code></pre> <p>Return the best legal move (column index) for the side to move.</p> <p>Parameters:</p> Name Type Description Default <code>Board</code> <p>Current Connect-4 board position.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Selected column index in the range <code>0..6</code>.</p> Source code in <code>src/bitbully/agent_interface.py</code> <pre><code>def best_move(\n    self,\n    board: Board,\n) -&gt; int:\n    \"\"\"Return the best legal move (column index) for the side to move.\n\n    Args:\n        board (Board):\n            Current Connect-4 board position.\n\n    Returns:\n        int:\n            Selected column index in the range ``0..6``.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"interface/#src.bitbully.agent_interface.Connect4Agent.best_move(board)","title":"<code>board</code>","text":""},{"location":"interface/#src.bitbully.agent_interface.Connect4Agent.score_all_moves","title":"score_all_moves","text":"<pre><code>score_all_moves(board: Board) -&gt; dict[int, int]\n</code></pre> <p>Score all legal moves for the given board state.</p> <p>Parameters:</p> Name Type Description Default <code>Board</code> <p>Current Connect-4 board position.</p> required <p>Returns:</p> Type Description <code>dict[int, int]</code> <p>dict[int, int]: Mapping <code>{column: score}</code> for all legal columns (0..6). Columns that are full or illegal must not appear in the mapping.</p> Notes <ul> <li>Higher scores indicate better moves.</li> <li>The returned dictionary may contain between 0 and 7 entries.</li> </ul> Source code in <code>src/bitbully/agent_interface.py</code> <pre><code>def score_all_moves(self, board: Board) -&gt; dict[int, int]:\n    \"\"\"Score all legal moves for the given board state.\n\n    Args:\n        board (Board):\n            Current Connect-4 board position.\n\n    Returns:\n        dict[int, int]:\n            Mapping ``{column: score}`` for all *legal* columns (0..6).\n            Columns that are full or illegal **must not** appear in the mapping.\n\n    Notes:\n        - Higher scores indicate better moves.\n        - The returned dictionary may contain between 0 and 7 entries.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"interface/#src.bitbully.agent_interface.Connect4Agent.score_all_moves(board)","title":"<code>board</code>","text":""},{"location":"interface/#src.bitbully.agent_interface.Connect4Agent.score_move","title":"score_move","text":"<pre><code>score_move(board: Board, column: int, first_guess: int = 0) -&gt; int\n</code></pre> <p>Evaluate a single legal move for the given board state.</p> <p>This method is optional and not required by the GUI, but can be useful for agents that support fine-grained move evaluation.</p> <p>Parameters:</p> Name Type Description Default <code>Board</code> <p>Current Connect-4 board position.</p> required <code>int</code> <p>Column index (0..6) of the move to evaluate.</p> required <code>int</code> <p>Optional initial guess for iterative or search-based agents. Implementations may safely ignore this parameter.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Evaluation score for the given move.</p> Source code in <code>src/bitbully/agent_interface.py</code> <pre><code>def score_move(self, board: Board, column: int, first_guess: int = 0) -&gt; int:\n    \"\"\"Evaluate a single legal move for the given board state.\n\n    This method is optional and not required by the GUI, but can be useful\n    for agents that support fine-grained move evaluation.\n\n    Args:\n        board (Board):\n            Current Connect-4 board position.\n        column (int):\n            Column index (0..6) of the move to evaluate.\n        first_guess (int):\n            Optional initial guess for iterative or search-based agents.\n            Implementations may safely ignore this parameter.\n\n    Returns:\n        int:\n            Evaluation score for the given move.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"interface/#src.bitbully.agent_interface.Connect4Agent.score_move(board)","title":"<code>board</code>","text":""},{"location":"interface/#src.bitbully.agent_interface.Connect4Agent.score_move(column)","title":"<code>column</code>","text":""},{"location":"interface/#src.bitbully.agent_interface.Connect4Agent.score_move(first_guess)","title":"<code>first_guess</code>","text":""},{"location":"solver/","title":"solver","text":""},{"location":"solver/#src.bitbully.solver","title":"solver","text":"<p>This module provides the Connect Four AI agent \"BitBully\" with opening book support.</p> <p>Classes:</p> Name Description <code>BitBully</code> <p>A Connect Four AI agent with optional opening book support.</p> <p>Attributes:</p> Name Type Description <code>OpeningBookName</code> <code>TypeAlias</code> <p>Name of the opening book used by the BitBully engine.</p> <code>TieBreakStrategy</code> <code>TypeAlias</code> <p>Strategy for breaking ties between equally good moves.</p>"},{"location":"solver/#src.bitbully.solver.OpeningBookName","title":"OpeningBookName  <code>module-attribute</code>","text":"<pre><code>OpeningBookName: TypeAlias = Literal['default', '8-ply', '12-ply', '12-ply-dist']\n</code></pre> <p>Name of the opening book used by the BitBully engine.</p> <p>Possible values: - <code>\"default\"</code>: Alias for <code>\"12-ply-dist\"</code>. - <code>\"8-ply\"</code>: 8-ply opening book (win/loss only). - <code>\"12-ply\"</code>: 12-ply opening book (win/loss only). - <code>\"12-ply-dist\"</code>: 12-ply opening book with distance-to-win information.</p> Returned by: <ul> <li> BitBully API Reference <code></code>\u00a0solver <code></code>\u00a0BitBully <ul> <li> <code></code>\u00a0opening_book_type </li> <li> <code></code>\u00a0available_opening_books </li> </ul> </li> </ul> Used by: <ul> <li> BitBully API Reference <code></code>\u00a0solver <code></code>\u00a0BitBully </li> </ul>"},{"location":"solver/#src.bitbully.solver.TieBreakStrategy","title":"TieBreakStrategy  <code>module-attribute</code>","text":"<pre><code>TieBreakStrategy: TypeAlias = Literal['center', 'leftmost', 'random']\n</code></pre> <p>Strategy for breaking ties between equally good moves.</p> <p>Possible values: - <code>\"center\"</code>: Prefer moves closer to the center column. - <code>\"leftmost\"</code>: Prefer the leftmost among the best moves. - <code>\"random\"</code>: Choose randomly among the best moves.</p> Used by: <ul> <li> BitBully API Reference <code></code>\u00a0solver <code></code>\u00a0BitBully </li> </ul>"},{"location":"solver/#src.bitbully.solver.BitBully","title":"BitBully","text":"<pre><code>BitBully(opening_book: OpeningBookName | None = 'default', *, tie_break: TieBreakStrategy | None = None, rng: Random | None = None)\n</code></pre> <p>A Connect Four AI agent with optional opening book support.</p> <p>Todo: - We have to describe the scoring scheme (range of values and their meaning).</p> <p>This class is a high-level Python wrapper around <code>bitbully_core.BitBullyCore</code>. It integrates the packaged BitBully Databases opening books and operates on <code>bitbully.Board</code> objects.</p> Notes <ul> <li>If an opening book is enabled, it is used automatically for   early-game positions.</li> <li>For deeper positions or positions outside the database horizon,   the engine falls back to search-based evaluation.</li> </ul> Example <pre><code>from bitbully import BitBully, Board\n\nagent = BitBully()\nboard, _ = Board.random_board(n_ply=14, forbid_direct_win=True)\nprint(board)\n\n# All three search methods should agree on the score\nscore_mtdf = agent.mtdf(board)\nscore_negamax = agent.negamax(board)\nscore_null_window = agent.null_window(board)\nassert score_negamax == score_null_window == score_mtdf\n</code></pre> Example <pre><code>from bitbully import BitBully, Board\n\nboard = Board()  # empty board\nagent = BitBully()\nscores = agent.score_all_moves(board)  # get scores for all moves\nassert len(scores) == 7  # there are 7 columns\nassert scores == {3: 1, 2: 0, 4: 0, 1: -1, 5: -1, 0: -2, 6: -2}  # center column is best\nprint(scores)\n</code></pre> <p>Expected Output: <pre><code>{3: 1, 2: 0, 4: 0, 1: -1, 5: -1, 0: -2, 6: -2}\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>OpeningBookName | None</code> <p>Which opening book to load.</p> <ul> <li><code>\"default\"</code>: Alias for <code>\"12-ply-dist\"</code>.</li> <li><code>\"8-ply\"</code>: 8-ply book with win/loss values.</li> <li><code>\"12-ply\"</code>: 12-ply book with win/loss values.</li> <li><code>\"12-ply-dist\"</code>: 12-ply book with win/loss and distance values.</li> <li><code>None</code>: Disable opening-book usage entirely.</li> </ul> <code>'default'</code> <code>TieBreakStrategy | None</code> <p>Default strategy for breaking ties between equally scoring moves. If <code>None</code>, defaults to <code>\"center\"</code>.</p> <code>None</code> <code>Random | None</code> <p>Optional RNG for reproducible \"random\" tie-breaking.</p> <code>None</code> <p>TODO: Example for initialization with different books.</p> <p>Methods:</p> Name Description <code>__repr__</code> <p>Return a concise string representation of the BitBully agent.</p> <code>available_opening_books</code> <p>Return the available opening book identifiers.</p> <code>best_move</code> <p>Return the best legal move (column index) for the current player.</p> <code>get_node_counter</code> <p>Return the number of nodes visited since the last reset.</p> <code>is_book_loaded</code> <p>Check whether an opening book is loaded.</p> <code>load_book</code> <p>Load an opening book from a file path.</p> <code>mtdf</code> <p>Evaluate a position using the MTD(f) algorithm.</p> <code>negamax</code> <p>Evaluate a position using negamax search.</p> <code>null_window</code> <p>Evaluate a position using a null-window search.</p> <code>reset_book</code> <p>Unload the currently loaded opening book (if any).</p> <code>reset_node_counter</code> <p>Reset the internal node counter.</p> <code>reset_transposition_table</code> <p>Clear the internal transposition table.</p> <code>score_all_moves</code> <p>Score all legal moves for the given board state.</p> <code>score_move</code> <p>Evaluate a single move for the given board state.</p> <p>Attributes:</p> Name Type Description <code>opening_book_type</code> <code>OpeningBookName | None</code> <code>rng</code> <code>tie_break</code> Source code in <code>src/bitbully/solver.py</code> <pre><code>def __init__(\n    self,\n    opening_book: OpeningBookName | None = \"default\",\n    *,\n    tie_break: TieBreakStrategy | None = None,\n    rng: random.Random | None = None,\n) -&gt; None:\n    \"\"\"Initialize the BitBully agent.\n\n    Args:\n        opening_book (OpeningBookName | None):\n            Which opening book to load.\n\n            - ``\"default\"``: Alias for ``\"12-ply-dist\"``.\n            - ``\"8-ply\"``: 8-ply book with win/loss values.\n            - ``\"12-ply\"``: 12-ply book with win/loss values.\n            - ``\"12-ply-dist\"``: 12-ply book with win/loss *and distance* values.\n            - ``None``: Disable opening-book usage entirely.\n        tie_break (TieBreakStrategy | None):\n            Default strategy for breaking ties between equally scoring moves.\n            If ``None``, defaults to ``\"center\"``.\n        rng (random.Random | None):\n            Optional RNG for reproducible \"random\" tie-breaking.\n\n    TODO: Example for initialization with different books.\n\n    \"\"\"\n    self.opening_book_type: OpeningBookName | None = opening_book\n    self.tie_break = tie_break if tie_break is not None else \"center\"\n    self.rng = rng if rng is not None else random.Random()\n\n    if opening_book is None:\n        self._core = bitbully_core.BitBullyCore()\n        return\n\n    import bitbully_databases as bbd\n\n    db_path = bbd.BitBullyDatabases.get_database_path(opening_book)\n    self._core = bitbully_core.BitBullyCore(Path(db_path))\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully(opening_book)","title":"<code>opening_book</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully(tie_break)","title":"<code>tie_break</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully(rng)","title":"<code>rng</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully.opening_book_type","title":"opening_book_type  <code>instance-attribute</code>","text":"<pre><code>opening_book_type: OpeningBookName | None = opening_book\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.rng","title":"rng  <code>instance-attribute</code>","text":"<pre><code>rng = rng if rng is not None else Random()\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.tie_break","title":"tie_break  <code>instance-attribute</code>","text":"<pre><code>tie_break = tie_break if tie_break is not None else 'center'\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a concise string representation of the BitBully agent.</p> Source code in <code>src/bitbully/solver.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a concise string representation of the BitBully agent.\"\"\"\n    return f\"BitBully(opening_book={self.opening_book_type!r}, book_loaded={self.is_book_loaded()})\"\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.available_opening_books","title":"available_opening_books  <code>classmethod</code>","text":"<pre><code>available_opening_books() -&gt; tuple[OpeningBookName, ...]\n</code></pre> <p>Return the available opening book identifiers.</p> <p>Returns:</p> Type Description <code>tuple[OpeningBookName, ...]</code> <p>tuple[OpeningBookName, ...]: All supported opening book names, including <code>\"default\"</code>.</p> Example <pre><code>from bitbully import BitBully\n\nbooks = BitBully.available_opening_books()\nprint(books)  # ('default', '8-ply', '12-ply', '12-ply-dist')\n</code></pre> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0solver <code></code>\u00a0BitBully <code></code>\u00a0load_book </li> </ul> Source code in <code>src/bitbully/solver.py</code> <pre><code>@classmethod\ndef available_opening_books(cls) -&gt; tuple[OpeningBookName, ...]:\n    \"\"\"Return the available opening book identifiers.\n\n    Returns:\n        tuple[OpeningBookName, ...]:\n            All supported opening book names, including ``\"default\"``.\n\n    Example:\n        ```python\n        from bitbully import BitBully\n\n        books = BitBully.available_opening_books()\n        print(books)  # ('default', '8-ply', '12-ply', '12-ply-dist')\n        ```\n\n    \"\"\"\n    return get_args(OpeningBookName)\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.best_move","title":"best_move","text":"<pre><code>best_move(board: Board, *, tie_break: TieBreakStrategy | None = None, rng: Random | None = None) -&gt; int\n</code></pre> <p>Return the best legal move (column index) for the current player.</p> <p>All legal moves are scored using :meth:<code>score_all_moves</code>. The move(s) with the highest score are considered best, and ties are resolved according to <code>tie_break</code>.</p> Tie-breaking strategies <ul> <li><code>None</code> (default): Use the agent's default tie-breaking strategy (<code>self.tie_break</code>).</li> <li><code>\"center\"</code> (default):     Prefer the move closest to the center column (3). If still tied,     choose the smaller column index.</li> <li><code>\"leftmost\"</code>:     Choose the smallest column index among tied moves.</li> <li><code>\"random\"</code>:     Choose uniformly at random among tied moves. An optional     <code>rng</code> can be provided for reproducibility.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>Board</code> <p>The current board state.</p> required <code>TieBreakStrategy | None</code> <p>Strategy used to resolve ties between equally scoring moves.</p> <code>None</code> <code>Random | None</code> <p>Random number generator used when <code>tie_break=\"random\"</code>. If <code>None</code>, the agent's (<code>self.rng</code>) RNG is used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The selected column index (0-6).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there are no legal moves (board is full) or if an unknown tie-breaking strategy is specified.</p> Example <pre><code>from bitbully import BitBully, Board\nimport random\n\nagent = BitBully()\nboard = Board()\nbest_col = agent.best_move(board)\nassert best_col == 3  # Center column is best on an empty board\n</code></pre> Example <p><pre><code>from bitbully import BitBully, Board\nimport random\n\nagent = BitBully()\nboard = Board(\"341\")  # some arbitrary position\nprint(board)\nassert agent.best_move(board, tie_break=\"center\") == 3  # Several moves are tied; center is preferred\nassert agent.best_move(board, tie_break=\"leftmost\") == 1  # Leftmost among tied moves\nassert agent.best_move(board, tie_break=\"random\") in {1, 3, 4}  # Random among tied moves\n\nrng = random.Random(42)  # use own random number generator\nassert agent.best_move(board, tie_break=\"random\", rng=rng) in {1, 3, 4}\n</code></pre> Expected Output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  X  _  X  O  _  _\n</code></pre></p> Source code in <code>src/bitbully/solver.py</code> <pre><code>def best_move(\n    self,\n    board: Board,\n    *,\n    tie_break: TieBreakStrategy | None = None,\n    rng: random.Random | None = None,\n) -&gt; int:\n    \"\"\"Return the best legal move (column index) for the current player.\n\n    All legal moves are scored using :meth:`score_all_moves`. The move(s)\n    with the highest score are considered best, and ties are resolved\n    according to ``tie_break``.\n\n    Tie-breaking strategies:\n        - ``None`` (default): Use the agent's default tie-breaking strategy (`self.tie_break`).\n        - ``\"center\"`` (default):\n            Prefer the move closest to the center column (3). If still tied,\n            choose the smaller column index.\n        - ``\"leftmost\"``:\n            Choose the smallest column index among tied moves.\n        - ``\"random\"``:\n            Choose uniformly at random among tied moves. An optional\n            ``rng`` can be provided for reproducibility.\n\n    Args:\n        board (Board): The current board state.\n        tie_break (TieBreakStrategy | None):\n            Strategy used to resolve ties between equally scoring moves.\n        rng (random.Random | None):\n            Random number generator used when ``tie_break=\"random\"``.\n            If ``None``, the agent's (`self.rng`) RNG is used.\n\n    Returns:\n        int: The selected column index (0-6).\n\n    Raises:\n        ValueError: If there are no legal moves (board is full) or\n            if an unknown tie-breaking strategy is specified.\n\n    Example:\n        ```python\n        from bitbully import BitBully, Board\n        import random\n\n        agent = BitBully()\n        board = Board()\n        best_col = agent.best_move(board)\n        assert best_col == 3  # Center column is best on an empty board\n        ```\n\n    Example:\n        ```python\n        from bitbully import BitBully, Board\n        import random\n\n        agent = BitBully()\n        board = Board(\"341\")  # some arbitrary position\n        print(board)\n        assert agent.best_move(board, tie_break=\"center\") == 3  # Several moves are tied; center is preferred\n        assert agent.best_move(board, tie_break=\"leftmost\") == 1  # Leftmost among tied moves\n        assert agent.best_move(board, tie_break=\"random\") in {1, 3, 4}  # Random among tied moves\n\n        rng = random.Random(42)  # use own random number generator\n        assert agent.best_move(board, tie_break=\"random\", rng=rng) in {1, 3, 4}\n        ```\n        Expected Output:\n        ```\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  X  _  X  O  _  _\n        ```\n    \"\"\"\n    scores = self.score_all_moves(board)\n    if not scores:\n        raise ValueError(\"No legal moves available (board appears to be full).\")\n\n    best_score = max(scores.values())\n    best_cols = [c for c, s in scores.items() if s == best_score]\n\n    if len(best_cols) == 1:\n        return best_cols[0]\n\n    if tie_break is None:\n        tie_break = self.tie_break\n    if rng is None:\n        rng = self.rng\n\n    if tie_break == \"center\":\n        # Prefer center column (3), then smaller index for stability.\n        return min(best_cols, key=lambda c: (abs(c - 3), c))\n\n    if tie_break == \"leftmost\":\n        return min(best_cols)\n\n    if tie_break == \"random\":\n        if rng is None:\n            return random.choice(best_cols)\n        return rng.choice(best_cols)\n\n    raise ValueError(f\"Unknown tie-breaking strategy: {tie_break!r}\")\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.best_move(board)","title":"<code>board</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully.best_move(tie_break)","title":"<code>tie_break</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully.best_move(rng)","title":"<code>rng</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully.get_node_counter","title":"get_node_counter","text":"<pre><code>get_node_counter() -&gt; int\n</code></pre> <p>Return the number of nodes visited since the last reset.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of visited nodes.</p> Example <pre><code>from bitbully import BitBully, Board\n\nagent = BitBully()\nboard = Board()\n_ = agent.score_all_moves(board)\nprint(f\"Nodes visited: {agent.get_node_counter()}\")\n\n# Note that has to be reset manually:\nagent.reset_node_counter()\nassert agent.get_node_counter() == 0\n</code></pre> Referenced by: <ul> <li> BitBully API Reference <code></code>\u00a0solver <code></code>\u00a0BitBully <code></code>\u00a0reset_node_counter </li> </ul> Source code in <code>src/bitbully/solver.py</code> <pre><code>def get_node_counter(self) -&gt; int:\n    \"\"\"Return the number of nodes visited since the last reset.\n\n    Returns:\n        int: Number of visited nodes.\n\n    Example:\n        ```python\n        from bitbully import BitBully, Board\n\n        agent = BitBully()\n        board = Board()\n        _ = agent.score_all_moves(board)\n        print(f\"Nodes visited: {agent.get_node_counter()}\")\n\n        # Note that has to be reset manually:\n        agent.reset_node_counter()\n        assert agent.get_node_counter() == 0\n        ```\n    \"\"\"\n    return int(self._core.getNodeCounter())\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.is_book_loaded","title":"is_book_loaded","text":"<pre><code>is_book_loaded() -&gt; bool\n</code></pre> <p>Check whether an opening book is loaded.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if an opening book is loaded, otherwise <code>False</code>.</p> Example <pre><code>from bitbully import BitBully\n\nagent = BitBully()  # per default, the 12-ply-dist book is loaded\nassert agent.is_book_loaded() is True\n\n# Unload the book\nagent.reset_book()\nassert agent.is_book_loaded() is False\n</code></pre> Source code in <code>src/bitbully/solver.py</code> <pre><code>def is_book_loaded(self) -&gt; bool:\n    \"\"\"Check whether an opening book is loaded.\n\n    Returns:\n        bool: ``True`` if an opening book is loaded, otherwise ``False``.\n\n    Example:\n        ```python\n        from bitbully import BitBully\n\n        agent = BitBully()  # per default, the 12-ply-dist book is loaded\n        assert agent.is_book_loaded() is True\n\n        # Unload the book\n        agent.reset_book()\n        assert agent.is_book_loaded() is False\n        ```\n    \"\"\"\n    return bool(self._core.isBookLoaded())\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.load_book","title":"load_book","text":"<pre><code>load_book(book: OpeningBookName | PathLike[str] | str) -&gt; None\n</code></pre> <p>Load an opening book from a file path.</p> <p>This is a thin wrapper around <code>bitbully_core.BitBullyCore.loadBook</code>.</p> <p>Parameters:</p> Name Type Description Default <code>OpeningBookName | PathLike[str] | str</code> <p>Name/Identifier (see <code>available_opening_books</code>) or path of the opening book to load.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the book identifier/path is invalid or if loading the book fails.</p> Example <pre><code>from bitbully import BitBully\nfrom pathlib import Path\n\nwhich_book = BitBully.available_opening_books()[0]  # e.g., \"default\"\n\nagent = BitBully(opening_book=None)  # start without book\nassert agent.is_book_loaded() is False\nagent.load_book(which_book)  # load \"default\" book\nassert agent.is_book_loaded() is True\n</code></pre> Example <pre><code>from bitbully import BitBully\nfrom pathlib import Path\nimport bitbully_databases as bbd\n\nwhich_book = BitBully.available_opening_books()[2]  # e.g., \"12-ply\"\ndb_path = bbd.BitBullyDatabases.get_database_path(which_book)\n\nagent = BitBully(opening_book=None)  # start without book\nassert agent.is_book_loaded() is False\nagent.load_book(db_path)\nassert agent.is_book_loaded() is True\n</code></pre> Source code in <code>src/bitbully/solver.py</code> <pre><code>def load_book(self, book: OpeningBookName | os.PathLike[str] | str) -&gt; None:\n    \"\"\"Load an opening book from a file path.\n\n    This is a thin wrapper around\n    [`bitbully_core.BitBullyCore.loadBook`][src.bitbully.bitbully_core.BitBullyCore.loadBook].\n\n    Args:\n        book (OpeningBookName | os.PathLike[str] | str):\n            Name/Identifier (see [`available_opening_books`][src.bitbully.solver.BitBully.available_opening_books])\n            or path of the opening book to load.\n\n    Raises:\n        ValueError:\n            If the book identifier/path is invalid or if loading the book fails.\n\n    Example:\n        ```python\n        from bitbully import BitBully\n        from pathlib import Path\n\n        which_book = BitBully.available_opening_books()[0]  # e.g., \"default\"\n\n        agent = BitBully(opening_book=None)  # start without book\n        assert agent.is_book_loaded() is False\n        agent.load_book(which_book)  # load \"default\" book\n        assert agent.is_book_loaded() is True\n        ```\n\n    Example:\n        ```python\n        from bitbully import BitBully\n        from pathlib import Path\n        import bitbully_databases as bbd\n\n        which_book = BitBully.available_opening_books()[2]  # e.g., \"12-ply\"\n        db_path = bbd.BitBullyDatabases.get_database_path(which_book)\n\n        agent = BitBully(opening_book=None)  # start without book\n        assert agent.is_book_loaded() is False\n        agent.load_book(db_path)\n        assert agent.is_book_loaded() is True\n        ```\n    \"\"\"\n    self._core.resetBook()\n    if _is_opening_book_name(book):\n        import bitbully_databases as bbd\n\n        db_path = bbd.BitBullyDatabases.get_database_path(book)\n        self.opening_book_type = book\n    elif isinstance(book, (os.PathLike, str)):\n        if isinstance(book, str) and not book.strip():\n            raise ValueError(f\"Invalid book path: {book!r}\")\n        db_path = Path(book)\n        self.opening_book_type = None\n    else:\n        raise ValueError(f\"Invalid book identifier or path: {book!r}\")\n\n    if not self._core.loadBook(db_path):\n        self.opening_book_type = None\n        self._core.resetBook()\n        raise ValueError(f\"Failed to load opening book from path: {db_path}\")\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.load_book(book)","title":"<code>book</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully.mtdf","title":"mtdf","text":"<pre><code>mtdf(board: Board, first_guess: int = 0) -&gt; int\n</code></pre> <p>Evaluate a position using the MTD(f) algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>Board</code> <p>The board position to evaluate.</p> required <code>int</code> <p>Initial guess for the score (often 0).</p> <code>0</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The evaluation score.</p> Example <pre><code>from bitbully import BitBully, Board\n\nagent = BitBully()\nboard = Board()\nscore = agent.mtdf(board)\nassert score == 1  # Expected score for an empty board\n</code></pre> Source code in <code>src/bitbully/solver.py</code> <pre><code>def mtdf(self, board: Board, first_guess: int = 0) -&gt; int:\n    \"\"\"Evaluate a position using the MTD(f) algorithm.\n\n    Args:\n        board (Board): The board position to evaluate.\n        first_guess (int): Initial guess for the score (often 0).\n\n    Returns:\n        int: The evaluation score.\n\n    Example:\n        ```python\n        from bitbully import BitBully, Board\n\n        agent = BitBully()\n        board = Board()\n        score = agent.mtdf(board)\n        assert score == 1  # Expected score for an empty board\n        ```\n    \"\"\"\n    return int(self._core.mtdf(board.native, first_guess=first_guess))\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.mtdf(board)","title":"<code>board</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully.mtdf(first_guess)","title":"<code>first_guess</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully.negamax","title":"negamax","text":"<pre><code>negamax(board: Board, alpha: int = -1000, beta: int = 1000, depth: int = 0) -&gt; int\n</code></pre> <p>Evaluate a position using negamax search.</p> <p>Parameters:</p> Name Type Description Default <code>Board</code> <p>The board position to evaluate.</p> required <code>int</code> <p>Alpha bound.</p> <code>-1000</code> <code>int</code> <p>Beta bound.</p> <code>1000</code> <code>int</code> <p>Search depth in plies.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The evaluation score returned by the engine.</p> Example <pre><code>from bitbully import BitBully, Board\n\nagent = BitBully()\nboard = Board()\nscore = agent.negamax(board)\nassert score == 1  # Expected score for an empty board\n</code></pre> Source code in <code>src/bitbully/solver.py</code> <pre><code>def negamax(self, board: Board, alpha: int = -1000, beta: int = 1000, depth: int = 0) -&gt; int:\n    \"\"\"Evaluate a position using negamax search.\n\n    Args:\n        board (Board): The board position to evaluate.\n        alpha (int): Alpha bound.\n        beta (int): Beta bound.\n        depth (int): Search depth in plies.\n\n    Returns:\n        int: The evaluation score returned by the engine.\n\n    Example:\n        ```python\n        from bitbully import BitBully, Board\n\n        agent = BitBully()\n        board = Board()\n        score = agent.negamax(board)\n        assert score == 1  # Expected score for an empty board\n        ```\n    \"\"\"\n    return int(\n        self._core.negamax(\n            board.native,\n            alpha=alpha,\n            beta=beta,\n            depth=depth,\n        )\n    )\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.negamax(board)","title":"<code>board</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully.negamax(alpha)","title":"<code>alpha</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully.negamax(beta)","title":"<code>beta</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully.negamax(depth)","title":"<code>depth</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully.null_window","title":"null_window","text":"<pre><code>null_window(board: Board) -&gt; int\n</code></pre> <p>Evaluate a position using a null-window search.</p> <p>Parameters:</p> Name Type Description Default <code>Board</code> <p>The board position to evaluate.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The evaluation score.</p> Example <pre><code>from bitbully import BitBully, Board\n\nagent = BitBully()\nboard = Board()\nscore = agent.null_window(board)\nassert score == 1  # Expected score for an empty board\n</code></pre> Source code in <code>src/bitbully/solver.py</code> <pre><code>def null_window(self, board: Board) -&gt; int:\n    \"\"\"Evaluate a position using a null-window search.\n\n    Args:\n        board (Board): The board position to evaluate.\n\n    Returns:\n        int: The evaluation score.\n\n    Example:\n        ```python\n        from bitbully import BitBully, Board\n\n        agent = BitBully()\n        board = Board()\n        score = agent.null_window(board)\n        assert score == 1  # Expected score for an empty board\n        ```\n    \"\"\"\n    return int(self._core.nullWindow(board.native))\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.null_window(board)","title":"<code>board</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully.reset_book","title":"reset_book","text":"<pre><code>reset_book() -&gt; None\n</code></pre> <p>Unload the currently loaded opening book (if any).</p> <p>This resets the engine to search-only mode until another opening book is loaded.</p> Example <pre><code>from bitbully import BitBully\n\nagent = BitBully()  # per default, the 12-ply-dist book is loaded\nassert agent.is_book_loaded() is True\nagent.reset_book()\nassert agent.is_book_loaded() is False\n</code></pre> Source code in <code>src/bitbully/solver.py</code> <pre><code>def reset_book(self) -&gt; None:\n    \"\"\"Unload the currently loaded opening book (if any).\n\n    This resets the engine to *search-only* mode until another\n    opening book is loaded.\n\n    Example:\n        ```python\n        from bitbully import BitBully\n\n        agent = BitBully()  # per default, the 12-ply-dist book is loaded\n        assert agent.is_book_loaded() is True\n        agent.reset_book()\n        assert agent.is_book_loaded() is False\n        ```\n    \"\"\"\n    self._core.resetBook()\n    self.opening_book_type = None\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.reset_node_counter","title":"reset_node_counter","text":"<pre><code>reset_node_counter() -&gt; None\n</code></pre> <p>Reset the internal node counter.</p> <p>See Also: <code>get_node_counter</code> for usage.</p> Source code in <code>src/bitbully/solver.py</code> <pre><code>def reset_node_counter(self) -&gt; None:\n    \"\"\"Reset the internal node counter.\n\n    See Also: [`get_node_counter`][src.bitbully.solver.BitBully.get_node_counter] for usage.\n    \"\"\"\n    self._core.resetNodeCounter()\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.reset_transposition_table","title":"reset_transposition_table","text":"<pre><code>reset_transposition_table() -&gt; None\n</code></pre> <p>Clear the internal transposition table.</p> Source code in <code>src/bitbully/solver.py</code> <pre><code>def reset_transposition_table(self) -&gt; None:\n    \"\"\"Clear the internal transposition table.\"\"\"\n    self._core.resetTranspositionTable()\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.score_all_moves","title":"score_all_moves","text":"<pre><code>score_all_moves(board: Board) -&gt; dict[int, int]\n</code></pre> <p>Score all legal moves for the given board state.</p> <p>Parameters:</p> Name Type Description Default <code>Board</code> <p>The current board state.</p> required <p>Returns:</p> Type Description <code>dict[int, int]</code> <p>dict[int, int]: A dictionary of up to 7 column-value pairs, one per reachable column (0-6). Higher values generally indicate better moves for the player to move. If a column is full, it will not be listed in the returned dictionary.</p> Example <pre><code>from bitbully import BitBully, Board\n\nagent = BitBully()\nboard = Board()\nscores = agent.score_all_moves(board)\nassert scores == {3: 1, 2: 0, 4: 0, 1: -1, 5: -1, 0: -2, 6: -2}  # Center column is best on an empty board\n</code></pre> Example <p>When a column is full, it is omitted from the results: <pre><code>from bitbully import BitBully, Board\n\nagent = BitBully()\nboard = Board(6 * \"3\")  # fill center column\nscores = agent.score_all_moves(board)\nassert scores == {2: 1, 4: 1, 1: 0, 5: 0, 0: -1, 6: -1}  # Column 3 is full and thus omitted\n</code></pre></p> Source code in <code>src/bitbully/solver.py</code> <pre><code>def score_all_moves(self, board: Board) -&gt; dict[int, int]:\n    \"\"\"Score all legal moves for the given board state.\n\n    Args:\n        board (Board): The current board state.\n\n    Returns:\n        dict[int, int]:\n            A dictionary of up to 7 column-value pairs, one per reachable column (0-6).\n            Higher values generally indicate better moves for the player to move. If a\n            column is full, it will not be listed in the returned dictionary.\n\n    Example:\n        ```python\n        from bitbully import BitBully, Board\n\n        agent = BitBully()\n        board = Board()\n        scores = agent.score_all_moves(board)\n        assert scores == {3: 1, 2: 0, 4: 0, 1: -1, 5: -1, 0: -2, 6: -2}  # Center column is best on an empty board\n        ```\n\n    Example:\n        When a column is full, it is omitted from the results:\n        ```python\n        from bitbully import BitBully, Board\n\n        agent = BitBully()\n        board = Board(6 * \"3\")  # fill center column\n        scores = agent.score_all_moves(board)\n        assert scores == {2: 1, 4: 1, 1: 0, 5: 0, 0: -1, 6: -1}  # Column 3 is full and thus omitted\n        ```\n    \"\"\"\n    scores = self._core.scoreMoves(board.native)\n    column_values = {\n        col: val for (col, val) in enumerate(scores) if val &gt; -100\n    }  # invalid moves have score less than -100\n    return dict(sorted(column_values.items(), key=operator.itemgetter(1), reverse=True))\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.score_all_moves(board)","title":"<code>board</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully.score_move","title":"score_move","text":"<pre><code>score_move(board: Board, column: int, first_guess: int = 0) -&gt; int\n</code></pre> <p>Evaluate a single move for the given board state.</p> <p>Parameters:</p> Name Type Description Default <code>Board</code> <p>The current board state.</p> required <code>int</code> <p>Column index (0-6) of the move to evaluate.</p> required <code>int</code> <p>Initial guess for the score (often 0).</p> <code>0</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The evaluation score of the move.</p> Example <pre><code>from bitbully import BitBully, Board\n\nagent = BitBully()\nboard = Board()\nscore = agent.score_move(board, column=3)\nassert score == 1  # Score for the center column on an empty board\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the column is outside the valid range or if the column is full.</p> Notes <ul> <li>This is a wrapper around   <code>bitbully_core.BitBullyCore.scoreMove</code>.</li> </ul> Source code in <code>src/bitbully/solver.py</code> <pre><code>def score_move(self, board: Board, column: int, first_guess: int = 0) -&gt; int:\n    \"\"\"Evaluate a single move for the given board state.\n\n    Args:\n        board (Board): The current board state.\n        column (int): Column index (0-6) of the move to evaluate.\n        first_guess (int): Initial guess for the score (often 0).\n\n    Returns:\n        int: The evaluation score of the move.\n\n    Example:\n        ```python\n        from bitbully import BitBully, Board\n\n        agent = BitBully()\n        board = Board()\n        score = agent.score_move(board, column=3)\n        assert score == 1  # Score for the center column on an empty board\n        ```\n\n    Raises:\n        ValueError: If the column is outside the valid range or if the column is full.\n\n    Notes:\n        - This is a wrapper around\n          [`bitbully_core.BitBullyCore.scoreMove`][src.bitbully.bitbully_core.BitBullyCore.scoreMove].\n    \"\"\"\n    if not board.is_legal_move(column):\n        raise ValueError(f\"Column {column} is either full or invalid; cannot score move.\")\n\n    return int(self._core.scoreMove(board.native, column, first_guess))\n</code></pre>"},{"location":"solver/#src.bitbully.solver.BitBully.score_move(board)","title":"<code>board</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully.score_move(column)","title":"<code>column</code>","text":""},{"location":"solver/#src.bitbully.solver.BitBully.score_move(first_guess)","title":"<code>first_guess</code>","text":""},{"location":"user_guide/","title":"BitBully User Guide","text":""}]}