{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"BitBully: A fast and perfect-playing Connect-4 Agent for Python 3 &amp; C/C++","text":"<p>BitBully is a high-performance Connect-4 solver built using C++ and Python bindings, leveraging advanced algorithms and optimized bitwise operations. It provides tools for solving and analyzing Connect-4 games efficiently, designed for both developers and researchers.</p>"},{"location":"bitbully/","title":"bitbully","text":"<p>This module provides the Connect Four AI agent \"BitBully\" with opening book support.</p>"},{"location":"bitbully/#src.bitbully.bitbully.BitBully","title":"<code>BitBully</code>","text":"<p>A Connect Four AI agent with opening book support.</p> Source code in <code>src/bitbully/bitbully.py</code> <pre><code>class BitBully:\n    \"\"\"A Connect Four AI agent with opening book support.\"\"\"\n\n    def __init__(self, opening_book: Literal[\"default\", \"8-ply\", \"12-ply\", \"12-ply-dist\"] | None = \"default\") -&gt; None:\n        \"\"\"Initializes the BitBully agent with the specified opening book.\n\n        Args:\n            opening_book (Literal[\"default\", \"8-ply\", \"12-ply\", \"12-ply-dist\"] | None):\n                The type of opening book to use. Options are:\n                - \"default\": Uses the default 12-ply distance-based opening book.\n                - \"8-ply\": Uses an 8-ply opening book.\n                - \"12-ply\": Uses a 12-ply opening book.\n                - \"12-ply-dist\": Uses a 12-ply distance-based opening book.\n                - None: No opening book will be used.\n        \"\"\"\n        from pathlib import Path\n\n        import bitbully_databases as bbd\n\n        self.opening_book_type = opening_book\n\n        if opening_book:\n            db_path = bbd.BitBullyDatabases.get_database_path(opening_book)\n            self.bitbully_agent = bitbully_core.BitBullyCore(Path(db_path))\n        else:\n            self.bitbully_agent = bitbully_core.BitBullyCore()\n\n    def score_next_moves(self, board: Board) -&gt; list[int]:\n        \"\"\"Scores all possible moves for the given board state.\n\n        Args:\n            board (Board):\n                The current board state.\n\n        Returns:\n            list[int]: A list of scores for each column (0-6).\n        \"\"\"\n        return self.bitbully_agent.scoreMoves(board._board)\n</code></pre>"},{"location":"bitbully/#src.bitbully.bitbully.BitBully.__init__","title":"<code>__init__(opening_book='default')</code>","text":"<p>Initializes the BitBully agent with the specified opening book.</p> <p>Parameters:</p> Name Type Description Default <code>opening_book</code> <code>Literal['default', '8-ply', '12-ply', '12-ply-dist'] | None</code> <p>The type of opening book to use. Options are: - \"default\": Uses the default 12-ply distance-based opening book. - \"8-ply\": Uses an 8-ply opening book. - \"12-ply\": Uses a 12-ply opening book. - \"12-ply-dist\": Uses a 12-ply distance-based opening book. - None: No opening book will be used.</p> <code>'default'</code> Source code in <code>src/bitbully/bitbully.py</code> <pre><code>def __init__(self, opening_book: Literal[\"default\", \"8-ply\", \"12-ply\", \"12-ply-dist\"] | None = \"default\") -&gt; None:\n    \"\"\"Initializes the BitBully agent with the specified opening book.\n\n    Args:\n        opening_book (Literal[\"default\", \"8-ply\", \"12-ply\", \"12-ply-dist\"] | None):\n            The type of opening book to use. Options are:\n            - \"default\": Uses the default 12-ply distance-based opening book.\n            - \"8-ply\": Uses an 8-ply opening book.\n            - \"12-ply\": Uses a 12-ply opening book.\n            - \"12-ply-dist\": Uses a 12-ply distance-based opening book.\n            - None: No opening book will be used.\n    \"\"\"\n    from pathlib import Path\n\n    import bitbully_databases as bbd\n\n    self.opening_book_type = opening_book\n\n    if opening_book:\n        db_path = bbd.BitBullyDatabases.get_database_path(opening_book)\n        self.bitbully_agent = bitbully_core.BitBullyCore(Path(db_path))\n    else:\n        self.bitbully_agent = bitbully_core.BitBullyCore()\n</code></pre>"},{"location":"bitbully/#src.bitbully.bitbully.BitBully.score_next_moves","title":"<code>score_next_moves(board)</code>","text":"<p>Scores all possible moves for the given board state.</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Board</code> <p>The current board state.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: A list of scores for each column (0-6).</p> Source code in <code>src/bitbully/bitbully.py</code> <pre><code>def score_next_moves(self, board: Board) -&gt; list[int]:\n    \"\"\"Scores all possible moves for the given board state.\n\n    Args:\n        board (Board):\n            The current board state.\n\n    Returns:\n        list[int]: A list of scores for each column (0-6).\n    \"\"\"\n    return self.bitbully_agent.scoreMoves(board._board)\n</code></pre>"},{"location":"bitbully_core/","title":"bitbully_core","text":"<p>Bitbully is a fast Connect-4 solver.</p>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore","title":"<code>BitBullyCore</code>","text":"Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>class BitBullyCore:\n    @typing.overload\n    def __init__(self) -&gt; None: ...\n\n    @typing.overload\n    def __init__(self, openingBookPath: os.PathLike) -&gt; None: ...\n\n    def getNodeCounter(self) -&gt; int:\n        \"\"\"Get the current node counter\"\"\"\n\n    @typing.overload\n    def isBookLoaded(self) -&gt; bool:\n        \"\"\"Check, if opening book is loaded\"\"\"\n\n    @typing.overload\n    def isBookLoaded(self) -&gt; bool:\n        \"\"\"Check, if opening book is loaded\"\"\"\n\n    def mtdf(self, board: ..., first_guess: int) -&gt; int:\n        \"\"\"MTD(f) algorithm\"\"\"\n\n    def negamax(self, board: ..., alpha: int, beta: int, depth: int) -&gt; int:\n        \"\"\"Negamax search\"\"\"\n\n    def nullWindow(self, board: ...) -&gt; int:\n        \"\"\"Null-window search\"\"\"\n\n    def resetNodeCounter(self) -&gt; None:\n        \"\"\"Reset the node counter\"\"\"\n\n    def resetTranspositionTable(self) -&gt; None:\n        \"\"\"Reset the transposition table\"\"\"\n\n    def scoreMoves(self, board: ...) -&gt; list[int]:\n        \"\"\"Evaluate all moves\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.getNodeCounter","title":"<code>getNodeCounter()</code>","text":"<p>Get the current node counter</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def getNodeCounter(self) -&gt; int:\n    \"\"\"Get the current node counter\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.mtdf","title":"<code>mtdf(board, first_guess)</code>","text":"<p>MTD(f) algorithm</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def mtdf(self, board: ..., first_guess: int) -&gt; int:\n    \"\"\"MTD(f) algorithm\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.negamax","title":"<code>negamax(board, alpha, beta, depth)</code>","text":"<p>Negamax search</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def negamax(self, board: ..., alpha: int, beta: int, depth: int) -&gt; int:\n    \"\"\"Negamax search\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.nullWindow","title":"<code>nullWindow(board)</code>","text":"<p>Null-window search</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def nullWindow(self, board: ...) -&gt; int:\n    \"\"\"Null-window search\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.resetNodeCounter","title":"<code>resetNodeCounter()</code>","text":"<p>Reset the node counter</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def resetNodeCounter(self) -&gt; None:\n    \"\"\"Reset the node counter\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.resetTranspositionTable","title":"<code>resetTranspositionTable()</code>","text":"<p>Reset the transposition table</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def resetTranspositionTable(self) -&gt; None:\n    \"\"\"Reset the transposition table\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BitBullyCore.scoreMoves","title":"<code>scoreMoves(board)</code>","text":"<p>Evaluate all moves</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def scoreMoves(self, board: ...) -&gt; list[int]:\n    \"\"\"Evaluate all moves\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore","title":"<code>BoardCore</code>","text":"Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>class BoardCore:\n    __hash__: typing.ClassVar[None] = None\n\n    @staticmethod\n    def isValid(\n            board: typing.Annotated[\n                list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(6)]],\n                pybind11_stubgen.typing_ext.FixedSize(7),\n            ],\n    ) -&gt; bool:\n        \"\"\"Check, if a board is a valid one.\"\"\"\n\n    @staticmethod\n    def randomBoard(nPly: int, forbidDirectWin: bool) -&gt; tuple[BoardCore, list[int]]:\n        \"\"\"Create a random board with n tokens.\"\"\"\n\n    def __eq__(self, arg0: BoardCore) -&gt; bool:\n        \"\"\"Check if two boards are equal\"\"\"\n\n    @typing.overload\n    def __init__(self) -&gt; None: ...\n\n    @typing.overload\n    def __init__(self, arg0: BoardCore) -&gt; None: ...\n\n    def __ne__(self, arg0: BoardCore) -&gt; bool:\n        \"\"\"Check if two boards are not equal\"\"\"\n\n    def allPositions(self, upToNPly: int, exactlyN: bool) -&gt; list[BoardCore]:\n        \"\"\"Generate all positions that can be reached from the current board with n tokens.\"\"\"\n\n    @typing.overload\n    def canWin(self, column: int) -&gt; bool:\n        \"\"\"Check, if current player can win by moving into column.\"\"\"\n\n    @typing.overload\n    def canWin(self) -&gt; bool:\n        \"\"\"Check, if current player can win with the next move.\"\"\"\n\n    def copy(self) -&gt; BoardCore:\n        \"\"\"Create a deep copy of the board.\"\"\"\n\n    def countTokens(self) -&gt; int:\n        \"\"\"Get the number of Tokens on the board\"\"\"\n\n    def doubleThreat(self, moves: int) -&gt; int:\n        \"\"\"Find double threats\"\"\"\n\n    def findThreats(self, moves: int) -&gt; int:\n        \"\"\"Find threats on the board\"\"\"\n\n    def legalMovesMask(self) -&gt; int:\n        \"\"\"Generate possible moves as bitboard\"\"\"\n\n    def generateNonLosingMoves(self) -&gt; int:\n        \"\"\"Generate non-losing moves\"\"\"\n\n    def legalMoves(self) -&gt; list[int]:\n        \"\"\"Generate possible moves as a vector of column indices\"\"\"\n\n    def hasWin(self) -&gt; bool:\n        \"\"\"Check, if the player who performed the last move has a winning position (4 in a row).\"\"\"\n\n    def hash(self) -&gt; int:\n        \"\"\"Hash the current position and return hash value.\"\"\"\n\n    def isLegalMove(self, column: int) -&gt; bool:\n        \"\"\"Check if a move is legal\"\"\"\n\n    def mirror(self) -&gt; BoardCore:\n        \"\"\"Get the mirrored board (mirror around center column)\"\"\"\n\n    def movesLeft(self) -&gt; int:\n        \"\"\"Get the number of moves left\"\"\"\n\n    @typing.overload\n    def play(self, column: int) -&gt; bool:\n        \"\"\"Play a move by column index\"\"\"\n\n    @typing.overload\n    def play(self, moveSequence: list[int]) -&gt; bool:\n        \"\"\"\n        Play a sequence of moves by column index\n        \"\"\"\n\n    @typing.overload\n    def play(self, moveSequence: str) -&gt; bool:\n        \"\"\"\n        Play a sequence of moves by column index\n        \"\"\"\n\n    def playMoveOnCopy(self, mv: int) -&gt; BoardCore:\n        \"\"\"Play a move on a copy of the board and return the new board\"\"\"\n\n    @typing.overload\n    def setBoard(self, moveSequence: list[int]) -&gt; bool:\n        \"\"\"Set the board using a 2D array\"\"\"\n\n    @typing.overload\n    def setBoard(\n            self,\n            moveSequence: typing.Annotated[\n                list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(6)]],\n                pybind11_stubgen.typing_ext.FixedSize(7),\n            ],\n    ) -&gt; bool:\n        \"\"\"Set the board using a 2D array\"\"\"\n\n    @typing.overload\n    def setBoard(\n            self,\n            moveSequence: typing.Annotated[\n                list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(7)]],\n                pybind11_stubgen.typing_ext.FixedSize(6),\n            ],\n    ) -&gt; bool:\n        \"\"\"Set the board using a 2D array\"\"\"\n\n    @typing.overload\n    def setBoard(self, moveSequence: str) -&gt; bool:\n        \"\"\"Set the board using a sequence as string\"\"\"\n\n    def sortMoves(self, moves: int) -&gt; ...:\n        \"\"\"Sort moves based on priority\"\"\"\n\n    def toArray(\n            self,\n    ) -&gt; typing.Annotated[\n        list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(6)]],\n        pybind11_stubgen.typing_ext.FixedSize(7),\n    ]:\n        \"\"\"Convert the board to a 2D array representation\"\"\"\n\n    def toHuffman(self) -&gt; int:\n        \"\"\"Encode position into a huffman-code compressed sequence.\"\"\"\n\n    def toString(self) -&gt; str:\n        \"\"\"Return a string representation of the board\"\"\"\n\n    def uid(self) -&gt; int:\n        \"\"\"Get the unique identifier for the board\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.__eq__","title":"<code>__eq__(arg0)</code>","text":"<p>Check if two boards are equal</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def __eq__(self, arg0: BoardCore) -&gt; bool:\n    \"\"\"Check if two boards are equal\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.__ne__","title":"<code>__ne__(arg0)</code>","text":"<p>Check if two boards are not equal</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def __ne__(self, arg0: BoardCore) -&gt; bool:\n    \"\"\"Check if two boards are not equal\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.allPositions","title":"<code>allPositions(upToNPly, exactlyN)</code>","text":"<p>Generate all positions that can be reached from the current board with n tokens.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def allPositions(self, upToNPly: int, exactlyN: bool) -&gt; list[BoardCore]:\n    \"\"\"Generate all positions that can be reached from the current board with n tokens.\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.copy","title":"<code>copy()</code>","text":"<p>Create a deep copy of the board.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def copy(self) -&gt; BoardCore:\n    \"\"\"Create a deep copy of the board.\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.countTokens","title":"<code>countTokens()</code>","text":"<p>Get the number of Tokens on the board</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def countTokens(self) -&gt; int:\n    \"\"\"Get the number of Tokens on the board\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.doubleThreat","title":"<code>doubleThreat(moves)</code>","text":"<p>Find double threats</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def doubleThreat(self, moves: int) -&gt; int:\n    \"\"\"Find double threats\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.findThreats","title":"<code>findThreats(moves)</code>","text":"<p>Find threats on the board</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def findThreats(self, moves: int) -&gt; int:\n    \"\"\"Find threats on the board\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.generateNonLosingMoves","title":"<code>generateNonLosingMoves()</code>","text":"<p>Generate non-losing moves</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def generateNonLosingMoves(self) -&gt; int:\n    \"\"\"Generate non-losing moves\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.hasWin","title":"<code>hasWin()</code>","text":"<p>Check, if the player who performed the last move has a winning position (4 in a row).</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def hasWin(self) -&gt; bool:\n    \"\"\"Check, if the player who performed the last move has a winning position (4 in a row).\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.hash","title":"<code>hash()</code>","text":"<p>Hash the current position and return hash value.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def hash(self) -&gt; int:\n    \"\"\"Hash the current position and return hash value.\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.isLegalMove","title":"<code>isLegalMove(column)</code>","text":"<p>Check if a move is legal</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def isLegalMove(self, column: int) -&gt; bool:\n    \"\"\"Check if a move is legal\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.isValid","title":"<code>isValid(board)</code>  <code>staticmethod</code>","text":"<p>Check, if a board is a valid one.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>@staticmethod\ndef isValid(\n        board: typing.Annotated[\n            list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(6)]],\n            pybind11_stubgen.typing_ext.FixedSize(7),\n        ],\n) -&gt; bool:\n    \"\"\"Check, if a board is a valid one.\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.legalMoves","title":"<code>legalMoves()</code>","text":"<p>Generate possible moves as a vector of column indices</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def legalMoves(self) -&gt; list[int]:\n    \"\"\"Generate possible moves as a vector of column indices\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.legalMovesMask","title":"<code>legalMovesMask()</code>","text":"<p>Generate possible moves as bitboard</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def legalMovesMask(self) -&gt; int:\n    \"\"\"Generate possible moves as bitboard\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.mirror","title":"<code>mirror()</code>","text":"<p>Get the mirrored board (mirror around center column)</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def mirror(self) -&gt; BoardCore:\n    \"\"\"Get the mirrored board (mirror around center column)\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.movesLeft","title":"<code>movesLeft()</code>","text":"<p>Get the number of moves left</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def movesLeft(self) -&gt; int:\n    \"\"\"Get the number of moves left\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.playMoveOnCopy","title":"<code>playMoveOnCopy(mv)</code>","text":"<p>Play a move on a copy of the board and return the new board</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def playMoveOnCopy(self, mv: int) -&gt; BoardCore:\n    \"\"\"Play a move on a copy of the board and return the new board\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.randomBoard","title":"<code>randomBoard(nPly, forbidDirectWin)</code>  <code>staticmethod</code>","text":"<p>Create a random board with n tokens.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>@staticmethod\ndef randomBoard(nPly: int, forbidDirectWin: bool) -&gt; tuple[BoardCore, list[int]]:\n    \"\"\"Create a random board with n tokens.\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.sortMoves","title":"<code>sortMoves(moves)</code>","text":"<p>Sort moves based on priority</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def sortMoves(self, moves: int) -&gt; ...:\n    \"\"\"Sort moves based on priority\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.toArray","title":"<code>toArray()</code>","text":"<p>Convert the board to a 2D array representation</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def toArray(\n        self,\n) -&gt; typing.Annotated[\n    list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(6)]],\n    pybind11_stubgen.typing_ext.FixedSize(7),\n]:\n    \"\"\"Convert the board to a 2D array representation\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.toHuffman","title":"<code>toHuffman()</code>","text":"<p>Encode position into a huffman-code compressed sequence.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def toHuffman(self) -&gt; int:\n    \"\"\"Encode position into a huffman-code compressed sequence.\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.toString","title":"<code>toString()</code>","text":"<p>Return a string representation of the board</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def toString(self) -&gt; str:\n    \"\"\"Return a string representation of the board\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.BoardCore.uid","title":"<code>uid()</code>","text":"<p>Get the unique identifier for the board</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def uid(self) -&gt; int:\n    \"\"\"Get the unique identifier for the board\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore","title":"<code>OpeningBookCore</code>","text":"Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>class OpeningBookCore:\n    @staticmethod\n    def readBook(filename: os.PathLike, with_distances: bool = True, is_8ply: bool = False) -&gt; list[tuple[int, int]]:\n        \"\"\"Read a book from a file.\"\"\"\n\n    @typing.overload\n    def __init__(self, bookPath: os.PathLike, is_8ply: bool, with_distances: bool) -&gt; None:\n        \"\"\"Initialize an OpeningBook with explicit settings.\"\"\"\n\n    @typing.overload\n    def __init__(self, bookPath: os.PathLike) -&gt; None:\n        \"\"\"Initialize an OpeningBook by inferring database type from file size.\"\"\"\n\n    def convertValue(self, value: int, board: BoardCore) -&gt; int:\n        \"\"\"Convert a value to the internal scoring system.\"\"\"\n\n    def getBoardValue(self, board: BoardCore) -&gt; int:\n        \"\"\"Get the value of a given board.\"\"\"\n\n    def getBook(self) -&gt; list[tuple[int, int]]:\n        \"\"\"Return the raw book table.\"\"\"\n\n    def getBookSize(self) -&gt; int:\n        \"\"\"Get the size of the book.\"\"\"\n\n    def getEntry(self, entryIdx: int) -&gt; tuple[int, int]:\n        \"\"\"Get an entry from the book by index.\"\"\"\n\n    def getNPly(self) -&gt; int:\n        \"\"\"Get the ply depth of the book.\"\"\"\n\n    def init(self, bookPath: os.PathLike, is_8ply: bool, with_distances: bool) -&gt; None:\n        \"\"\"Reinitialize the OpeningBook with new settings.\"\"\"\n\n    def isInBook(self, board: BoardCore) -&gt; bool:\n        \"\"\"Check, if the given board is in the opening book. Note, that usually boards are only present in one mirrored variant.\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.convertValue","title":"<code>convertValue(value, board)</code>","text":"<p>Convert a value to the internal scoring system.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def convertValue(self, value: int, board: BoardCore) -&gt; int:\n    \"\"\"Convert a value to the internal scoring system.\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.getBoardValue","title":"<code>getBoardValue(board)</code>","text":"<p>Get the value of a given board.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def getBoardValue(self, board: BoardCore) -&gt; int:\n    \"\"\"Get the value of a given board.\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.getBook","title":"<code>getBook()</code>","text":"<p>Return the raw book table.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def getBook(self) -&gt; list[tuple[int, int]]:\n    \"\"\"Return the raw book table.\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.getBookSize","title":"<code>getBookSize()</code>","text":"<p>Get the size of the book.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def getBookSize(self) -&gt; int:\n    \"\"\"Get the size of the book.\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.getEntry","title":"<code>getEntry(entryIdx)</code>","text":"<p>Get an entry from the book by index.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def getEntry(self, entryIdx: int) -&gt; tuple[int, int]:\n    \"\"\"Get an entry from the book by index.\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.getNPly","title":"<code>getNPly()</code>","text":"<p>Get the ply depth of the book.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def getNPly(self) -&gt; int:\n    \"\"\"Get the ply depth of the book.\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.init","title":"<code>init(bookPath, is_8ply, with_distances)</code>","text":"<p>Reinitialize the OpeningBook with new settings.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def init(self, bookPath: os.PathLike, is_8ply: bool, with_distances: bool) -&gt; None:\n    \"\"\"Reinitialize the OpeningBook with new settings.\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.isInBook","title":"<code>isInBook(board)</code>","text":"<p>Check, if the given board is in the opening book. Note, that usually boards are only present in one mirrored variant.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>def isInBook(self, board: BoardCore) -&gt; bool:\n    \"\"\"Check, if the given board is in the opening book. Note, that usually boards are only present in one mirrored variant.\"\"\"\n</code></pre>"},{"location":"bitbully_core/#src.bitbully.bitbully_core.OpeningBookCore.readBook","title":"<code>readBook(filename, with_distances=True, is_8ply=False)</code>  <code>staticmethod</code>","text":"<p>Read a book from a file.</p> Source code in <code>src/bitbully/bitbully_core.pyi</code> <pre><code>@staticmethod\ndef readBook(filename: os.PathLike, with_distances: bool = True, is_8ply: bool = False) -&gt; list[tuple[int, int]]:\n    \"\"\"Read a book from a file.\"\"\"\n</code></pre>"},{"location":"board/","title":"board","text":"<p>This module defines the Board class for managing the state of a Connect Four game.</p>"},{"location":"board/#src.bitbully.board.Board","title":"<code>Board</code>","text":"<p>Represents the state of a Connect Four board. Mostly a thin wrapper around BoardCore.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>class Board:\n    \"\"\"Represents the state of a Connect Four board. Mostly a thin wrapper around BoardCore.\"\"\"\n\n    def __init__(self, init_with: Sequence[Sequence[int]] | Sequence[int] | str | None = None) -&gt; None:\n        \"\"\"Initializes a Board instance.\n\n        Args:\n            init_with (Sequence[Sequence[int]] | Sequence[int] | str | None):\n                Optional initial board state. Accepts:\n                - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7\n                - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3])\n                - String: A move sequence of columns as string (e.g., \"002233\")\n                - None for an empty board\n\n        Raises:\n            ValueError: If the provided initial board state is invalid.\n\n        Example:\n            You can initialize an empty board in multiple ways:\n            ```python\n            import bitbully as bb\n\n            # Create an empty board using the default constructor.\n            board = bb.Board()  # Starts with no tokens placed.\n\n            # Alternatively, initialize the board explicitly from a 2D list.\n            # Each inner list represents a column (7 columns total, 6 rows each).\n            # A value of 0 indicates an empty cell; 1 and 2 would represent player tokens.\n            board = bb.Board([[0] * 6 for _ in range(7)])  # Equivalent to an empty board.\n\n            # You can also set up a specific board position manually using a 6 x 7 layout,\n            # where each inner list represents a row instead of a column.\n            # (Both layouts are accepted by BitBully for convenience.)\n            # For more complex examples using 2D arrays, see the examples below.\n            board = bb.Board([[0] * 7 for _ in range(6)])  # Also equivalent to an empty board.\n\n            # Display the board in text form.\n            # The __repr__ method shows the current state (useful for debugging or interactive use).\n            board\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            ```\n\n        The recommended way to initialize an empty board is simply `Board()`.\n\n        Example:\n            You can also initialize a board with a sequence of moves:\n            ```python\n            import bitbully as bb\n\n            # Initialize a board with a sequence of moves played in the center column.\n\n            # The list [3, 3, 3] represents three moves in column index 3 (zero-based).\n            # Moves alternate automatically between Player 1 (yellow, X) and Player 2 (red, O).\n            # After these three moves, the center column will contain:\n            #   - Row 0: Player 1 token (bottom)\n            #   - Row 1: Player 2 token\n            #   - Row 2: Player 1 token\n            board = bb.Board([3, 3, 3])\n\n            # Display the resulting board.\n            # The textual output shows the tokens placed in the center column.\n            board\n            ```\n\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  _  _  X  _  _  _\n            ```\n\n        Example:\n            You can also initialize a board using a string containing a move sequence:\n            ```python\n            import bitbully as bb\n\n            # Initialize a board using a compact move string.\n\n            # The string \"33333111\" represents a sequence of eight moves:\n            #   3 3 3 3 3 \u2192 five moves in the center column (index 3)\n            #   1 1 1 \u2192 three moves in the second column (index 1)\n            #\n            # Moves are applied in order, alternating automatically between Player 1 (yellow, X)\n            # and Player 2 (red, O), just as if you had called `board.play()` repeatedly.\n            #\n            # This shorthand is convenient for reproducing board states or test positions\n            # without having to provide long move lists.\n\n            board = bb.Board(\"33333111\")\n\n            # Display the resulting board.\n            # The printed layout shows how the tokens stack in each column.\n            board\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  O  _  X  _  _  _\n            _  X  _  O  _  _  _\n            _  O  _  X  _  _  _\n            ```\n\n        Example:\n            You can also initialize a board using a 2D array (list of lists):\n            ```python\n            import bitbully as bb\n\n            # Use a 6 x 7 list (rows x columns) to set up a specific board position manually.\n\n            # Each inner list represents a row of the Connect-4 grid.\n            # Convention:\n            #   - 0 \u2192 empty cell\n            #   - 1 \u2192 Player 1 token (yellow, X)\n            #   - 2 \u2192 Player 2 token (red, O)\n            #\n            # The top list corresponds to the *top row* (row index 5),\n            # and the bottom list corresponds to the *bottom row* (row index 0).\n            # This layout matches the typical visual display of the board.\n\n            board_array = [\n                [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n                [0, 0, 0, 1, 0, 0, 0],  # Row 4: Player 1 token in column 3\n                [0, 0, 0, 2, 0, 0, 0],  # Row 3: Player 2 token in column 3\n                [0, 2, 0, 1, 0, 0, 0],  # Row 2: tokens in columns 1 and 3\n                [0, 1, 0, 2, 0, 0, 0],  # Row 1: tokens in columns 1 and 3\n                [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom): tokens stacked lowest\n            ]\n\n            # Create a Board instance directly from the 2D list.\n            # This allows reconstructing arbitrary positions (e.g., from test data or saved states)\n            # without replaying the move sequence.\n            board = bb.Board(board_array)\n\n            # Display the resulting board state in text form.\n            board\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  O  _  X  _  _  _\n            _  X  _  O  _  _  _\n            _  O  _  X  _  _  _\n            ```\n\n        Example:\n            You can also initialize a board using a 2D (7 x 6) array with columns as inner lists:\n            ```python\n            import bitbully as bb\n\n            # Use a 7 x 6 list (columns x rows) to set up a specific board position manually.\n\n            # Each inner list represents a **column** of the Connect-4 board, from left (index 0)\n            # to right (index 6). Each column contains six entries \u2014 one for each row, from\n            # bottom (index 0) to top (index 5).\n            #\n            # Convention:\n            #   - 0 \u2192 empty cell\n            #   - 1 \u2192 Player 1 token (yellow, X)\n            #   - 2 \u2192 Player 2 token (red, O)\n            #\n            # This column-major layout matches the internal representation used by BitBully,\n            # where tokens are dropped into columns rather than filled row by row.\n\n            board_array = [\n                [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)\n                [2, 1, 2, 0, 0, 0],  # Column 1\n                [0, 0, 0, 0, 0, 0],  # Column 2\n                [1, 2, 1, 2, 1, 0],  # Column 3 (center)\n                [0, 0, 0, 0, 0, 0],  # Column 4\n                [0, 0, 0, 0, 0, 0],  # Column 5\n                [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)\n            ]\n\n            # Create a Board instance directly from the 2D list.\n            # This allows reconstructing any arbitrary position (e.g., test cases, saved games)\n            # without replaying all moves individually.\n            board = bb.Board(board_array)\n\n            # Display the resulting board.\n            # The text output shows tokens as they would appear in a real Connect-4 grid.\n            board\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  O  _  X  _  _  _\n            _  X  _  O  _  _  _\n            _  O  _  X  _  _  _\n            ```\n        \"\"\"\n        self._board = bitbully_core.BoardCore()\n        if init_with is not None and not self.reset_board(init_with):\n            raise ValueError(\n                \"Invalid initial board state provided. Check the examples in the docstring for valid formats.\"\n            )\n\n    def __eq__(self, value: object) -&gt; bool:\n        \"\"\"Checks equality between two Board instances.\n\n        Notes:\n            - Equality checks in BitBully compare the *exact board state* (bit patterns),\n              not just the move history.\n            - Two different move sequences can still yield the same position if they\n              result in identical token configurations.\n            - This is useful for comparing solver states, verifying test positions,\n              or detecting transpositions in search algorithms.\n\n        Args:\n            value (object): The other Board instance to compare against.\n\n        Returns:\n            bool: True if both boards are equal, False otherwise.\n\n        Raises:\n            NotImplementedError: If the other value is not a Board instance.\n\n        Example:\n            ```python\n            import bitbully as bb\n\n            # Create two boards that should represent *identical* game states.\n            board1 = bb.Board()\n            assert board1.play(\"33333111\")\n\n            board2 = bb.Board()\n            # Play the same position step by step using a different but equivalent sequence.\n            # Internally, the final bitboard state will match `board1`.\n            assert board2.play(\"31133331\")\n\n            # Boards with identical token placements are considered equal.\n            # Equality (`==`) and inequality (`!=`) operators are overloaded for convenience.\n            assert board1 == board2\n            assert not (board1 != board2)\n\n            # ------------------------------------------------------------------------------\n\n            # Create two boards that differ by one move.\n            board1 = bb.Board(\"33333111\")\n            board2 = bb.Board(\"33333112\")  # One extra move in the last column (index 2)\n\n            # Since the token layout differs, equality no longer holds.\n            assert board1 != board2\n            assert not (board1 == board2)\n            ```\n        \"\"\"\n        if not isinstance(value, Board):\n            raise NotImplementedError(\"Can only compare with another Board instance.\")\n        return bool(self._board == value._board)\n\n    def __ne__(self, value: object) -&gt; bool:\n        \"\"\"Checks inequality between two Board instances.\n\n        See the documentation for [`bitbully.Board.__eq__`][src.bitbully.Board.__eq__] for details.\n\n        Args:\n            value (object): The other Board instance to compare against.\n\n        Returns:\n            bool: True if both boards are not equal, False otherwise.\n        \"\"\"\n        return not self.__eq__(value)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Returns a string representation of the Board instance.\"\"\"\n        return f\"{self._board}\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a human-readable ASCII representation (same as to_string()).\n\n        See the documentation for [`bitbully.Board.to_string`][src.bitbully.Board.to_string] for details.\n        \"\"\"\n        return self.to_string()\n\n    def all_positions(self, up_to_n_ply: int, exactly_n: bool) -&gt; list[Board]:\n        \"\"\"Find all positions reachable from the current position up to a given ply.\n\n        This is a high-level wrapper around\n        `bitbully_core.BoardCore.allPositions`.\n\n        Starting from the **current** board, it generates all positions that can be\n        reached by playing additional moves such that the resulting position has:\n\n        - At most ``up_to_n_ply`` tokens on the board, if ``exactly_n`` is ``False``.\n        - Exactly ``up_to_n_ply`` tokens on the board, if ``exactly_n`` is ``True``.\n\n        Note:\n            The number of tokens already present in the current position is taken\n            into account. If ``up_to_n_ply`` is smaller than\n            ``self.count_tokens()``, the result is typically empty.\n\n            This function can grow combinatorially with ``up_to_n_ply`` and the\n            current position, so use it with care for large depths.\n\n        Args:\n            up_to_n_ply (int):\n                The maximum total number of tokens (ply) for generated positions.\n                Must be between 0 and 42 (inclusive).\n            exactly_n (bool):\n                If ``True``, only positions with exactly ``up_to_n_ply`` tokens\n                are returned. If ``False``, all positions with a token count\n                between the current number of tokens and ``up_to_n_ply`` are\n                included.\n\n        Returns:\n            list[Board]: A list of :class:`Board` instances representing all\n            reachable positions that satisfy the ply constraint.\n\n        Raises:\n            ValueError: If ``up_to_n_ply`` is outside the range ``[0, 42]``.\n\n        Example:\n            Compute all positions at exactly 3 ply from the empty board:\n\n            ```python\n            import bitbully as bb\n\n            # Start from an empty board.\n            board = bb.Board()\n\n            # Generate all positions that contain exactly 3 tokens.\n            positions = board.all_positions(3, exactly_n=True)\n\n            # According to OEIS A212693, there are exactly 238 distinct\n            # reachable positions with 3 played moves in standard Connect-4.\n            assert len(positions) == 238\n            ```\n\n            Reference:\n                - Number of distinct positions at ply *n*:\n                  https://oeis.org/A212693\n\n        \"\"\"\n        if not 0 &lt;= up_to_n_ply &lt;= 42:\n            raise ValueError(f\"up_to_n_ply must be between 0 and 42 (inclusive), got {up_to_n_ply}.\")\n\n        # Delegate to the C++ core, which returns a list of BoardCore objects.\n        core_positions = self._board.allPositions(up_to_n_ply, exactly_n)\n\n        # Wrap each BoardCore in a high-level Board instance.\n        positions: list[Board] = []\n        for core_board in core_positions:\n            b = Board()  # start with an empty high-level Board\n            b._board = core_board  # replace its internal BoardCore\n            positions.append(b)\n\n        return positions\n\n    def can_win_next(self, move: int | None = None) -&gt; bool:\n        \"\"\"Checks if the current player can win in the next move.\n\n        Args:\n            move (int | None): Optional column to check for an immediate win. If None, checks all columns.\n\n        Returns:\n            bool: True if the current player can win next, False otherwise.\n\n        See also: [`bitbully.Board.has_win`][src.bitbully.Board.has_win].\n\n        Example:\n            ```python\n            import bitbully as bb\n\n            # Create a board from a move string.\n            # The string \"332311\" represents a short sequence of alternating moves\n            # that results in a nearly winning position for Player 1 (yellow, X).\n            board = bb.Board(\"332311\")\n\n            # Display the current board state (see below)\n            print(board)\n\n            # Player 1 (yellow, X) \u2014 who is next to move \u2014 can win immediately\n            # by placing a token in either column 0 or column 4.\n            assert board.can_win_next(0)\n            assert board.can_win_next(4)\n\n            # However, playing in other columns does not result in an instant win.\n            assert not board.can_win_next(2)\n            assert not board.can_win_next(3)\n\n            # You can also call `can_win_next()` without arguments to perform a general check.\n            # It returns True if the current player has *any* winning move available.\n            assert board.can_win_next()\n            ```\n            The board we created above looks like this:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  O  _  _  _\n            _  O  _  O  _  _  _\n            _  X  X  X  _  _  _\n            ```\n        \"\"\"\n        if move is None:\n            return self._board.canWin()\n        return bool(self._board.canWin(move))\n\n    def copy(self) -&gt; Board:\n        \"\"\"Creates a copy of the current Board instance.\n\n        The `copy()` method returns a new `Board` object that represents the\n        *same position* as the original at the time of copying. Subsequent\n        changes to one board do **not** affect the other \u2014 they are completely\n        independent.\n\n        Returns:\n            Board: A new Board instance that is a copy of the current one.\n\n        Example:\n            Create a board, copy it, and verify that both represent the same position:\n            ```python\n            import bitbully as bb\n\n            # Create a board from a compact move string.\n            board = bb.Board(\"33333111\")\n\n            # Create an independent copy of the current position.\n            board_copy = board.copy()\n\n            # Both boards represent the same position and are considered equal.\n            assert board == board_copy\n            assert hash(board) == hash(board_copy)\n            assert board.to_string() == board_copy.to_string()\n\n            # Display the board state.\n            print(board)\n            ```\n            Expected output (both boards print the same position):\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  O  _  X  _  _  _\n            _  X  _  O  _  _  _\n            _  O  _  X  _  _  _\n            ```\n\n        Example:\n            Modifying the copy does not affect the original:\n            ```python\n            import bitbully as bb\n\n            board = bb.Board(\"33333111\")\n\n            # Create a copy of the current position.\n            board_copy = board.copy()\n\n            # Play an additional move on the copied board only.\n            assert board_copy.play(0)  # Drop a token into the leftmost column.\n\n            # Now the boards represent different positions.\n            assert board != board_copy\n\n            # The original board remains unchanged.\n            print(\"Original:\")\n            print(board)\n\n            print(\"Modified copy:\")\n            print(board_copy)\n            ```\n            Expected output:\n            ```text\n            Original:\n\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  O  _  X  _  _  _\n            _  X  _  O  _  _  _\n            _  O  _  X  _  _  _\n\n            Modified copy:\n\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  O  _  X  _  _  _\n            _  X  _  O  _  _  _\n            X  O  _  X  _  _  _\n            ```\n        \"\"\"\n        new_board = Board()\n        new_board._board = self._board.copy()\n        return new_board\n\n    def count_tokens(self) -&gt; int:\n        \"\"\"Counts the total number of tokens currently placed on the board.\n\n        This method simply returns how many moves have been played so far in the\n        current position \u2014 that is, the number of occupied cells on the 7x6 grid.\n\n        It does **not** distinguish between players; it only reports the total\n        number of tokens, regardless of whether they belong to Player 1 or Player 2.\n\n        Returns:\n            int: The total number of tokens on the board (between 0 and 42).\n\n        Example:\n            Count tokens on an empty board:\n            ```python\n            import bitbully as bb\n\n            board = bb.Board()  # No moves played yet.\n            assert board.count_tokens() == 0\n\n            # The board is completely empty.\n            print(board)\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            ```\n\n        Example:\n            Count tokens after a few moves:\n            ```python\n            import bitbully as bb\n\n            # Play three moves in the center column (index 3).\n            board = bb.Board()\n            assert board.play([3, 3, 3])\n\n            # Three tokens have been placed on the board.\n            assert board.count_tokens() == 3\n\n            print(board)\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  _  _  X  _  _  _\n            ```\n\n        Example:\n            Relation to the length of a move sequence:\n            ```python\n            import bitbully as bb\n\n            moves = \"33333111\"  # 8 moves in total\n            board = bb.Board(moves)\n\n            # The number of tokens on the board always matches\n            # the number of moves that have been played.\n            # (as long as the input was valid)\n            assert board.count_tokens() == len(moves)\n            ```\n        \"\"\"\n        return self._board.countTokens()\n\n    def legal_moves(self, non_losing: bool = False) -&gt; list[int]:\n        \"\"\"Returns a list of legal moves (columns) that can be played.\n\n        Args:\n            non_losing (bool): If True, only return moves that do not allow the\n              opponent to win immediately.\n\n        Returns:\n            list[int]: A list of column indices (0-6) where a move can be played.\n\n        Raises:\n            NotImplementedError: If the method is not implemented yet.\n        \"\"\"\n        # TODO: Implement in C++?\n        raise NotImplementedError(\"legal_moves is not implemented yet.\")\n\n    def has_win(self) -&gt; bool:\n        \"\"\"Checks if the current player has a winning position.\n\n        Returns:\n            bool: True if the current player has a winning position (4-in-a-row), False otherwise.\n\n        Unlike `can_win_next()`, which checks whether the current player *could* win\n        on their next move, the `has_win()` method determines whether a winning\n        condition already exists on the board.\n        This method is typically used right after a move to verify whether the game\n        has been won.\n\n        See also: [`bitbully.Board.can_win_next`][src.bitbully.Board.can_win_next].\n\n        Example:\n            ```python\n            import bitbully as bb\n\n            # Initialize a board from a move sequence.\n            # The string \"332311\" represents a position where Player 1 (yellow, X)\n            # is one move away from winning.\n            board = bb.Board(\"332311\")\n\n            # At this stage, Player 1 has not yet won, but can win immediately\n            # by placing a token in either column 0 or column 4.\n            assert not board.has_win()\n            assert board.can_win_next(0)  # Check column 0\n            assert board.can_win_next(4)  # Check column 4\n            assert board.can_win_next()  # General check (any winning move)\n\n            # Simulate Player 1 playing in column 4 \u2014 this completes\n            # a horizontal line of four tokens and wins the game.\n            assert board.play(4)\n\n            # Display the updated board to visualize the winning position.\n            print(board)\n\n            # The board now contains a winning configuration:\n            # Player 1 (yellow, X) has achieved a Connect-4.\n            assert board.has_win()\n            ```\n            Board from above, expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  O  _  _  _\n            _  O  _  O  _  _  _\n            _  X  X  X  X  _  _\n            ```\n        \"\"\"\n        return self._board.hasWin()\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Returns a hash of the Board instance for use in hash-based collections.\n\n        Returns:\n            int: The hash value of the Board instance.\n\n        Example:\n            ```python\n            import bitbully as bb\n\n            # Create two boards that represent the same final position.\n            # The first board is initialized directly from a move string.\n            board1 = bb.Board(\"33333111\")\n\n            # The second board is built incrementally by playing an equivalent sequence of moves.\n            # Even though the order of intermediate plays differs, the final layout of tokens\n            # (and thus the internal bitboard state) will be identical to `board1`.\n            board2 = bb.Board()\n            board2.play(\"31133331\")\n\n            # Boards with identical configurations produce the same hash value.\n            # This allows them to be used efficiently as keys in dictionaries or members of sets.\n            assert hash(board1) == hash(board2)\n\n            # Display the board's hash value.\n            hash(board1)\n            ```\n            Expected output:\n            ```text\n            971238920548618160\n            ```\n        \"\"\"\n        return self._board.hash()\n\n    def is_legal_move(self, move: int) -&gt; bool:\n        \"\"\"Checks if a move (column) is legal in the current position.\n\n        A move is considered *legal* if:\n\n        - The column index is within the valid range (0-6), **and**\n        - The column is **not full** (i.e. it still has at least one empty cell).\n\n        This method does **not** check for tactical consequences such as\n        leaving an immediate win to the opponent, nor does it stop being\n        usable once a player has already won. It purely validates whether a\n        token can be dropped into the given column according to the basic\n        rules of Connect Four. You have to check for wins separately using\n        [`bitbully.Board.has_win`][src.bitbully.Board.has_win].\n\n\n        Args:\n            move (int): The column index (0-6) to check.\n\n        Returns:\n            bool: True if the move is legal, False otherwise.\n\n        Example:\n            All moves are legal on an empty board:\n            ```python\n            import bitbully as bb\n\n            board = bb.Board()  # Empty 7x6 board\n\n            # Every column index from 0 to 6 is a valid move.\n            for col in range(7):\n                assert board.is_legal_move(col)\n\n            # Out-of-range indices are always illegal.\n            assert not board.is_legal_move(-1)\n            assert not board.is_legal_move(7)\n            ```\n\n        Example:\n            Detecting an illegal move in a full column:\n            ```python\n            import bitbully as bb\n\n            # Fill the center column (index 3) with six tokens.\n            board = bb.Board()\n            assert board.play([3, 3, 3, 3, 3, 3])\n\n            # The center column is now full, so another move in column 3 is illegal.\n            assert not board.is_legal_move(3)\n\n            # Other columns are still available (as long as they are not full).\n            assert board.is_legal_move(0)\n            assert board.is_legal_move(6)\n\n            print(board)\n            ```\n            Expected output:\n            ```text\n            _  _  _  O  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  _  _  X  _  _  _\n            ```\n\n        Example:\n            This function only checks legality, not for situations where a player has won:\n            ```python\n            import bitbully as bb\n\n            # Player 1 (yellow, X) wins  the game.\n            board = bb.Board()\n            assert board.play(\"1122334\")\n\n            # Even though Player 1 has already won, moves in non-full columns are still legal.\n            for col in range(7):\n                assert board.is_legal_move(col)\n\n            print(board)\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  O  O  O  _  _  _\n            _  X  X  X  X  _  _\n            ```\n        \"\"\"\n        return self._board.isLegalMove(move)\n\n    def mirror(self) -&gt; Board:\n        \"\"\"Returns a new Board instance that is the mirror image of the current board.\n\n        This method reflects the board **horizontally** around its vertical center column:\n        - Column 0 &lt;-&gt; Column 6\n        - Column 1 &lt;-&gt; Column 5\n        - Column 2 &lt;-&gt; Column 4\n        - Column 3 stays in the center\n\n        The player to move is not changed - only the spatial\n        arrangement of the tokens is mirrored. The original board remains unchanged;\n        `mirror()` always returns a **new** `Board` instance.\n\n        Returns:\n            Board: A new Board instance that is the mirror image of the current one.\n\n        Example:\n            Mirroring a simple asymmetric position:\n            ```python\n            import bitbully as bb\n\n            # Play four moves along the bottom row.\n            board = bb.Board()\n            assert board.play(\"0123\")  # Columns: 0, 1, 2, 3\n\n            # Create a mirrored copy of the board.\n            mirrored = board.mirror()\n\n            print(\"Original:\")\n            print(board)\n\n            print(\"Mirrored:\")\n            print(mirrored)\n            ```\n\n            Expected output:\n            ```text\n            Original:\n\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            X  O  X  O  _  _  _\n\n            Mirrored:\n\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  O  X  O  X\n            ```\n\n        Example:\n            Mirroring a position that is already symmetric:\n            ```python\n            import bitbully as bb\n\n            # Central symmetry: one token in each outer column and in the center.\n            board = bb.Board([1, 3, 5])\n\n            mirrored = board.mirror()\n\n            # The mirrored position is identical to the original.\n            assert board == mirrored\n            assert hash(board) == hash(mirrored)\n\n            print(board)\n            ```\n             Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  X  _  O  _  X  _\n            ```\n        \"\"\"\n        new_board = Board()\n        new_board._board = self._board.mirror()\n        return new_board\n\n    def moves_left(self) -&gt; int:\n        \"\"\"Returns the number of moves left until the board is full.\n\n        This is simply the number of *empty* cells remaining on the 7x6 grid.\n        On an empty board there are 42 free cells, so:\n\n        - At the start of the game: `moves_left() == 42`\n        - After `n` valid moves: `moves_left() == 42 - n`\n        - On a completely full board: `moves_left() == 0`\n\n        This method is equivalent to:\n        ```\n        42 - board.count_tokens()\n        ```\n        but implemented efficiently in the underlying C++ core.\n\n        Returns:\n            int: The number of moves left (0-42).\n\n        Example:\n            Moves left on an empty board:\n            ```python\n            import bitbully as bb\n\n            board = bb.Board()  # No tokens placed yet.\n            assert board.moves_left() == 42\n            assert board.count_tokens() == 0\n            ```\n\n        Example:\n            Relation to the number of moves played:\n            ```python\n            import bitbully as bb\n\n            # Play five moves in various columns.\n            moves = [3, 3, 1, 4, 6]\n            board = bb.Board()\n            assert board.play(moves)\n\n            # Five tokens have been placed, so 42 - 5 = 37 moves remain.\n            assert board.count_tokens() == 5\n            assert board.moves_left() == 37\n            assert board.moves_left() + board.count_tokens() == 42\n            ```\n        \"\"\"\n        return self._board.movesLeft()\n\n    def play(self, move: int | Sequence[int] | str) -&gt; bool:\n        \"\"\"Plays one or more moves for the current player.\n\n        The method updates the internal board state by dropping tokens\n        into the specified columns. Input can be:\n        - a single integer (column index 0 to 6),\n        - an iterable sequence of integers (e.g., `[3, 1, 3]` or `range(7)`),\n        - or a string of digits (e.g., `\"33333111\"`) representing the move order.\n\n        Args:\n            move (int | Sequence[int] | str):\n                The column index or sequence of column indices where tokens should be placed.\n\n        Returns:\n            bool: True if the move was played successfully, False if the move was illegal.\n\n\n        Example:\n            Play a sequence of moves into the center column (column index 3):\n            ```python\n            import bitbully as bb\n\n            board = bb.Board()\n            assert board.play([3, 3, 3])  # returns True on successful move\n            board\n            ```\n\n            Expected output:\n\n            ```\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  _  _  X  _  _  _\n            ```\n\n        Example:\n            Play a sequence of moves across all columns:\n            ```python\n            import bitbully as bb\n\n            board = bb.Board()\n            assert board.play(range(7))  # returns True on successful move\n            board\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            X  O  X  O  X  O  X\n            ```\n\n        Example:\n            Play a sequence using a string:\n            ```python\n            import bitbully as bb\n\n            board = bb.Board()\n            assert board.play(\"33333111\")  # returns True on successful move\n            board\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  O  _  X  _  _  _\n            _  X  _  O  _  _  _\n            _  O  _  X  _  _  _\n            ```\n        \"\"\"\n        # Case 1: string -&gt; pass through directly\n        if isinstance(move, str):\n            return self._board.play(move)\n\n        # Case 2: int -&gt; pass through directly\n        if isinstance(move, int):\n            return self._board.play(move)\n\n        # From here on, move is a Sequence[...] (but not str or int).\n        move_list: list[int] = [int(v) for v in cast(Sequence[Any], move)]\n        return self._board.play(move_list)\n\n    def play_on_copy(self, move: int) -&gt; Board:\n        \"\"\"Return a new board with the given move applied, leaving the current board unchanged.\n\n        Args:\n            move (int):\n                The column index (0-6) in which to play the move.\n\n        Returns:\n            Board:\n                A new Board instance representing the position after the move.\n\n        Raises:\n            ValueError: If the move is illegal (e.g. column is full or out of range).\n\n        Example:\n            ```python\n            import bitbully as bb\n\n            board = bb.Board(\"333\")  # Some existing position\n            new_board = board.play_on_copy(4)\n\n            # The original board is unchanged.\n            assert board.count_tokens() == 3\n\n            # The returned board includes the new move.\n            assert new_board.count_tokens() == 4\n            assert new_board != board\n            ```\n        \"\"\"\n        # Delegate to C++ (this returns a BoardCore instance)\n        core_new = self._board.playMoveOnCopy(move)\n\n        if core_new is None:\n            # C++ signals illegal move by returning a null board\n            raise ValueError(f\"Illegal move: column {move}\")\n\n        # Wrap in a new high-level Board object\n        new_board = Board()\n        new_board._board = core_new\n        return new_board\n\n    def reset_board(self, board: Sequence[int] | Sequence[Sequence[int]] | str | None = None) -&gt; bool:\n        \"\"\"Resets the board or sets (overrides) the board to a specific state.\n\n        Args:\n            board (Sequence[int] | Sequence[Sequence[int]] | str | None):\n                The new board state. Accepts:\n                - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7\n                - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3])\n                - String: A move sequence of columns as string (e.g., \"002233...\")\n                - None: to reset to an empty board\n\n        Returns:\n            bool: True if the board was set successfully, False otherwise.\n\n        Example:\n            Reset the board to an empty state:\n            ```python\n            import bitbully as bb\n\n            # Create a temporary board position from a move string.\n            # The string \"0123456\" plays one token in each column (0-6) in sequence.\n            board = bb.Board(\"0123456\")\n\n            # Reset the board to an empty state.\n            # Calling `reset_board()` clears all tokens and restores the starting position.\n            # No moves \u2192 an empty board.\n            assert board.reset_board()\n            board\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            ```\n\n        Example:\n            (Re-)Set the board using a move sequence string:\n            ```python\n            import bitbully as bb\n\n            # This is just a temporary setup; it will be replaced below.\n            board = bb.Board(\"0123456\")\n\n            # Set the board state directly from a move sequence.\n            # The list [3, 3, 3] represents three consecutive moves in the center column (index 3).\n            # Moves alternate automatically between Player 1 (yellow) and Player 2 (red).\n            #\n            # The `reset_board()` method clears the current position and replays the given moves\n            # from an empty board \u2014 effectively overriding any existing board state.\n            assert board.reset_board([3, 3, 3])\n\n            # Display the updated board to verify the new position.\n            board\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  _  _  X  _  _  _\n            ```\n\n        Example:\n            You can also set the board using other formats, such as a 2D array or a string.\n            See the examples in the [`bitbully.Board.__init__`][src.bitbully.Board.__init__] docstring for details.\n\n            ```python\n            # Briefly demonstrate the different input formats accepted by `reset_board()`.\n            import bitbully as bb\n\n            # Create an empty board instance\n            board = bb.Board()\n\n            # Variant 1: From a list of moves (integers)\n            # Each number represents a column index (0-6); moves alternate between players.\n            assert board.reset_board([3, 3, 3])\n\n            # Variant 2: From a compact move string\n            # Equivalent to the list above \u2014 useful for quick testing or serialization.\n            assert board.reset_board(\"33333111\")\n\n            # Variant 3: From a 2D list in row-major format (6 x 7)\n            # Each inner list represents a row (top to bottom).\n            # 0 = empty, 1 = Player 1, 2 = Player 2.\n            board_array = [\n                [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n                [0, 0, 0, 1, 0, 0, 0],  # Row 4\n                [0, 0, 0, 2, 0, 0, 0],  # Row 3\n                [0, 2, 0, 1, 0, 0, 0],  # Row 2\n                [0, 1, 0, 2, 0, 0, 0],  # Row 1\n                [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom)\n            ]\n            assert board.reset_board(board_array)\n\n            # Variant 4: From a 2D list in column-major format (7 x 6)\n            # Each inner list represents a column (left to right); this matches BitBully's internal layout.\n            board_array = [\n                [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)\n                [2, 1, 2, 1, 0, 0],  # Column 1\n                [0, 0, 0, 0, 0, 0],  # Column 2\n                [1, 2, 1, 2, 1, 0],  # Column 3 (center)\n                [0, 0, 0, 0, 0, 0],  # Column 4\n                [2, 1, 2, 0, 0, 0],  # Column 5\n                [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)\n            ]\n            assert board.reset_board(board_array)\n\n            # Display the final board state in text form\n            board\n            ```\n\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  X  _  O  _  _  _\n            _  O  _  X  _  O  _\n            _  X  _  O  _  X  _\n            _  O  _  X  _  O  _\n            ```\n        \"\"\"\n        if board is None:\n            return self._board.setBoard([])\n        if isinstance(board, str):\n            return self._board.setBoard(board)\n\n        # From here on, board is a Sequence[...] (but not str).\n        # Distinguish 2D vs 1D by inspecting the first element.\n        if len(board) &gt; 0 and isinstance(board[0], Sequence) and not isinstance(board[0], (str, bytes)):\n            # Case 2: 2D -&gt; list[list[int]]\n            # Convert inner sequences to lists of ints\n            grid: list[list[int]] = [[int(v) for v in row] for row in cast(Sequence[Sequence[Any]], board)]\n            return self._board.setBoard(grid)\n\n        # Case 3: 1D -&gt; list[int]\n        moves: list[int] = [int(v) for v in cast(Sequence[Any], board)]\n        return self._board.setBoard(moves)\n\n    def to_array(self, column_major_layout: bool = True) -&gt; list[list[int]]:\n        \"\"\"Returns the board state as a 2D array (list of lists).\n\n        This layout is convenient for printing, serialization, or converting\n        to a NumPy array for further analysis.\n\n        Args:\n            column_major_layout (bool): Use column-major format if set to `True`,\n                otherwise the row-major-layout is used.\n\n        Returns:\n            list[list[int]]: A 7x6 2D list representing the board state.\n\n        Raises:\n            NotImplementedError: If `column_major_layout` is set to `False`.\n\n        Example:\n            === \"Column-major Format:\"\n\n                The returned array is in **column-major** format with shape `7 x 6`\n                (`[column][row]`):\n\n                - There are 7 inner lists, one for each column of the board.\n                - Each inner list has 6 integers, one for each row.\n                - Row index `0` corresponds to the **bottom row**,\n                row index `5` to the **top row**.\n                - Convention:\n                - `0` -&gt; empty cell\n                - `1` -&gt; Player 1 token (yellow, X)\n                - `2` -&gt; Player 2 token (red, O)\n\n                ```python\n                import bitbully as bb\n                from pprint import pprint\n\n                # Create a position from a move sequence.\n                board = bb.Board(\"33333111\")\n\n                # Extract the board as a 2D list (rows x columns).\n                arr = board.to_array()\n\n                # Reconstruct the same position from the 2D array.\n                board2 = bb.Board(arr)\n\n                # Both boards represent the same position.\n                assert board == board2\n                assert board.to_array() == board2.to_array()\n\n                # print ther result of `board.to_array()`:\n                pprint(board.to_array())\n                ```\n                Expected output:\n                ```text\n                [[0, 0, 0, 0, 0, 0],\n                [2, 1, 2, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0],\n                [1, 2, 1, 2, 1, 0],\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0]]\n                ```\n\n            === \"Row-major Format:\"\n\n                ``` markdown\n                TODO: This is not supported yet\n                ```\n        \"\"\"\n        if not column_major_layout:\n            # TODO: Implement in C++\n            raise NotImplementedError(\"Row-major Layout is yet to be implemented\")\n\n        return self._board.toArray()\n\n    def to_string(self) -&gt; str:\n        \"\"\"Returns a human-readable ASCII representation of the board.\n\n        The returned string shows the **current board position** as a 6x7 grid,\n        laid out exactly as it would appear when you print a `Board` instance:\n\n        - 6 lines of text, one per row (top row first, bottom row last)\n        - 7 entries per row, separated by two spaces\n        - `_` represents an empty cell\n        - `X` represents a token from Player 1 (yellow)\n        - `O` represents a token from Player 2 (red)\n\n        This is useful when you want to explicitly capture the board as a string\n        (e.g., for logging, debugging, or embedding into error messages) instead\n        of relying on `print(board)` or `repr(board)`.\n\n        Returns:\n            str: A multi-line ASCII string representing the board state.\n\n        Example:\n            Using `to_string()` on an empty board:\n            ```python\n            import bitbully as bb\n\n            board = bb.Board(\"33333111\")\n\n            s = board.to_string()\n            print(s)\n            ```\n\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  O  _  X  _  _  _\n            _  X  _  O  _  _  _\n            _  O  _  X  _  _  _\n            ```\n        \"\"\"\n        return self._board.toString()\n\n    def uid(self) -&gt; int:\n        \"\"\"Returns a unique identifier for the current board state.\n\n        The UID is a deterministic integer computed from the internal bitboard\n        representation of the position. It is **stable**, **position-based**, and\n        uniquely tied to the exact token layout **and** the side to move.\n\n        Key properties:\n\n        - Boards with the **same** configuration (tokens + player to move) always\n          produce the **same** UID.\n        - Any change to the board (e.g., after a legal move) will almost always\n          result in a **different** UID.\n        - Copies of a board created via the copy constructor or `Board.copy()`\n          naturally share the same UID as long as their states remain identical.\n\n        Unlike `__hash__()`, the UID is not optimized for hash-table dispersion.\n        For use in transposition tables, caching, or dictionary/set keys,\n        prefer `__hash__()` since it provides a higher-quality hash distribution.\n\n        Returns:\n            int: A unique integer identifier for the board state.\n\n        Example:\n            UID is an integer and not None:\n            ```python\n            import bitbully as bb\n\n            board = bb.Board()\n            u = board.uid()\n\n            assert isinstance(u, int)\n            # Empty board has a well-defined, stable UID.\n            assert board.uid() == u\n            ```\n\n        Example:\n            UID changes when the position changes:\n            ```python\n            import bitbully as bb\n\n            board = bb.Board()\n            uid_before = board.uid()\n\n            assert board.play(1)  # Make a move in column 1.\n\n            uid_after = board.uid()\n            assert uid_after != uid_before\n            ```\n\n        Example:\n            Copies share the same UID while they are identical:\n            ```python\n            import bitbully as bb\n\n            board = bb.Board(\"0123\")\n\n            # Create an independent copy of the same position.\n            board_copy = board.copy()\n\n            assert board is not board_copy  # Different objects\n            assert board == board_copy  # Same position\n            assert board.uid() == board_copy.uid()  # Same UID\n\n            # After modifying the copy, they diverge.\n            assert board_copy.play(4)\n            assert board != board_copy\n            assert board.uid() != board_copy.uid()\n            ```\n\n        Example:\n            Different move sequences leading to the same position share the same UID:\n            ```python\n            import bitbully as bb\n\n            board_1 = bb.Board(\"01234444\")\n            board_2 = bb.Board(\"44440123\")\n\n            assert board_1 is not board_2  # Different objects\n            assert board_1 == board_2  # Same position\n            assert board_1.uid() == board_2.uid()  # Same UID\n\n            # After modifying the copy, they diverge.\n            assert board_1.play(4)\n            assert board_1 != board_2\n            assert board_1.uid() != board_2.uid()\n            ```\n        \"\"\"\n        return self._board.uid()\n\n    @property\n    def current_player(self) -&gt; int:\n        \"\"\"Returns the player whose turn it is to move.\n\n        The current player is derived from the **parity** of the number of tokens\n        on the board:\n\n        - Player 1 (yellow, ``X``) moves first on an empty board.\n        - After an even number of moves \u2192 it is Player 1's turn.\n        - After an odd  number of moves \u2192 it is Player 2's turn.\n\n        Returns:\n            int:\n                The player to move:\n\n                - ``1`` \u2192 Player 1 (yellow, ``X``)\n                - ``2`` \u2192 Player 2 (red, ``O``)\n\n        Example:\n            ```python\n            import bitbully as bb\n\n            # Empty board \u2192 Player 1 starts.\n            board = bb.Board()\n            assert board.current_player == 1\n            assert board.count_tokens() == 0\n\n            # After one move, it's Player 2's turn.\n            assert board.play(3)\n            assert board.count_tokens() == 1\n            assert board.current_player == 2\n\n            # After a second move, it's again Player 1's turn.\n            assert board.play(4)\n            assert board.count_tokens() == 2\n            assert board.current_player == 1\n            ```\n        \"\"\"\n        # Empty board: Player 1\n        return 1 if self.count_tokens() % 2 == 0 else 2\n\n    def is_full(self) -&gt; bool:\n        \"\"\"Checks whether the board has any empty cells left.\n\n        A Connect Four board has 42 cells in total (7 columns x 6 rows).\n        This method returns ``True`` if **all** cells are occupied, i.e.\n        when  [`bitbully.Board.moves_left`][src.bitbully.Board.moves_left] returns ``0``.\n\n        Returns:\n            bool:\n                ``True`` if the board is completely full\n                (no more legal moves possible), otherwise ``False``.\n\n        Example:\n            ```python\n            import bitbully as bb\n\n            board = bb.Board()\n            assert not board.is_full()\n            assert board.moves_left() == 42\n            assert board.count_tokens() == 0\n\n            # Fill the board column by column.\n            for _ in range(6):\n                assert board.play(\"0123456\")  # one token per column, per row\n\n            # Now every cell is occupied.\n            assert board.is_full()\n            assert board.moves_left() == 0\n            assert board.count_tokens() == 42\n            ```\n        \"\"\"\n        return self.moves_left() == 0\n\n    def is_game_over(self) -&gt; bool:\n        \"\"\"Checks whether the game has ended (win or draw).\n\n        A game of Connect Four is considered **over** if:\n\n        - One of the players has a winning position\n          (see [`bitbully.Board.has_win`][src.bitbully.Board.has_win]), **or**\n        - The board is completely full and no further moves can be played\n          (see [`bitbully.Board.is_full`][src.bitbully.Board.is_full]).\n\n        This method does **not** indicate *who* won; for that, use\n        [`bitbully.Board.winner`][src.bitbully.Board.winner].\n\n        Returns:\n            bool:\n                ``True`` if the game is over (win or draw), otherwise ``False``.\n\n        Example:\n            Game over by a win:\n            ```python\n            import bitbully as bb\n\n            # Player 1 (X) wins horizontally on the bottom row.\n            board = bb.Board()\n            assert board.play(\"0101010\")\n\n            assert board.has_win()\n            assert board.is_game_over()\n            assert board.winner() == 1\n            ```\n\n        Example:\n            Game over by a draw (full board, no winner):\n            ```python\n            import bitbully as bb\n\n            board, _ = bb.Board.random_board(42, forbid_direct_win=False)\n\n            assert board.is_full()\n            assert not board.has_win()\n            assert board.is_game_over()\n            assert board.winner() is None\n            ```\n        \"\"\"\n        return self.has_win() or self.is_full()\n\n    def winner(self) -&gt; int | None:\n        \"\"\"Returns the winning player, if the game has been won.\n\n        This helper interprets the current board under the assumption that\n        [`bitbully.Board.has_win`][src.bitbully.Board.has_win] indicates **the last move** created a\n        winning configuration. In that case, the winner is the *previous* player:\n\n        - If it is currently Player 1's turn, then Player 2 must have just won.\n        - If it is currently Player 2's turn, then Player 1 must have just won.\n\n        If there is no winner (i.e. [`bitbully.Board.has_win`][src.bitbully.Board.has_win] is ``False``),\n        this method returns ``None``.\n\n        Returns:\n            int | None:\n                The winning player, or ``None`` if there is no winner.\n\n                - ``1`` \u2192 Player 1 (yellow, ``X``)\n                - ``2`` \u2192 Player 2 (red, ``O``)\n                - ``None`` \u2192 No winner (game still ongoing or draw)\n\n        Example:\n            Detecting a winner:\n            ```python\n            import bitbully as bb\n\n            # Player 1 wins with a horizontal line at the bottom.\n            board = bb.Board()\n            assert board.play(\"1122334\")\n\n            assert board.has_win()\n            assert board.is_game_over()\n\n            # It is now Player 2's turn to move next...\n            assert board.current_player == 2\n\n            # ...which implies Player 1 must be the winner.\n            assert board.winner() == 1\n            ```\n\n        Example:\n            No winner yet:\n            ```python\n            import bitbully as bb\n\n            board = bb.Board()\n            assert board.play(\"112233\")  # no connect-four yet\n\n            assert not board.has_win()\n            assert not board.is_game_over()\n            assert board.winner() is None\n            ```\n        \"\"\"\n        if not self.has_win():\n            return None\n        # Previous player = opposite of current_player\n        return 2 if self.current_player == 1 else 1\n\n    @classmethod\n    def from_moves(cls, moves: Sequence[int] | str) -&gt; Board:\n        \"\"\"Creates a board by replaying a sequence of moves from the empty position.\n\n        This is a convenience constructor around [`bitbully.Board.play`][src.bitbully.Board.play].\n        It starts from an empty board and applies the given move sequence, assuming\n        it is **legal** (no out-of-range columns, no moves in full columns, etc.).\n\n        Args:\n            moves (Sequence[int] | str):\n                The move sequence to replay from the starting position. Accepts:\n\n                - A sequence of integers (e.g. ``[3, 3, 3, 1]``)\n                - A string of digits (e.g. ``\"3331\"``)\n\n                Each value represents a column index (0-6). Players alternate\n                automatically between moves.\n\n        Returns:\n            Board:\n                A new `Board` instance representing the final position\n                after all moves have been applied.\n\n        Example:\n            ```python\n            import bitbully as bb\n\n            # Create a position directly from a compact move string.\n            board = bb.Board.from_moves(\"33333111\")\n\n            # Equivalent to:\n            # board = bb.Board()\n            # assert board.play(\"33333111\")\n\n            print(board)\n            assert board.count_tokens() == 8\n            assert not board.has_win()\n            ```\n        \"\"\"\n        board = cls()\n        assert board.play(moves)\n        return board\n\n    @classmethod\n    def from_array(cls, arr: Sequence[Sequence[int]]) -&gt; Board:\n        \"\"\"Creates a board directly from a 2D array representation.\n\n        This is a convenience wrapper around the main constructor\n        [`bitbully.Board.__init__`][src.bitbully.Board.__init__]\n        and accepts the same array formats:\n\n        - **Row-major**: 6 x 7 (``[row][column]``), top row first.\n        - **Column-major**: 7 x 6 (``[column][row]``), left column first.\n\n        Values must follow the usual convention:\n\n        - ``0`` \u2192 empty cell\n        - ``1`` \u2192 Player 1 token (yellow, ``X``)\n        - ``2`` \u2192 Player 2 token (red, ``O``)\n\n        Args:\n            arr (Sequence[Sequence[int]]):\n                A 2D array describing the board state, either in row-major or\n                column-major layout. See the examples in\n                [`bitbully.Board.__init__`][src.bitbully.Board.__init__] for details.\n\n        Returns:\n            Board:\n                A new `Board` instance representing the given layout.\n\n        Example:\n            Using a 6 x 7 row-major layout:\n            ```python\n            import bitbully as bb\n\n            board_array = [\n                [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n                [0, 0, 0, 1, 0, 0, 0],  # Row 4\n                [0, 0, 0, 2, 0, 0, 0],  # Row 3\n                [0, 2, 0, 1, 0, 0, 0],  # Row 2\n                [0, 1, 0, 2, 0, 0, 0],  # Row 1\n                [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom)\n            ]\n\n            board = bb.Board.from_array(board_array)\n            print(board)\n            ```\n\n        Example:\n            Using a 7 x 6 column-major layout:\n            ```python\n            import bitbully as bb\n\n            board_array = [\n                [0, 0, 0, 0, 0, 0],  # Column 0\n                [2, 1, 2, 1, 0, 0],  # Column 1\n                [0, 0, 0, 0, 0, 0],  # Column 2\n                [1, 2, 1, 2, 1, 0],  # Column 3\n                [0, 0, 0, 0, 0, 0],  # Column 4\n                [2, 1, 2, 0, 0, 0],  # Column 5\n                [0, 0, 0, 0, 0, 0],  # Column 6\n            ]\n\n            board = bb.Board.from_array(board_array)\n\n            # Round-trip via to_array:\n            assert board.to_array() == board_array\n            ```\n        \"\"\"\n        return cls(arr)\n\n    @staticmethod\n    def random_board(n_ply: int, forbid_direct_win: bool) -&gt; tuple[Board, list[int]]:\n        \"\"\"Generates a random board state by playing a specified number of random moves.\n\n        If ``forbid_direct_win`` is ``True``, the generated position is guaranteed\n        **not** to contain an immediate winning move for the player to move.\n\n        Args:\n            n_ply (int):\n                Number of random moves to simulate (0-42).\n            forbid_direct_win (bool):\n                If ``True``, ensures the resulting board has **no immediate winning move**.\n\n        Returns:\n            tuple[Board, list[int]]:\n                A pair ``(board, moves)`` where ``board`` is the generated position\n                and ``moves`` are the exact random moves performed.\n\n        Raises:\n            ValueError: If `n_ply` is outside the valid range [0, 42].\n\n        Example:\n            Basic usage:\n            ```python\n            import bitbully as bb\n\n            board, moves = bb.Board.random_board(10, forbid_direct_win=True)\n\n            print(\"Moves:\", moves)\n            print(\"Board:\")\n            print(board)\n\n            # The move list must match the requested ply.\n            assert len(moves) == 10\n\n            # No immediate winning move when forbid_direct_win=True.\n            assert not board.can_win_next()\n            ```\n\n        Example:\n            Using random boards in tests or simulations:\n            ```python\n            import bitbully as bb\n\n            # Generate 50 random 10-ply positions.\n            for _ in range(50):\n                board, moves = bb.Board.random_board(10, forbid_direct_win=True)\n                assert len(moves) == 10\n                assert not board.has_win()  # Game should not be over\n                assert board.count_tokens() == 10  # All generated boards contain exactly 10 tokens\n                assert not board.can_win_next()  # Since `forbid_direct_win=True`, no immediate threat\n            ```\n\n        Example:\n            Reconstructing the board manually from the move list:\n            ```python\n            import bitbully as bb\n\n            b1, moves = bb.Board.random_board(8, forbid_direct_win=True)\n\n            # Recreate the board using the move sequence:\n            b2 = bb.Board(moves)\n\n            assert b1 == b2\n            assert b1.to_string() == b2.to_string()\n            assert b1.uid() == b2.uid()\n            ```\n\n        Example:\n            Ensure randomness by generating many distinct sequences:\n            ```python\n            import bitbully as bb\n\n            seen = set()\n            for _ in range(20):\n                _, moves = bb.Board.random_board(5, False)\n                seen.add(tuple(moves))\n\n            # Very likely to see more than one unique sequence.\n            assert len(seen) &gt; 1\n            ```\n        \"\"\"\n        if not 0 &lt;= n_ply &lt;= 42:\n            raise ValueError(f\"n_ply must be between 0 and 42 (inclusive), got {n_ply}.\")\n        board_, moves = bitbully_core.BoardCore.randomBoard(n_ply, forbid_direct_win)\n        board = Board()\n        board._board = board_\n\n        return board, moves\n\n    def to_huffman(self) -&gt; int:\n        \"\"\"Encode the current board position into a Huffman-compressed byte sequence.\n\n        This is a high-level wrapper around\n        `bitbully_core.BoardCore.toHuffman`. The returned int encodes the\n        exact token layout **and** the side to move using the same format as\n        the BitBully opening databases.\n\n        The encoding is:\n\n        - Deterministic: the same position always yields the same byte sequence.\n        - Compact: suitable for storage (of positions with little number of tokens),\n          or lookups in the BitBully database format.\n\n        Returns:\n            int: A Huffman-compressed representation of the current board\n            state.\n\n        Raises:\n            NotImplementedError:\n                If the position does not contain exactly 8 or 12 tokens, as the\n                  Huffman encoding is only defined for these cases.\n\n        Example:\n            Encode a position and verify that equivalent positions have the\n            same Huffman code:\n\n            ```python\n            import bitbully as bb\n\n            # Two different move sequences leading to the same final position.\n            b1 = bb.Board(\"01234444\")\n            b2 = bb.Board(\"44440123\")\n\n            h1 = b1.to_huffman()\n            h2 = b2.to_huffman()\n\n            # Huffman encoding is purely position-based.\n            assert h1 == h2\n\n            print(f\"Huffman code: {h1}\")\n            ```\n        Expected output:\n            ```text\n            Huffman code: 10120112\n            ```\n        \"\"\"\n        token_count = self.count_tokens()\n        if token_count != 8 and token_count != 12:\n            raise NotImplementedError(\"to_huffman() is only implemented for positions with 8 or 12 tokens.\")\n        return self._board.toHuffman()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.current_player","title":"<code>current_player</code>  <code>property</code>","text":"<p>Returns the player whose turn it is to move.</p> <p>The current player is derived from the parity of the number of tokens on the board:</p> <ul> <li>Player 1 (yellow, <code>X</code>) moves first on an empty board.</li> <li>After an even number of moves \u2192 it is Player 1's turn.</li> <li>After an odd  number of moves \u2192 it is Player 2's turn.</li> </ul> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The player to move:</p> <ul> <li><code>1</code> \u2192 Player 1 (yellow, <code>X</code>)</li> <li><code>2</code> \u2192 Player 2 (red, <code>O</code>)</li> </ul> Example <pre><code>import bitbully as bb\n\n# Empty board \u2192 Player 1 starts.\nboard = bb.Board()\nassert board.current_player == 1\nassert board.count_tokens() == 0\n\n# After one move, it's Player 2's turn.\nassert board.play(3)\nassert board.count_tokens() == 1\nassert board.current_player == 2\n\n# After a second move, it's again Player 1's turn.\nassert board.play(4)\nassert board.count_tokens() == 2\nassert board.current_player == 1\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.__eq__","title":"<code>__eq__(value)</code>","text":"<p>Checks equality between two Board instances.</p> Notes <ul> <li>Equality checks in BitBully compare the exact board state (bit patterns),   not just the move history.</li> <li>Two different move sequences can still yield the same position if they   result in identical token configurations.</li> <li>This is useful for comparing solver states, verifying test positions,   or detecting transpositions in search algorithms.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>object</code> <p>The other Board instance to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if both boards are equal, False otherwise.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the other value is not a Board instance.</p> Example <pre><code>import bitbully as bb\n\n# Create two boards that should represent *identical* game states.\nboard1 = bb.Board()\nassert board1.play(\"33333111\")\n\nboard2 = bb.Board()\n# Play the same position step by step using a different but equivalent sequence.\n# Internally, the final bitboard state will match `board1`.\nassert board2.play(\"31133331\")\n\n# Boards with identical token placements are considered equal.\n# Equality (`==`) and inequality (`!=`) operators are overloaded for convenience.\nassert board1 == board2\nassert not (board1 != board2)\n\n# ------------------------------------------------------------------------------\n\n# Create two boards that differ by one move.\nboard1 = bb.Board(\"33333111\")\nboard2 = bb.Board(\"33333112\")  # One extra move in the last column (index 2)\n\n# Since the token layout differs, equality no longer holds.\nassert board1 != board2\nassert not (board1 == board2)\n</code></pre> Source code in <code>src/bitbully/board.py</code> <pre><code>def __eq__(self, value: object) -&gt; bool:\n    \"\"\"Checks equality between two Board instances.\n\n    Notes:\n        - Equality checks in BitBully compare the *exact board state* (bit patterns),\n          not just the move history.\n        - Two different move sequences can still yield the same position if they\n          result in identical token configurations.\n        - This is useful for comparing solver states, verifying test positions,\n          or detecting transpositions in search algorithms.\n\n    Args:\n        value (object): The other Board instance to compare against.\n\n    Returns:\n        bool: True if both boards are equal, False otherwise.\n\n    Raises:\n        NotImplementedError: If the other value is not a Board instance.\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        # Create two boards that should represent *identical* game states.\n        board1 = bb.Board()\n        assert board1.play(\"33333111\")\n\n        board2 = bb.Board()\n        # Play the same position step by step using a different but equivalent sequence.\n        # Internally, the final bitboard state will match `board1`.\n        assert board2.play(\"31133331\")\n\n        # Boards with identical token placements are considered equal.\n        # Equality (`==`) and inequality (`!=`) operators are overloaded for convenience.\n        assert board1 == board2\n        assert not (board1 != board2)\n\n        # ------------------------------------------------------------------------------\n\n        # Create two boards that differ by one move.\n        board1 = bb.Board(\"33333111\")\n        board2 = bb.Board(\"33333112\")  # One extra move in the last column (index 2)\n\n        # Since the token layout differs, equality no longer holds.\n        assert board1 != board2\n        assert not (board1 == board2)\n        ```\n    \"\"\"\n    if not isinstance(value, Board):\n        raise NotImplementedError(\"Can only compare with another Board instance.\")\n    return bool(self._board == value._board)\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns a hash of the Board instance for use in hash-based collections.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The hash value of the Board instance.</p> Example <p><pre><code>import bitbully as bb\n\n# Create two boards that represent the same final position.\n# The first board is initialized directly from a move string.\nboard1 = bb.Board(\"33333111\")\n\n# The second board is built incrementally by playing an equivalent sequence of moves.\n# Even though the order of intermediate plays differs, the final layout of tokens\n# (and thus the internal bitboard state) will be identical to `board1`.\nboard2 = bb.Board()\nboard2.play(\"31133331\")\n\n# Boards with identical configurations produce the same hash value.\n# This allows them to be used efficiently as keys in dictionaries or members of sets.\nassert hash(board1) == hash(board2)\n\n# Display the board's hash value.\nhash(board1)\n</code></pre> Expected output: <pre><code>971238920548618160\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Returns a hash of the Board instance for use in hash-based collections.\n\n    Returns:\n        int: The hash value of the Board instance.\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        # Create two boards that represent the same final position.\n        # The first board is initialized directly from a move string.\n        board1 = bb.Board(\"33333111\")\n\n        # The second board is built incrementally by playing an equivalent sequence of moves.\n        # Even though the order of intermediate plays differs, the final layout of tokens\n        # (and thus the internal bitboard state) will be identical to `board1`.\n        board2 = bb.Board()\n        board2.play(\"31133331\")\n\n        # Boards with identical configurations produce the same hash value.\n        # This allows them to be used efficiently as keys in dictionaries or members of sets.\n        assert hash(board1) == hash(board2)\n\n        # Display the board's hash value.\n        hash(board1)\n        ```\n        Expected output:\n        ```text\n        971238920548618160\n        ```\n    \"\"\"\n    return self._board.hash()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.__init__","title":"<code>__init__(init_with=None)</code>","text":"<p>Initializes a Board instance.</p> <p>Parameters:</p> Name Type Description Default <code>init_with</code> <code>Sequence[Sequence[int]] | Sequence[int] | str | None</code> <p>Optional initial board state. Accepts: - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7 - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3]) - String: A move sequence of columns as string (e.g., \"002233\") - None for an empty board</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided initial board state is invalid.</p> Example <p>You can initialize an empty board in multiple ways: <pre><code>import bitbully as bb\n\n# Create an empty board using the default constructor.\nboard = bb.Board()  # Starts with no tokens placed.\n\n# Alternatively, initialize the board explicitly from a 2D list.\n# Each inner list represents a column (7 columns total, 6 rows each).\n# A value of 0 indicates an empty cell; 1 and 2 would represent player tokens.\nboard = bb.Board([[0] * 6 for _ in range(7)])  # Equivalent to an empty board.\n\n# You can also set up a specific board position manually using a 6 x 7 layout,\n# where each inner list represents a row instead of a column.\n# (Both layouts are accepted by BitBully for convenience.)\n# For more complex examples using 2D arrays, see the examples below.\nboard = bb.Board([[0] * 7 for _ in range(6)])  # Also equivalent to an empty board.\n\n# Display the board in text form.\n# The __repr__ method shows the current state (useful for debugging or interactive use).\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n</code></pre></p> <p>The recommended way to initialize an empty board is simply <code>Board()</code>.</p> Example <p>You can also initialize a board with a sequence of moves: <pre><code>import bitbully as bb\n\n# Initialize a board with a sequence of moves played in the center column.\n\n# The list [3, 3, 3] represents three moves in column index 3 (zero-based).\n# Moves alternate automatically between Player 1 (yellow, X) and Player 2 (red, O).\n# After these three moves, the center column will contain:\n#   - Row 0: Player 1 token (bottom)\n#   - Row 1: Player 2 token\n#   - Row 2: Player 1 token\nboard = bb.Board([3, 3, 3])\n\n# Display the resulting board.\n# The textual output shows the tokens placed in the center column.\nboard\n</code></pre></p> <p>Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n</code></pre></p> Example <p>You can also initialize a board using a string containing a move sequence: <pre><code>import bitbully as bb\n\n# Initialize a board using a compact move string.\n\n# The string \"33333111\" represents a sequence of eight moves:\n#   3 3 3 3 3 \u2192 five moves in the center column (index 3)\n#   1 1 1 \u2192 three moves in the second column (index 1)\n#\n# Moves are applied in order, alternating automatically between Player 1 (yellow, X)\n# and Player 2 (red, O), just as if you had called `board.play()` repeatedly.\n#\n# This shorthand is convenient for reproducing board states or test positions\n# without having to provide long move lists.\n\nboard = bb.Board(\"33333111\")\n\n# Display the resulting board.\n# The printed layout shows how the tokens stack in each column.\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Example <p>You can also initialize a board using a 2D array (list of lists): <pre><code>import bitbully as bb\n\n# Use a 6 x 7 list (rows x columns) to set up a specific board position manually.\n\n# Each inner list represents a row of the Connect-4 grid.\n# Convention:\n#   - 0 \u2192 empty cell\n#   - 1 \u2192 Player 1 token (yellow, X)\n#   - 2 \u2192 Player 2 token (red, O)\n#\n# The top list corresponds to the *top row* (row index 5),\n# and the bottom list corresponds to the *bottom row* (row index 0).\n# This layout matches the typical visual display of the board.\n\nboard_array = [\n    [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n    [0, 0, 0, 1, 0, 0, 0],  # Row 4: Player 1 token in column 3\n    [0, 0, 0, 2, 0, 0, 0],  # Row 3: Player 2 token in column 3\n    [0, 2, 0, 1, 0, 0, 0],  # Row 2: tokens in columns 1 and 3\n    [0, 1, 0, 2, 0, 0, 0],  # Row 1: tokens in columns 1 and 3\n    [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom): tokens stacked lowest\n]\n\n# Create a Board instance directly from the 2D list.\n# This allows reconstructing arbitrary positions (e.g., from test data or saved states)\n# without replaying the move sequence.\nboard = bb.Board(board_array)\n\n# Display the resulting board state in text form.\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Example <p>You can also initialize a board using a 2D (7 x 6) array with columns as inner lists: <pre><code>import bitbully as bb\n\n# Use a 7 x 6 list (columns x rows) to set up a specific board position manually.\n\n# Each inner list represents a **column** of the Connect-4 board, from left (index 0)\n# to right (index 6). Each column contains six entries \u2014 one for each row, from\n# bottom (index 0) to top (index 5).\n#\n# Convention:\n#   - 0 \u2192 empty cell\n#   - 1 \u2192 Player 1 token (yellow, X)\n#   - 2 \u2192 Player 2 token (red, O)\n#\n# This column-major layout matches the internal representation used by BitBully,\n# where tokens are dropped into columns rather than filled row by row.\n\nboard_array = [\n    [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)\n    [2, 1, 2, 0, 0, 0],  # Column 1\n    [0, 0, 0, 0, 0, 0],  # Column 2\n    [1, 2, 1, 2, 1, 0],  # Column 3 (center)\n    [0, 0, 0, 0, 0, 0],  # Column 4\n    [0, 0, 0, 0, 0, 0],  # Column 5\n    [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)\n]\n\n# Create a Board instance directly from the 2D list.\n# This allows reconstructing any arbitrary position (e.g., test cases, saved games)\n# without replaying all moves individually.\nboard = bb.Board(board_array)\n\n# Display the resulting board.\n# The text output shows tokens as they would appear in a real Connect-4 grid.\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def __init__(self, init_with: Sequence[Sequence[int]] | Sequence[int] | str | None = None) -&gt; None:\n    \"\"\"Initializes a Board instance.\n\n    Args:\n        init_with (Sequence[Sequence[int]] | Sequence[int] | str | None):\n            Optional initial board state. Accepts:\n            - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7\n            - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3])\n            - String: A move sequence of columns as string (e.g., \"002233\")\n            - None for an empty board\n\n    Raises:\n        ValueError: If the provided initial board state is invalid.\n\n    Example:\n        You can initialize an empty board in multiple ways:\n        ```python\n        import bitbully as bb\n\n        # Create an empty board using the default constructor.\n        board = bb.Board()  # Starts with no tokens placed.\n\n        # Alternatively, initialize the board explicitly from a 2D list.\n        # Each inner list represents a column (7 columns total, 6 rows each).\n        # A value of 0 indicates an empty cell; 1 and 2 would represent player tokens.\n        board = bb.Board([[0] * 6 for _ in range(7)])  # Equivalent to an empty board.\n\n        # You can also set up a specific board position manually using a 6 x 7 layout,\n        # where each inner list represents a row instead of a column.\n        # (Both layouts are accepted by BitBully for convenience.)\n        # For more complex examples using 2D arrays, see the examples below.\n        board = bb.Board([[0] * 7 for _ in range(6)])  # Also equivalent to an empty board.\n\n        # Display the board in text form.\n        # The __repr__ method shows the current state (useful for debugging or interactive use).\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        ```\n\n    The recommended way to initialize an empty board is simply `Board()`.\n\n    Example:\n        You can also initialize a board with a sequence of moves:\n        ```python\n        import bitbully as bb\n\n        # Initialize a board with a sequence of moves played in the center column.\n\n        # The list [3, 3, 3] represents three moves in column index 3 (zero-based).\n        # Moves alternate automatically between Player 1 (yellow, X) and Player 2 (red, O).\n        # After these three moves, the center column will contain:\n        #   - Row 0: Player 1 token (bottom)\n        #   - Row 1: Player 2 token\n        #   - Row 2: Player 1 token\n        board = bb.Board([3, 3, 3])\n\n        # Display the resulting board.\n        # The textual output shows the tokens placed in the center column.\n        board\n        ```\n\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        ```\n\n    Example:\n        You can also initialize a board using a string containing a move sequence:\n        ```python\n        import bitbully as bb\n\n        # Initialize a board using a compact move string.\n\n        # The string \"33333111\" represents a sequence of eight moves:\n        #   3 3 3 3 3 \u2192 five moves in the center column (index 3)\n        #   1 1 1 \u2192 three moves in the second column (index 1)\n        #\n        # Moves are applied in order, alternating automatically between Player 1 (yellow, X)\n        # and Player 2 (red, O), just as if you had called `board.play()` repeatedly.\n        #\n        # This shorthand is convenient for reproducing board states or test positions\n        # without having to provide long move lists.\n\n        board = bb.Board(\"33333111\")\n\n        # Display the resulting board.\n        # The printed layout shows how the tokens stack in each column.\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n\n    Example:\n        You can also initialize a board using a 2D array (list of lists):\n        ```python\n        import bitbully as bb\n\n        # Use a 6 x 7 list (rows x columns) to set up a specific board position manually.\n\n        # Each inner list represents a row of the Connect-4 grid.\n        # Convention:\n        #   - 0 \u2192 empty cell\n        #   - 1 \u2192 Player 1 token (yellow, X)\n        #   - 2 \u2192 Player 2 token (red, O)\n        #\n        # The top list corresponds to the *top row* (row index 5),\n        # and the bottom list corresponds to the *bottom row* (row index 0).\n        # This layout matches the typical visual display of the board.\n\n        board_array = [\n            [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n            [0, 0, 0, 1, 0, 0, 0],  # Row 4: Player 1 token in column 3\n            [0, 0, 0, 2, 0, 0, 0],  # Row 3: Player 2 token in column 3\n            [0, 2, 0, 1, 0, 0, 0],  # Row 2: tokens in columns 1 and 3\n            [0, 1, 0, 2, 0, 0, 0],  # Row 1: tokens in columns 1 and 3\n            [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom): tokens stacked lowest\n        ]\n\n        # Create a Board instance directly from the 2D list.\n        # This allows reconstructing arbitrary positions (e.g., from test data or saved states)\n        # without replaying the move sequence.\n        board = bb.Board(board_array)\n\n        # Display the resulting board state in text form.\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n\n    Example:\n        You can also initialize a board using a 2D (7 x 6) array with columns as inner lists:\n        ```python\n        import bitbully as bb\n\n        # Use a 7 x 6 list (columns x rows) to set up a specific board position manually.\n\n        # Each inner list represents a **column** of the Connect-4 board, from left (index 0)\n        # to right (index 6). Each column contains six entries \u2014 one for each row, from\n        # bottom (index 0) to top (index 5).\n        #\n        # Convention:\n        #   - 0 \u2192 empty cell\n        #   - 1 \u2192 Player 1 token (yellow, X)\n        #   - 2 \u2192 Player 2 token (red, O)\n        #\n        # This column-major layout matches the internal representation used by BitBully,\n        # where tokens are dropped into columns rather than filled row by row.\n\n        board_array = [\n            [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)\n            [2, 1, 2, 0, 0, 0],  # Column 1\n            [0, 0, 0, 0, 0, 0],  # Column 2\n            [1, 2, 1, 2, 1, 0],  # Column 3 (center)\n            [0, 0, 0, 0, 0, 0],  # Column 4\n            [0, 0, 0, 0, 0, 0],  # Column 5\n            [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)\n        ]\n\n        # Create a Board instance directly from the 2D list.\n        # This allows reconstructing any arbitrary position (e.g., test cases, saved games)\n        # without replaying all moves individually.\n        board = bb.Board(board_array)\n\n        # Display the resulting board.\n        # The text output shows tokens as they would appear in a real Connect-4 grid.\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n    \"\"\"\n    self._board = bitbully_core.BoardCore()\n    if init_with is not None and not self.reset_board(init_with):\n        raise ValueError(\n            \"Invalid initial board state provided. Check the examples in the docstring for valid formats.\"\n        )\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.__ne__","title":"<code>__ne__(value)</code>","text":"<p>Checks inequality between two Board instances.</p> <p>See the documentation for <code>bitbully.Board.__eq__</code> for details.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>object</code> <p>The other Board instance to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if both boards are not equal, False otherwise.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def __ne__(self, value: object) -&gt; bool:\n    \"\"\"Checks inequality between two Board instances.\n\n    See the documentation for [`bitbully.Board.__eq__`][src.bitbully.Board.__eq__] for details.\n\n    Args:\n        value (object): The other Board instance to compare against.\n\n    Returns:\n        bool: True if both boards are not equal, False otherwise.\n    \"\"\"\n    return not self.__eq__(value)\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the Board instance.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Returns a string representation of the Board instance.\"\"\"\n    return f\"{self._board}\"\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.__str__","title":"<code>__str__()</code>","text":"<p>Return a human-readable ASCII representation (same as to_string()).</p> <p>See the documentation for <code>bitbully.Board.to_string</code> for details.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a human-readable ASCII representation (same as to_string()).\n\n    See the documentation for [`bitbully.Board.to_string`][src.bitbully.Board.to_string] for details.\n    \"\"\"\n    return self.to_string()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.all_positions","title":"<code>all_positions(up_to_n_ply, exactly_n)</code>","text":"<p>Find all positions reachable from the current position up to a given ply.</p> <p>This is a high-level wrapper around <code>bitbully_core.BoardCore.allPositions</code>.</p> <p>Starting from the current board, it generates all positions that can be reached by playing additional moves such that the resulting position has:</p> <ul> <li>At most <code>up_to_n_ply</code> tokens on the board, if <code>exactly_n</code> is <code>False</code>.</li> <li>Exactly <code>up_to_n_ply</code> tokens on the board, if <code>exactly_n</code> is <code>True</code>.</li> </ul> Note <p>The number of tokens already present in the current position is taken into account. If <code>up_to_n_ply</code> is smaller than <code>self.count_tokens()</code>, the result is typically empty.</p> <p>This function can grow combinatorially with <code>up_to_n_ply</code> and the current position, so use it with care for large depths.</p> <p>Parameters:</p> Name Type Description Default <code>up_to_n_ply</code> <code>int</code> <p>The maximum total number of tokens (ply) for generated positions. Must be between 0 and 42 (inclusive).</p> required <code>exactly_n</code> <code>bool</code> <p>If <code>True</code>, only positions with exactly <code>up_to_n_ply</code> tokens are returned. If <code>False</code>, all positions with a token count between the current number of tokens and <code>up_to_n_ply</code> are included.</p> required <p>Returns:</p> Type Description <code>list[Board]</code> <p>list[Board]: A list of :class:<code>Board</code> instances representing all</p> <code>list[Board]</code> <p>reachable positions that satisfy the ply constraint.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>up_to_n_ply</code> is outside the range <code>[0, 42]</code>.</p> Example <p>Compute all positions at exactly 3 ply from the empty board:</p> <pre><code>import bitbully as bb\n\n# Start from an empty board.\nboard = bb.Board()\n\n# Generate all positions that contain exactly 3 tokens.\npositions = board.all_positions(3, exactly_n=True)\n\n# According to OEIS A212693, there are exactly 238 distinct\n# reachable positions with 3 played moves in standard Connect-4.\nassert len(positions) == 238\n</code></pre> <p>Reference:     - Number of distinct positions at ply n:       https://oeis.org/A212693</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def all_positions(self, up_to_n_ply: int, exactly_n: bool) -&gt; list[Board]:\n    \"\"\"Find all positions reachable from the current position up to a given ply.\n\n    This is a high-level wrapper around\n    `bitbully_core.BoardCore.allPositions`.\n\n    Starting from the **current** board, it generates all positions that can be\n    reached by playing additional moves such that the resulting position has:\n\n    - At most ``up_to_n_ply`` tokens on the board, if ``exactly_n`` is ``False``.\n    - Exactly ``up_to_n_ply`` tokens on the board, if ``exactly_n`` is ``True``.\n\n    Note:\n        The number of tokens already present in the current position is taken\n        into account. If ``up_to_n_ply`` is smaller than\n        ``self.count_tokens()``, the result is typically empty.\n\n        This function can grow combinatorially with ``up_to_n_ply`` and the\n        current position, so use it with care for large depths.\n\n    Args:\n        up_to_n_ply (int):\n            The maximum total number of tokens (ply) for generated positions.\n            Must be between 0 and 42 (inclusive).\n        exactly_n (bool):\n            If ``True``, only positions with exactly ``up_to_n_ply`` tokens\n            are returned. If ``False``, all positions with a token count\n            between the current number of tokens and ``up_to_n_ply`` are\n            included.\n\n    Returns:\n        list[Board]: A list of :class:`Board` instances representing all\n        reachable positions that satisfy the ply constraint.\n\n    Raises:\n        ValueError: If ``up_to_n_ply`` is outside the range ``[0, 42]``.\n\n    Example:\n        Compute all positions at exactly 3 ply from the empty board:\n\n        ```python\n        import bitbully as bb\n\n        # Start from an empty board.\n        board = bb.Board()\n\n        # Generate all positions that contain exactly 3 tokens.\n        positions = board.all_positions(3, exactly_n=True)\n\n        # According to OEIS A212693, there are exactly 238 distinct\n        # reachable positions with 3 played moves in standard Connect-4.\n        assert len(positions) == 238\n        ```\n\n        Reference:\n            - Number of distinct positions at ply *n*:\n              https://oeis.org/A212693\n\n    \"\"\"\n    if not 0 &lt;= up_to_n_ply &lt;= 42:\n        raise ValueError(f\"up_to_n_ply must be between 0 and 42 (inclusive), got {up_to_n_ply}.\")\n\n    # Delegate to the C++ core, which returns a list of BoardCore objects.\n    core_positions = self._board.allPositions(up_to_n_ply, exactly_n)\n\n    # Wrap each BoardCore in a high-level Board instance.\n    positions: list[Board] = []\n    for core_board in core_positions:\n        b = Board()  # start with an empty high-level Board\n        b._board = core_board  # replace its internal BoardCore\n        positions.append(b)\n\n    return positions\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.can_win_next","title":"<code>can_win_next(move=None)</code>","text":"<p>Checks if the current player can win in the next move.</p> <p>Parameters:</p> Name Type Description Default <code>move</code> <code>int | None</code> <p>Optional column to check for an immediate win. If None, checks all columns.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the current player can win next, False otherwise.</p> <p>See also: <code>bitbully.Board.has_win</code>.</p> Example <p><pre><code>import bitbully as bb\n\n# Create a board from a move string.\n# The string \"332311\" represents a short sequence of alternating moves\n# that results in a nearly winning position for Player 1 (yellow, X).\nboard = bb.Board(\"332311\")\n\n# Display the current board state (see below)\nprint(board)\n\n# Player 1 (yellow, X) \u2014 who is next to move \u2014 can win immediately\n# by placing a token in either column 0 or column 4.\nassert board.can_win_next(0)\nassert board.can_win_next(4)\n\n# However, playing in other columns does not result in an instant win.\nassert not board.can_win_next(2)\nassert not board.can_win_next(3)\n\n# You can also call `can_win_next()` without arguments to perform a general check.\n# It returns True if the current player has *any* winning move available.\nassert board.can_win_next()\n</code></pre> The board we created above looks like this: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  O  _  _  _\n_  O  _  O  _  _  _\n_  X  X  X  _  _  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def can_win_next(self, move: int | None = None) -&gt; bool:\n    \"\"\"Checks if the current player can win in the next move.\n\n    Args:\n        move (int | None): Optional column to check for an immediate win. If None, checks all columns.\n\n    Returns:\n        bool: True if the current player can win next, False otherwise.\n\n    See also: [`bitbully.Board.has_win`][src.bitbully.Board.has_win].\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        # Create a board from a move string.\n        # The string \"332311\" represents a short sequence of alternating moves\n        # that results in a nearly winning position for Player 1 (yellow, X).\n        board = bb.Board(\"332311\")\n\n        # Display the current board state (see below)\n        print(board)\n\n        # Player 1 (yellow, X) \u2014 who is next to move \u2014 can win immediately\n        # by placing a token in either column 0 or column 4.\n        assert board.can_win_next(0)\n        assert board.can_win_next(4)\n\n        # However, playing in other columns does not result in an instant win.\n        assert not board.can_win_next(2)\n        assert not board.can_win_next(3)\n\n        # You can also call `can_win_next()` without arguments to perform a general check.\n        # It returns True if the current player has *any* winning move available.\n        assert board.can_win_next()\n        ```\n        The board we created above looks like this:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  O  _  _  _\n        _  X  X  X  _  _  _\n        ```\n    \"\"\"\n    if move is None:\n        return self._board.canWin()\n    return bool(self._board.canWin(move))\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.copy","title":"<code>copy()</code>","text":"<p>Creates a copy of the current Board instance.</p> <p>The <code>copy()</code> method returns a new <code>Board</code> object that represents the same position as the original at the time of copying. Subsequent changes to one board do not affect the other \u2014 they are completely independent.</p> <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>A new Board instance that is a copy of the current one.</p> Example <p>Create a board, copy it, and verify that both represent the same position: <pre><code>import bitbully as bb\n\n# Create a board from a compact move string.\nboard = bb.Board(\"33333111\")\n\n# Create an independent copy of the current position.\nboard_copy = board.copy()\n\n# Both boards represent the same position and are considered equal.\nassert board == board_copy\nassert hash(board) == hash(board_copy)\nassert board.to_string() == board_copy.to_string()\n\n# Display the board state.\nprint(board)\n</code></pre> Expected output (both boards print the same position): <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Example <p>Modifying the copy does not affect the original: <pre><code>import bitbully as bb\n\nboard = bb.Board(\"33333111\")\n\n# Create a copy of the current position.\nboard_copy = board.copy()\n\n# Play an additional move on the copied board only.\nassert board_copy.play(0)  # Drop a token into the leftmost column.\n\n# Now the boards represent different positions.\nassert board != board_copy\n\n# The original board remains unchanged.\nprint(\"Original:\")\nprint(board)\n\nprint(\"Modified copy:\")\nprint(board_copy)\n</code></pre> Expected output: <pre><code>Original:\n\n_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n\nModified copy:\n\n_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\nX  O  _  X  _  _  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def copy(self) -&gt; Board:\n    \"\"\"Creates a copy of the current Board instance.\n\n    The `copy()` method returns a new `Board` object that represents the\n    *same position* as the original at the time of copying. Subsequent\n    changes to one board do **not** affect the other \u2014 they are completely\n    independent.\n\n    Returns:\n        Board: A new Board instance that is a copy of the current one.\n\n    Example:\n        Create a board, copy it, and verify that both represent the same position:\n        ```python\n        import bitbully as bb\n\n        # Create a board from a compact move string.\n        board = bb.Board(\"33333111\")\n\n        # Create an independent copy of the current position.\n        board_copy = board.copy()\n\n        # Both boards represent the same position and are considered equal.\n        assert board == board_copy\n        assert hash(board) == hash(board_copy)\n        assert board.to_string() == board_copy.to_string()\n\n        # Display the board state.\n        print(board)\n        ```\n        Expected output (both boards print the same position):\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n\n    Example:\n        Modifying the copy does not affect the original:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board(\"33333111\")\n\n        # Create a copy of the current position.\n        board_copy = board.copy()\n\n        # Play an additional move on the copied board only.\n        assert board_copy.play(0)  # Drop a token into the leftmost column.\n\n        # Now the boards represent different positions.\n        assert board != board_copy\n\n        # The original board remains unchanged.\n        print(\"Original:\")\n        print(board)\n\n        print(\"Modified copy:\")\n        print(board_copy)\n        ```\n        Expected output:\n        ```text\n        Original:\n\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n\n        Modified copy:\n\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        X  O  _  X  _  _  _\n        ```\n    \"\"\"\n    new_board = Board()\n    new_board._board = self._board.copy()\n    return new_board\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.count_tokens","title":"<code>count_tokens()</code>","text":"<p>Counts the total number of tokens currently placed on the board.</p> <p>This method simply returns how many moves have been played so far in the current position \u2014 that is, the number of occupied cells on the 7x6 grid.</p> <p>It does not distinguish between players; it only reports the total number of tokens, regardless of whether they belong to Player 1 or Player 2.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The total number of tokens on the board (between 0 and 42).</p> Example <p>Count tokens on an empty board: <pre><code>import bitbully as bb\n\nboard = bb.Board()  # No moves played yet.\nassert board.count_tokens() == 0\n\n# The board is completely empty.\nprint(board)\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n</code></pre></p> Example <p>Count tokens after a few moves: <pre><code>import bitbully as bb\n\n# Play three moves in the center column (index 3).\nboard = bb.Board()\nassert board.play([3, 3, 3])\n\n# Three tokens have been placed on the board.\nassert board.count_tokens() == 3\n\nprint(board)\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n</code></pre></p> Example <p>Relation to the length of a move sequence: <pre><code>import bitbully as bb\n\nmoves = \"33333111\"  # 8 moves in total\nboard = bb.Board(moves)\n\n# The number of tokens on the board always matches\n# the number of moves that have been played.\n# (as long as the input was valid)\nassert board.count_tokens() == len(moves)\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def count_tokens(self) -&gt; int:\n    \"\"\"Counts the total number of tokens currently placed on the board.\n\n    This method simply returns how many moves have been played so far in the\n    current position \u2014 that is, the number of occupied cells on the 7x6 grid.\n\n    It does **not** distinguish between players; it only reports the total\n    number of tokens, regardless of whether they belong to Player 1 or Player 2.\n\n    Returns:\n        int: The total number of tokens on the board (between 0 and 42).\n\n    Example:\n        Count tokens on an empty board:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()  # No moves played yet.\n        assert board.count_tokens() == 0\n\n        # The board is completely empty.\n        print(board)\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        ```\n\n    Example:\n        Count tokens after a few moves:\n        ```python\n        import bitbully as bb\n\n        # Play three moves in the center column (index 3).\n        board = bb.Board()\n        assert board.play([3, 3, 3])\n\n        # Three tokens have been placed on the board.\n        assert board.count_tokens() == 3\n\n        print(board)\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        ```\n\n    Example:\n        Relation to the length of a move sequence:\n        ```python\n        import bitbully as bb\n\n        moves = \"33333111\"  # 8 moves in total\n        board = bb.Board(moves)\n\n        # The number of tokens on the board always matches\n        # the number of moves that have been played.\n        # (as long as the input was valid)\n        assert board.count_tokens() == len(moves)\n        ```\n    \"\"\"\n    return self._board.countTokens()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.from_array","title":"<code>from_array(arr)</code>  <code>classmethod</code>","text":"<p>Creates a board directly from a 2D array representation.</p> <p>This is a convenience wrapper around the main constructor <code>bitbully.Board.__init__</code> and accepts the same array formats:</p> <ul> <li>Row-major: 6 x 7 (<code>[row][column]</code>), top row first.</li> <li>Column-major: 7 x 6 (<code>[column][row]</code>), left column first.</li> </ul> <p>Values must follow the usual convention:</p> <ul> <li><code>0</code> \u2192 empty cell</li> <li><code>1</code> \u2192 Player 1 token (yellow, <code>X</code>)</li> <li><code>2</code> \u2192 Player 2 token (red, <code>O</code>)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Sequence[Sequence[int]]</code> <p>A 2D array describing the board state, either in row-major or column-major layout. See the examples in <code>bitbully.Board.__init__</code> for details.</p> required <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>A new <code>Board</code> instance representing the given layout.</p> Example <p>Using a 6 x 7 row-major layout: <pre><code>import bitbully as bb\n\nboard_array = [\n    [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n    [0, 0, 0, 1, 0, 0, 0],  # Row 4\n    [0, 0, 0, 2, 0, 0, 0],  # Row 3\n    [0, 2, 0, 1, 0, 0, 0],  # Row 2\n    [0, 1, 0, 2, 0, 0, 0],  # Row 1\n    [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom)\n]\n\nboard = bb.Board.from_array(board_array)\nprint(board)\n</code></pre></p> Example <p>Using a 7 x 6 column-major layout: <pre><code>import bitbully as bb\n\nboard_array = [\n    [0, 0, 0, 0, 0, 0],  # Column 0\n    [2, 1, 2, 1, 0, 0],  # Column 1\n    [0, 0, 0, 0, 0, 0],  # Column 2\n    [1, 2, 1, 2, 1, 0],  # Column 3\n    [0, 0, 0, 0, 0, 0],  # Column 4\n    [2, 1, 2, 0, 0, 0],  # Column 5\n    [0, 0, 0, 0, 0, 0],  # Column 6\n]\n\nboard = bb.Board.from_array(board_array)\n\n# Round-trip via to_array:\nassert board.to_array() == board_array\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>@classmethod\ndef from_array(cls, arr: Sequence[Sequence[int]]) -&gt; Board:\n    \"\"\"Creates a board directly from a 2D array representation.\n\n    This is a convenience wrapper around the main constructor\n    [`bitbully.Board.__init__`][src.bitbully.Board.__init__]\n    and accepts the same array formats:\n\n    - **Row-major**: 6 x 7 (``[row][column]``), top row first.\n    - **Column-major**: 7 x 6 (``[column][row]``), left column first.\n\n    Values must follow the usual convention:\n\n    - ``0`` \u2192 empty cell\n    - ``1`` \u2192 Player 1 token (yellow, ``X``)\n    - ``2`` \u2192 Player 2 token (red, ``O``)\n\n    Args:\n        arr (Sequence[Sequence[int]]):\n            A 2D array describing the board state, either in row-major or\n            column-major layout. See the examples in\n            [`bitbully.Board.__init__`][src.bitbully.Board.__init__] for details.\n\n    Returns:\n        Board:\n            A new `Board` instance representing the given layout.\n\n    Example:\n        Using a 6 x 7 row-major layout:\n        ```python\n        import bitbully as bb\n\n        board_array = [\n            [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n            [0, 0, 0, 1, 0, 0, 0],  # Row 4\n            [0, 0, 0, 2, 0, 0, 0],  # Row 3\n            [0, 2, 0, 1, 0, 0, 0],  # Row 2\n            [0, 1, 0, 2, 0, 0, 0],  # Row 1\n            [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom)\n        ]\n\n        board = bb.Board.from_array(board_array)\n        print(board)\n        ```\n\n    Example:\n        Using a 7 x 6 column-major layout:\n        ```python\n        import bitbully as bb\n\n        board_array = [\n            [0, 0, 0, 0, 0, 0],  # Column 0\n            [2, 1, 2, 1, 0, 0],  # Column 1\n            [0, 0, 0, 0, 0, 0],  # Column 2\n            [1, 2, 1, 2, 1, 0],  # Column 3\n            [0, 0, 0, 0, 0, 0],  # Column 4\n            [2, 1, 2, 0, 0, 0],  # Column 5\n            [0, 0, 0, 0, 0, 0],  # Column 6\n        ]\n\n        board = bb.Board.from_array(board_array)\n\n        # Round-trip via to_array:\n        assert board.to_array() == board_array\n        ```\n    \"\"\"\n    return cls(arr)\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.from_moves","title":"<code>from_moves(moves)</code>  <code>classmethod</code>","text":"<p>Creates a board by replaying a sequence of moves from the empty position.</p> <p>This is a convenience constructor around <code>bitbully.Board.play</code>. It starts from an empty board and applies the given move sequence, assuming it is legal (no out-of-range columns, no moves in full columns, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>moves</code> <code>Sequence[int] | str</code> <p>The move sequence to replay from the starting position. Accepts:</p> <ul> <li>A sequence of integers (e.g. <code>[3, 3, 3, 1]</code>)</li> <li>A string of digits (e.g. <code>\"3331\"</code>)</li> </ul> <p>Each value represents a column index (0-6). Players alternate automatically between moves.</p> required <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>A new <code>Board</code> instance representing the final position after all moves have been applied.</p> Example <pre><code>import bitbully as bb\n\n# Create a position directly from a compact move string.\nboard = bb.Board.from_moves(\"33333111\")\n\n# Equivalent to:\n# board = bb.Board()\n# assert board.play(\"33333111\")\n\nprint(board)\nassert board.count_tokens() == 8\nassert not board.has_win()\n</code></pre> Source code in <code>src/bitbully/board.py</code> <pre><code>@classmethod\ndef from_moves(cls, moves: Sequence[int] | str) -&gt; Board:\n    \"\"\"Creates a board by replaying a sequence of moves from the empty position.\n\n    This is a convenience constructor around [`bitbully.Board.play`][src.bitbully.Board.play].\n    It starts from an empty board and applies the given move sequence, assuming\n    it is **legal** (no out-of-range columns, no moves in full columns, etc.).\n\n    Args:\n        moves (Sequence[int] | str):\n            The move sequence to replay from the starting position. Accepts:\n\n            - A sequence of integers (e.g. ``[3, 3, 3, 1]``)\n            - A string of digits (e.g. ``\"3331\"``)\n\n            Each value represents a column index (0-6). Players alternate\n            automatically between moves.\n\n    Returns:\n        Board:\n            A new `Board` instance representing the final position\n            after all moves have been applied.\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        # Create a position directly from a compact move string.\n        board = bb.Board.from_moves(\"33333111\")\n\n        # Equivalent to:\n        # board = bb.Board()\n        # assert board.play(\"33333111\")\n\n        print(board)\n        assert board.count_tokens() == 8\n        assert not board.has_win()\n        ```\n    \"\"\"\n    board = cls()\n    assert board.play(moves)\n    return board\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.has_win","title":"<code>has_win()</code>","text":"<p>Checks if the current player has a winning position.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the current player has a winning position (4-in-a-row), False otherwise.</p> <p>Unlike <code>can_win_next()</code>, which checks whether the current player could win on their next move, the <code>has_win()</code> method determines whether a winning condition already exists on the board. This method is typically used right after a move to verify whether the game has been won.</p> <p>See also: <code>bitbully.Board.can_win_next</code>.</p> Example <p><pre><code>import bitbully as bb\n\n# Initialize a board from a move sequence.\n# The string \"332311\" represents a position where Player 1 (yellow, X)\n# is one move away from winning.\nboard = bb.Board(\"332311\")\n\n# At this stage, Player 1 has not yet won, but can win immediately\n# by placing a token in either column 0 or column 4.\nassert not board.has_win()\nassert board.can_win_next(0)  # Check column 0\nassert board.can_win_next(4)  # Check column 4\nassert board.can_win_next()  # General check (any winning move)\n\n# Simulate Player 1 playing in column 4 \u2014 this completes\n# a horizontal line of four tokens and wins the game.\nassert board.play(4)\n\n# Display the updated board to visualize the winning position.\nprint(board)\n\n# The board now contains a winning configuration:\n# Player 1 (yellow, X) has achieved a Connect-4.\nassert board.has_win()\n</code></pre> Board from above, expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  O  _  _  _\n_  O  _  O  _  _  _\n_  X  X  X  X  _  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def has_win(self) -&gt; bool:\n    \"\"\"Checks if the current player has a winning position.\n\n    Returns:\n        bool: True if the current player has a winning position (4-in-a-row), False otherwise.\n\n    Unlike `can_win_next()`, which checks whether the current player *could* win\n    on their next move, the `has_win()` method determines whether a winning\n    condition already exists on the board.\n    This method is typically used right after a move to verify whether the game\n    has been won.\n\n    See also: [`bitbully.Board.can_win_next`][src.bitbully.Board.can_win_next].\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        # Initialize a board from a move sequence.\n        # The string \"332311\" represents a position where Player 1 (yellow, X)\n        # is one move away from winning.\n        board = bb.Board(\"332311\")\n\n        # At this stage, Player 1 has not yet won, but can win immediately\n        # by placing a token in either column 0 or column 4.\n        assert not board.has_win()\n        assert board.can_win_next(0)  # Check column 0\n        assert board.can_win_next(4)  # Check column 4\n        assert board.can_win_next()  # General check (any winning move)\n\n        # Simulate Player 1 playing in column 4 \u2014 this completes\n        # a horizontal line of four tokens and wins the game.\n        assert board.play(4)\n\n        # Display the updated board to visualize the winning position.\n        print(board)\n\n        # The board now contains a winning configuration:\n        # Player 1 (yellow, X) has achieved a Connect-4.\n        assert board.has_win()\n        ```\n        Board from above, expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  O  _  _  _\n        _  X  X  X  X  _  _\n        ```\n    \"\"\"\n    return self._board.hasWin()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.is_full","title":"<code>is_full()</code>","text":"<p>Checks whether the board has any empty cells left.</p> <p>A Connect Four board has 42 cells in total (7 columns x 6 rows). This method returns <code>True</code> if all cells are occupied, i.e. when  <code>bitbully.Board.moves_left</code> returns <code>0</code>.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the board is completely full (no more legal moves possible), otherwise <code>False</code>.</p> Example <pre><code>import bitbully as bb\n\nboard = bb.Board()\nassert not board.is_full()\nassert board.moves_left() == 42\nassert board.count_tokens() == 0\n\n# Fill the board column by column.\nfor _ in range(6):\n    assert board.play(\"0123456\")  # one token per column, per row\n\n# Now every cell is occupied.\nassert board.is_full()\nassert board.moves_left() == 0\nassert board.count_tokens() == 42\n</code></pre> Source code in <code>src/bitbully/board.py</code> <pre><code>def is_full(self) -&gt; bool:\n    \"\"\"Checks whether the board has any empty cells left.\n\n    A Connect Four board has 42 cells in total (7 columns x 6 rows).\n    This method returns ``True`` if **all** cells are occupied, i.e.\n    when  [`bitbully.Board.moves_left`][src.bitbully.Board.moves_left] returns ``0``.\n\n    Returns:\n        bool:\n            ``True`` if the board is completely full\n            (no more legal moves possible), otherwise ``False``.\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        assert not board.is_full()\n        assert board.moves_left() == 42\n        assert board.count_tokens() == 0\n\n        # Fill the board column by column.\n        for _ in range(6):\n            assert board.play(\"0123456\")  # one token per column, per row\n\n        # Now every cell is occupied.\n        assert board.is_full()\n        assert board.moves_left() == 0\n        assert board.count_tokens() == 42\n        ```\n    \"\"\"\n    return self.moves_left() == 0\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.is_game_over","title":"<code>is_game_over()</code>","text":"<p>Checks whether the game has ended (win or draw).</p> <p>A game of Connect Four is considered over if:</p> <ul> <li>One of the players has a winning position   (see <code>bitbully.Board.has_win</code>), or</li> <li>The board is completely full and no further moves can be played   (see <code>bitbully.Board.is_full</code>).</li> </ul> <p>This method does not indicate who won; for that, use <code>bitbully.Board.winner</code>.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the game is over (win or draw), otherwise <code>False</code>.</p> Example <p>Game over by a win: <pre><code>import bitbully as bb\n\n# Player 1 (X) wins horizontally on the bottom row.\nboard = bb.Board()\nassert board.play(\"0101010\")\n\nassert board.has_win()\nassert board.is_game_over()\nassert board.winner() == 1\n</code></pre></p> Example <p>Game over by a draw (full board, no winner): <pre><code>import bitbully as bb\n\nboard, _ = bb.Board.random_board(42, forbid_direct_win=False)\n\nassert board.is_full()\nassert not board.has_win()\nassert board.is_game_over()\nassert board.winner() is None\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def is_game_over(self) -&gt; bool:\n    \"\"\"Checks whether the game has ended (win or draw).\n\n    A game of Connect Four is considered **over** if:\n\n    - One of the players has a winning position\n      (see [`bitbully.Board.has_win`][src.bitbully.Board.has_win]), **or**\n    - The board is completely full and no further moves can be played\n      (see [`bitbully.Board.is_full`][src.bitbully.Board.is_full]).\n\n    This method does **not** indicate *who* won; for that, use\n    [`bitbully.Board.winner`][src.bitbully.Board.winner].\n\n    Returns:\n        bool:\n            ``True`` if the game is over (win or draw), otherwise ``False``.\n\n    Example:\n        Game over by a win:\n        ```python\n        import bitbully as bb\n\n        # Player 1 (X) wins horizontally on the bottom row.\n        board = bb.Board()\n        assert board.play(\"0101010\")\n\n        assert board.has_win()\n        assert board.is_game_over()\n        assert board.winner() == 1\n        ```\n\n    Example:\n        Game over by a draw (full board, no winner):\n        ```python\n        import bitbully as bb\n\n        board, _ = bb.Board.random_board(42, forbid_direct_win=False)\n\n        assert board.is_full()\n        assert not board.has_win()\n        assert board.is_game_over()\n        assert board.winner() is None\n        ```\n    \"\"\"\n    return self.has_win() or self.is_full()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.is_legal_move","title":"<code>is_legal_move(move)</code>","text":"<p>Checks if a move (column) is legal in the current position.</p> <p>A move is considered legal if:</p> <ul> <li>The column index is within the valid range (0-6), and</li> <li>The column is not full (i.e. it still has at least one empty cell).</li> </ul> <p>This method does not check for tactical consequences such as leaving an immediate win to the opponent, nor does it stop being usable once a player has already won. It purely validates whether a token can be dropped into the given column according to the basic rules of Connect Four. You have to check for wins separately using <code>bitbully.Board.has_win</code>.</p> <p>Parameters:</p> Name Type Description Default <code>move</code> <code>int</code> <p>The column index (0-6) to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the move is legal, False otherwise.</p> Example <p>All moves are legal on an empty board: <pre><code>import bitbully as bb\n\nboard = bb.Board()  # Empty 7x6 board\n\n# Every column index from 0 to 6 is a valid move.\nfor col in range(7):\n    assert board.is_legal_move(col)\n\n# Out-of-range indices are always illegal.\nassert not board.is_legal_move(-1)\nassert not board.is_legal_move(7)\n</code></pre></p> Example <p>Detecting an illegal move in a full column: <pre><code>import bitbully as bb\n\n# Fill the center column (index 3) with six tokens.\nboard = bb.Board()\nassert board.play([3, 3, 3, 3, 3, 3])\n\n# The center column is now full, so another move in column 3 is illegal.\nassert not board.is_legal_move(3)\n\n# Other columns are still available (as long as they are not full).\nassert board.is_legal_move(0)\nassert board.is_legal_move(6)\n\nprint(board)\n</code></pre> Expected output: <pre><code>_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n</code></pre></p> Example <p>This function only checks legality, not for situations where a player has won: <pre><code>import bitbully as bb\n\n# Player 1 (yellow, X) wins  the game.\nboard = bb.Board()\nassert board.play(\"1122334\")\n\n# Even though Player 1 has already won, moves in non-full columns are still legal.\nfor col in range(7):\n    assert board.is_legal_move(col)\n\nprint(board)\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  O  O  O  _  _  _\n_  X  X  X  X  _  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def is_legal_move(self, move: int) -&gt; bool:\n    \"\"\"Checks if a move (column) is legal in the current position.\n\n    A move is considered *legal* if:\n\n    - The column index is within the valid range (0-6), **and**\n    - The column is **not full** (i.e. it still has at least one empty cell).\n\n    This method does **not** check for tactical consequences such as\n    leaving an immediate win to the opponent, nor does it stop being\n    usable once a player has already won. It purely validates whether a\n    token can be dropped into the given column according to the basic\n    rules of Connect Four. You have to check for wins separately using\n    [`bitbully.Board.has_win`][src.bitbully.Board.has_win].\n\n\n    Args:\n        move (int): The column index (0-6) to check.\n\n    Returns:\n        bool: True if the move is legal, False otherwise.\n\n    Example:\n        All moves are legal on an empty board:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()  # Empty 7x6 board\n\n        # Every column index from 0 to 6 is a valid move.\n        for col in range(7):\n            assert board.is_legal_move(col)\n\n        # Out-of-range indices are always illegal.\n        assert not board.is_legal_move(-1)\n        assert not board.is_legal_move(7)\n        ```\n\n    Example:\n        Detecting an illegal move in a full column:\n        ```python\n        import bitbully as bb\n\n        # Fill the center column (index 3) with six tokens.\n        board = bb.Board()\n        assert board.play([3, 3, 3, 3, 3, 3])\n\n        # The center column is now full, so another move in column 3 is illegal.\n        assert not board.is_legal_move(3)\n\n        # Other columns are still available (as long as they are not full).\n        assert board.is_legal_move(0)\n        assert board.is_legal_move(6)\n\n        print(board)\n        ```\n        Expected output:\n        ```text\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        ```\n\n    Example:\n        This function only checks legality, not for situations where a player has won:\n        ```python\n        import bitbully as bb\n\n        # Player 1 (yellow, X) wins  the game.\n        board = bb.Board()\n        assert board.play(\"1122334\")\n\n        # Even though Player 1 has already won, moves in non-full columns are still legal.\n        for col in range(7):\n            assert board.is_legal_move(col)\n\n        print(board)\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  O  O  O  _  _  _\n        _  X  X  X  X  _  _\n        ```\n    \"\"\"\n    return self._board.isLegalMove(move)\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.legal_moves","title":"<code>legal_moves(non_losing=False)</code>","text":"<p>Returns a list of legal moves (columns) that can be played.</p> <p>Parameters:</p> Name Type Description Default <code>non_losing</code> <code>bool</code> <p>If True, only return moves that do not allow the opponent to win immediately.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: A list of column indices (0-6) where a move can be played.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented yet.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def legal_moves(self, non_losing: bool = False) -&gt; list[int]:\n    \"\"\"Returns a list of legal moves (columns) that can be played.\n\n    Args:\n        non_losing (bool): If True, only return moves that do not allow the\n          opponent to win immediately.\n\n    Returns:\n        list[int]: A list of column indices (0-6) where a move can be played.\n\n    Raises:\n        NotImplementedError: If the method is not implemented yet.\n    \"\"\"\n    # TODO: Implement in C++?\n    raise NotImplementedError(\"legal_moves is not implemented yet.\")\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.mirror","title":"<code>mirror()</code>","text":"<p>Returns a new Board instance that is the mirror image of the current board.</p> <p>This method reflects the board horizontally around its vertical center column: - Column 0 &lt;-&gt; Column 6 - Column 1 &lt;-&gt; Column 5 - Column 2 &lt;-&gt; Column 4 - Column 3 stays in the center</p> <p>The player to move is not changed - only the spatial arrangement of the tokens is mirrored. The original board remains unchanged; <code>mirror()</code> always returns a new <code>Board</code> instance.</p> <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>A new Board instance that is the mirror image of the current one.</p> Example <p>Mirroring a simple asymmetric position: <pre><code>import bitbully as bb\n\n# Play four moves along the bottom row.\nboard = bb.Board()\nassert board.play(\"0123\")  # Columns: 0, 1, 2, 3\n\n# Create a mirrored copy of the board.\nmirrored = board.mirror()\n\nprint(\"Original:\")\nprint(board)\n\nprint(\"Mirrored:\")\nprint(mirrored)\n</code></pre></p> <p>Expected output: <pre><code>Original:\n\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\nX  O  X  O  _  _  _\n\nMirrored:\n\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  O  X  O  X\n</code></pre></p> Example <p>Mirroring a position that is already symmetric: <pre><code>import bitbully as bb\n\n# Central symmetry: one token in each outer column and in the center.\nboard = bb.Board([1, 3, 5])\n\nmirrored = board.mirror()\n\n# The mirrored position is identical to the original.\nassert board == mirrored\nassert hash(board) == hash(mirrored)\n\nprint(board)\n</code></pre>  Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  X  _  O  _  X  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def mirror(self) -&gt; Board:\n    \"\"\"Returns a new Board instance that is the mirror image of the current board.\n\n    This method reflects the board **horizontally** around its vertical center column:\n    - Column 0 &lt;-&gt; Column 6\n    - Column 1 &lt;-&gt; Column 5\n    - Column 2 &lt;-&gt; Column 4\n    - Column 3 stays in the center\n\n    The player to move is not changed - only the spatial\n    arrangement of the tokens is mirrored. The original board remains unchanged;\n    `mirror()` always returns a **new** `Board` instance.\n\n    Returns:\n        Board: A new Board instance that is the mirror image of the current one.\n\n    Example:\n        Mirroring a simple asymmetric position:\n        ```python\n        import bitbully as bb\n\n        # Play four moves along the bottom row.\n        board = bb.Board()\n        assert board.play(\"0123\")  # Columns: 0, 1, 2, 3\n\n        # Create a mirrored copy of the board.\n        mirrored = board.mirror()\n\n        print(\"Original:\")\n        print(board)\n\n        print(\"Mirrored:\")\n        print(mirrored)\n        ```\n\n        Expected output:\n        ```text\n        Original:\n\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        X  O  X  O  _  _  _\n\n        Mirrored:\n\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  O  X  O  X\n        ```\n\n    Example:\n        Mirroring a position that is already symmetric:\n        ```python\n        import bitbully as bb\n\n        # Central symmetry: one token in each outer column and in the center.\n        board = bb.Board([1, 3, 5])\n\n        mirrored = board.mirror()\n\n        # The mirrored position is identical to the original.\n        assert board == mirrored\n        assert hash(board) == hash(mirrored)\n\n        print(board)\n        ```\n         Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  X  _  O  _  X  _\n        ```\n    \"\"\"\n    new_board = Board()\n    new_board._board = self._board.mirror()\n    return new_board\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.moves_left","title":"<code>moves_left()</code>","text":"<p>Returns the number of moves left until the board is full.</p> <p>This is simply the number of empty cells remaining on the 7x6 grid. On an empty board there are 42 free cells, so:</p> <ul> <li>At the start of the game: <code>moves_left() == 42</code></li> <li>After <code>n</code> valid moves: <code>moves_left() == 42 - n</code></li> <li>On a completely full board: <code>moves_left() == 0</code></li> </ul> <p>This method is equivalent to: <pre><code>42 - board.count_tokens()\n</code></pre> but implemented efficiently in the underlying C++ core.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of moves left (0-42).</p> Example <p>Moves left on an empty board: <pre><code>import bitbully as bb\n\nboard = bb.Board()  # No tokens placed yet.\nassert board.moves_left() == 42\nassert board.count_tokens() == 0\n</code></pre></p> Example <p>Relation to the number of moves played: <pre><code>import bitbully as bb\n\n# Play five moves in various columns.\nmoves = [3, 3, 1, 4, 6]\nboard = bb.Board()\nassert board.play(moves)\n\n# Five tokens have been placed, so 42 - 5 = 37 moves remain.\nassert board.count_tokens() == 5\nassert board.moves_left() == 37\nassert board.moves_left() + board.count_tokens() == 42\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def moves_left(self) -&gt; int:\n    \"\"\"Returns the number of moves left until the board is full.\n\n    This is simply the number of *empty* cells remaining on the 7x6 grid.\n    On an empty board there are 42 free cells, so:\n\n    - At the start of the game: `moves_left() == 42`\n    - After `n` valid moves: `moves_left() == 42 - n`\n    - On a completely full board: `moves_left() == 0`\n\n    This method is equivalent to:\n    ```\n    42 - board.count_tokens()\n    ```\n    but implemented efficiently in the underlying C++ core.\n\n    Returns:\n        int: The number of moves left (0-42).\n\n    Example:\n        Moves left on an empty board:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()  # No tokens placed yet.\n        assert board.moves_left() == 42\n        assert board.count_tokens() == 0\n        ```\n\n    Example:\n        Relation to the number of moves played:\n        ```python\n        import bitbully as bb\n\n        # Play five moves in various columns.\n        moves = [3, 3, 1, 4, 6]\n        board = bb.Board()\n        assert board.play(moves)\n\n        # Five tokens have been placed, so 42 - 5 = 37 moves remain.\n        assert board.count_tokens() == 5\n        assert board.moves_left() == 37\n        assert board.moves_left() + board.count_tokens() == 42\n        ```\n    \"\"\"\n    return self._board.movesLeft()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.play","title":"<code>play(move)</code>","text":"<p>Plays one or more moves for the current player.</p> <p>The method updates the internal board state by dropping tokens into the specified columns. Input can be: - a single integer (column index 0 to 6), - an iterable sequence of integers (e.g., <code>[3, 1, 3]</code> or <code>range(7)</code>), - or a string of digits (e.g., <code>\"33333111\"</code>) representing the move order.</p> <p>Parameters:</p> Name Type Description Default <code>move</code> <code>int | Sequence[int] | str</code> <p>The column index or sequence of column indices where tokens should be placed.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the move was played successfully, False if the move was illegal.</p> Example <p>Play a sequence of moves into the center column (column index 3): <pre><code>import bitbully as bb\n\nboard = bb.Board()\nassert board.play([3, 3, 3])  # returns True on successful move\nboard\n</code></pre></p> <p>Expected output:</p> <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n</code></pre> Example <p>Play a sequence of moves across all columns: <pre><code>import bitbully as bb\n\nboard = bb.Board()\nassert board.play(range(7))  # returns True on successful move\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\nX  O  X  O  X  O  X\n</code></pre></p> Example <p>Play a sequence using a string: <pre><code>import bitbully as bb\n\nboard = bb.Board()\nassert board.play(\"33333111\")  # returns True on successful move\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def play(self, move: int | Sequence[int] | str) -&gt; bool:\n    \"\"\"Plays one or more moves for the current player.\n\n    The method updates the internal board state by dropping tokens\n    into the specified columns. Input can be:\n    - a single integer (column index 0 to 6),\n    - an iterable sequence of integers (e.g., `[3, 1, 3]` or `range(7)`),\n    - or a string of digits (e.g., `\"33333111\"`) representing the move order.\n\n    Args:\n        move (int | Sequence[int] | str):\n            The column index or sequence of column indices where tokens should be placed.\n\n    Returns:\n        bool: True if the move was played successfully, False if the move was illegal.\n\n\n    Example:\n        Play a sequence of moves into the center column (column index 3):\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        assert board.play([3, 3, 3])  # returns True on successful move\n        board\n        ```\n\n        Expected output:\n\n        ```\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        ```\n\n    Example:\n        Play a sequence of moves across all columns:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        assert board.play(range(7))  # returns True on successful move\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        X  O  X  O  X  O  X\n        ```\n\n    Example:\n        Play a sequence using a string:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        assert board.play(\"33333111\")  # returns True on successful move\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n    \"\"\"\n    # Case 1: string -&gt; pass through directly\n    if isinstance(move, str):\n        return self._board.play(move)\n\n    # Case 2: int -&gt; pass through directly\n    if isinstance(move, int):\n        return self._board.play(move)\n\n    # From here on, move is a Sequence[...] (but not str or int).\n    move_list: list[int] = [int(v) for v in cast(Sequence[Any], move)]\n    return self._board.play(move_list)\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.play_on_copy","title":"<code>play_on_copy(move)</code>","text":"<p>Return a new board with the given move applied, leaving the current board unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>move</code> <code>int</code> <p>The column index (0-6) in which to play the move.</p> required <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>A new Board instance representing the position after the move.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the move is illegal (e.g. column is full or out of range).</p> Example <pre><code>import bitbully as bb\n\nboard = bb.Board(\"333\")  # Some existing position\nnew_board = board.play_on_copy(4)\n\n# The original board is unchanged.\nassert board.count_tokens() == 3\n\n# The returned board includes the new move.\nassert new_board.count_tokens() == 4\nassert new_board != board\n</code></pre> Source code in <code>src/bitbully/board.py</code> <pre><code>def play_on_copy(self, move: int) -&gt; Board:\n    \"\"\"Return a new board with the given move applied, leaving the current board unchanged.\n\n    Args:\n        move (int):\n            The column index (0-6) in which to play the move.\n\n    Returns:\n        Board:\n            A new Board instance representing the position after the move.\n\n    Raises:\n        ValueError: If the move is illegal (e.g. column is full or out of range).\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board(\"333\")  # Some existing position\n        new_board = board.play_on_copy(4)\n\n        # The original board is unchanged.\n        assert board.count_tokens() == 3\n\n        # The returned board includes the new move.\n        assert new_board.count_tokens() == 4\n        assert new_board != board\n        ```\n    \"\"\"\n    # Delegate to C++ (this returns a BoardCore instance)\n    core_new = self._board.playMoveOnCopy(move)\n\n    if core_new is None:\n        # C++ signals illegal move by returning a null board\n        raise ValueError(f\"Illegal move: column {move}\")\n\n    # Wrap in a new high-level Board object\n    new_board = Board()\n    new_board._board = core_new\n    return new_board\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.random_board","title":"<code>random_board(n_ply, forbid_direct_win)</code>  <code>staticmethod</code>","text":"<p>Generates a random board state by playing a specified number of random moves.</p> <p>If <code>forbid_direct_win</code> is <code>True</code>, the generated position is guaranteed not to contain an immediate winning move for the player to move.</p> <p>Parameters:</p> Name Type Description Default <code>n_ply</code> <code>int</code> <p>Number of random moves to simulate (0-42).</p> required <code>forbid_direct_win</code> <code>bool</code> <p>If <code>True</code>, ensures the resulting board has no immediate winning move.</p> required <p>Returns:</p> Type Description <code>tuple[Board, list[int]]</code> <p>tuple[Board, list[int]]: A pair <code>(board, moves)</code> where <code>board</code> is the generated position and <code>moves</code> are the exact random moves performed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>n_ply</code> is outside the valid range [0, 42].</p> Example <p>Basic usage: <pre><code>import bitbully as bb\n\nboard, moves = bb.Board.random_board(10, forbid_direct_win=True)\n\nprint(\"Moves:\", moves)\nprint(\"Board:\")\nprint(board)\n\n# The move list must match the requested ply.\nassert len(moves) == 10\n\n# No immediate winning move when forbid_direct_win=True.\nassert not board.can_win_next()\n</code></pre></p> Example <p>Using random boards in tests or simulations: <pre><code>import bitbully as bb\n\n# Generate 50 random 10-ply positions.\nfor _ in range(50):\n    board, moves = bb.Board.random_board(10, forbid_direct_win=True)\n    assert len(moves) == 10\n    assert not board.has_win()  # Game should not be over\n    assert board.count_tokens() == 10  # All generated boards contain exactly 10 tokens\n    assert not board.can_win_next()  # Since `forbid_direct_win=True`, no immediate threat\n</code></pre></p> Example <p>Reconstructing the board manually from the move list: <pre><code>import bitbully as bb\n\nb1, moves = bb.Board.random_board(8, forbid_direct_win=True)\n\n# Recreate the board using the move sequence:\nb2 = bb.Board(moves)\n\nassert b1 == b2\nassert b1.to_string() == b2.to_string()\nassert b1.uid() == b2.uid()\n</code></pre></p> Example <p>Ensure randomness by generating many distinct sequences: <pre><code>import bitbully as bb\n\nseen = set()\nfor _ in range(20):\n    _, moves = bb.Board.random_board(5, False)\n    seen.add(tuple(moves))\n\n# Very likely to see more than one unique sequence.\nassert len(seen) &gt; 1\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>@staticmethod\ndef random_board(n_ply: int, forbid_direct_win: bool) -&gt; tuple[Board, list[int]]:\n    \"\"\"Generates a random board state by playing a specified number of random moves.\n\n    If ``forbid_direct_win`` is ``True``, the generated position is guaranteed\n    **not** to contain an immediate winning move for the player to move.\n\n    Args:\n        n_ply (int):\n            Number of random moves to simulate (0-42).\n        forbid_direct_win (bool):\n            If ``True``, ensures the resulting board has **no immediate winning move**.\n\n    Returns:\n        tuple[Board, list[int]]:\n            A pair ``(board, moves)`` where ``board`` is the generated position\n            and ``moves`` are the exact random moves performed.\n\n    Raises:\n        ValueError: If `n_ply` is outside the valid range [0, 42].\n\n    Example:\n        Basic usage:\n        ```python\n        import bitbully as bb\n\n        board, moves = bb.Board.random_board(10, forbid_direct_win=True)\n\n        print(\"Moves:\", moves)\n        print(\"Board:\")\n        print(board)\n\n        # The move list must match the requested ply.\n        assert len(moves) == 10\n\n        # No immediate winning move when forbid_direct_win=True.\n        assert not board.can_win_next()\n        ```\n\n    Example:\n        Using random boards in tests or simulations:\n        ```python\n        import bitbully as bb\n\n        # Generate 50 random 10-ply positions.\n        for _ in range(50):\n            board, moves = bb.Board.random_board(10, forbid_direct_win=True)\n            assert len(moves) == 10\n            assert not board.has_win()  # Game should not be over\n            assert board.count_tokens() == 10  # All generated boards contain exactly 10 tokens\n            assert not board.can_win_next()  # Since `forbid_direct_win=True`, no immediate threat\n        ```\n\n    Example:\n        Reconstructing the board manually from the move list:\n        ```python\n        import bitbully as bb\n\n        b1, moves = bb.Board.random_board(8, forbid_direct_win=True)\n\n        # Recreate the board using the move sequence:\n        b2 = bb.Board(moves)\n\n        assert b1 == b2\n        assert b1.to_string() == b2.to_string()\n        assert b1.uid() == b2.uid()\n        ```\n\n    Example:\n        Ensure randomness by generating many distinct sequences:\n        ```python\n        import bitbully as bb\n\n        seen = set()\n        for _ in range(20):\n            _, moves = bb.Board.random_board(5, False)\n            seen.add(tuple(moves))\n\n        # Very likely to see more than one unique sequence.\n        assert len(seen) &gt; 1\n        ```\n    \"\"\"\n    if not 0 &lt;= n_ply &lt;= 42:\n        raise ValueError(f\"n_ply must be between 0 and 42 (inclusive), got {n_ply}.\")\n    board_, moves = bitbully_core.BoardCore.randomBoard(n_ply, forbid_direct_win)\n    board = Board()\n    board._board = board_\n\n    return board, moves\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.reset_board","title":"<code>reset_board(board=None)</code>","text":"<p>Resets the board or sets (overrides) the board to a specific state.</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Sequence[int] | Sequence[Sequence[int]] | str | None</code> <p>The new board state. Accepts: - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7 - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3]) - String: A move sequence of columns as string (e.g., \"002233...\") - None: to reset to an empty board</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the board was set successfully, False otherwise.</p> Example <p>Reset the board to an empty state: <pre><code>import bitbully as bb\n\n# Create a temporary board position from a move string.\n# The string \"0123456\" plays one token in each column (0-6) in sequence.\nboard = bb.Board(\"0123456\")\n\n# Reset the board to an empty state.\n# Calling `reset_board()` clears all tokens and restores the starting position.\n# No moves \u2192 an empty board.\nassert board.reset_board()\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n</code></pre></p> Example <p>(Re-)Set the board using a move sequence string: <pre><code>import bitbully as bb\n\n# This is just a temporary setup; it will be replaced below.\nboard = bb.Board(\"0123456\")\n\n# Set the board state directly from a move sequence.\n# The list [3, 3, 3] represents three consecutive moves in the center column (index 3).\n# Moves alternate automatically between Player 1 (yellow) and Player 2 (red).\n#\n# The `reset_board()` method clears the current position and replays the given moves\n# from an empty board \u2014 effectively overriding any existing board state.\nassert board.reset_board([3, 3, 3])\n\n# Display the updated board to verify the new position.\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n</code></pre></p> Example <p>You can also set the board using other formats, such as a 2D array or a string. See the examples in the <code>bitbully.Board.__init__</code> docstring for details.</p> <pre><code># Briefly demonstrate the different input formats accepted by `reset_board()`.\nimport bitbully as bb\n\n# Create an empty board instance\nboard = bb.Board()\n\n# Variant 1: From a list of moves (integers)\n# Each number represents a column index (0-6); moves alternate between players.\nassert board.reset_board([3, 3, 3])\n\n# Variant 2: From a compact move string\n# Equivalent to the list above \u2014 useful for quick testing or serialization.\nassert board.reset_board(\"33333111\")\n\n# Variant 3: From a 2D list in row-major format (6 x 7)\n# Each inner list represents a row (top to bottom).\n# 0 = empty, 1 = Player 1, 2 = Player 2.\nboard_array = [\n    [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n    [0, 0, 0, 1, 0, 0, 0],  # Row 4\n    [0, 0, 0, 2, 0, 0, 0],  # Row 3\n    [0, 2, 0, 1, 0, 0, 0],  # Row 2\n    [0, 1, 0, 2, 0, 0, 0],  # Row 1\n    [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom)\n]\nassert board.reset_board(board_array)\n\n# Variant 4: From a 2D list in column-major format (7 x 6)\n# Each inner list represents a column (left to right); this matches BitBully's internal layout.\nboard_array = [\n    [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)\n    [2, 1, 2, 1, 0, 0],  # Column 1\n    [0, 0, 0, 0, 0, 0],  # Column 2\n    [1, 2, 1, 2, 1, 0],  # Column 3 (center)\n    [0, 0, 0, 0, 0, 0],  # Column 4\n    [2, 1, 2, 0, 0, 0],  # Column 5\n    [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)\n]\nassert board.reset_board(board_array)\n\n# Display the final board state in text form\nboard\n</code></pre> <p>Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  O  _\n_  X  _  O  _  X  _\n_  O  _  X  _  O  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def reset_board(self, board: Sequence[int] | Sequence[Sequence[int]] | str | None = None) -&gt; bool:\n    \"\"\"Resets the board or sets (overrides) the board to a specific state.\n\n    Args:\n        board (Sequence[int] | Sequence[Sequence[int]] | str | None):\n            The new board state. Accepts:\n            - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7\n            - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3])\n            - String: A move sequence of columns as string (e.g., \"002233...\")\n            - None: to reset to an empty board\n\n    Returns:\n        bool: True if the board was set successfully, False otherwise.\n\n    Example:\n        Reset the board to an empty state:\n        ```python\n        import bitbully as bb\n\n        # Create a temporary board position from a move string.\n        # The string \"0123456\" plays one token in each column (0-6) in sequence.\n        board = bb.Board(\"0123456\")\n\n        # Reset the board to an empty state.\n        # Calling `reset_board()` clears all tokens and restores the starting position.\n        # No moves \u2192 an empty board.\n        assert board.reset_board()\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        ```\n\n    Example:\n        (Re-)Set the board using a move sequence string:\n        ```python\n        import bitbully as bb\n\n        # This is just a temporary setup; it will be replaced below.\n        board = bb.Board(\"0123456\")\n\n        # Set the board state directly from a move sequence.\n        # The list [3, 3, 3] represents three consecutive moves in the center column (index 3).\n        # Moves alternate automatically between Player 1 (yellow) and Player 2 (red).\n        #\n        # The `reset_board()` method clears the current position and replays the given moves\n        # from an empty board \u2014 effectively overriding any existing board state.\n        assert board.reset_board([3, 3, 3])\n\n        # Display the updated board to verify the new position.\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        ```\n\n    Example:\n        You can also set the board using other formats, such as a 2D array or a string.\n        See the examples in the [`bitbully.Board.__init__`][src.bitbully.Board.__init__] docstring for details.\n\n        ```python\n        # Briefly demonstrate the different input formats accepted by `reset_board()`.\n        import bitbully as bb\n\n        # Create an empty board instance\n        board = bb.Board()\n\n        # Variant 1: From a list of moves (integers)\n        # Each number represents a column index (0-6); moves alternate between players.\n        assert board.reset_board([3, 3, 3])\n\n        # Variant 2: From a compact move string\n        # Equivalent to the list above \u2014 useful for quick testing or serialization.\n        assert board.reset_board(\"33333111\")\n\n        # Variant 3: From a 2D list in row-major format (6 x 7)\n        # Each inner list represents a row (top to bottom).\n        # 0 = empty, 1 = Player 1, 2 = Player 2.\n        board_array = [\n            [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n            [0, 0, 0, 1, 0, 0, 0],  # Row 4\n            [0, 0, 0, 2, 0, 0, 0],  # Row 3\n            [0, 2, 0, 1, 0, 0, 0],  # Row 2\n            [0, 1, 0, 2, 0, 0, 0],  # Row 1\n            [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom)\n        ]\n        assert board.reset_board(board_array)\n\n        # Variant 4: From a 2D list in column-major format (7 x 6)\n        # Each inner list represents a column (left to right); this matches BitBully's internal layout.\n        board_array = [\n            [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)\n            [2, 1, 2, 1, 0, 0],  # Column 1\n            [0, 0, 0, 0, 0, 0],  # Column 2\n            [1, 2, 1, 2, 1, 0],  # Column 3 (center)\n            [0, 0, 0, 0, 0, 0],  # Column 4\n            [2, 1, 2, 0, 0, 0],  # Column 5\n            [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)\n        ]\n        assert board.reset_board(board_array)\n\n        # Display the final board state in text form\n        board\n        ```\n\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  O  _\n        _  X  _  O  _  X  _\n        _  O  _  X  _  O  _\n        ```\n    \"\"\"\n    if board is None:\n        return self._board.setBoard([])\n    if isinstance(board, str):\n        return self._board.setBoard(board)\n\n    # From here on, board is a Sequence[...] (but not str).\n    # Distinguish 2D vs 1D by inspecting the first element.\n    if len(board) &gt; 0 and isinstance(board[0], Sequence) and not isinstance(board[0], (str, bytes)):\n        # Case 2: 2D -&gt; list[list[int]]\n        # Convert inner sequences to lists of ints\n        grid: list[list[int]] = [[int(v) for v in row] for row in cast(Sequence[Sequence[Any]], board)]\n        return self._board.setBoard(grid)\n\n    # Case 3: 1D -&gt; list[int]\n    moves: list[int] = [int(v) for v in cast(Sequence[Any], board)]\n    return self._board.setBoard(moves)\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.to_array","title":"<code>to_array(column_major_layout=True)</code>","text":"<p>Returns the board state as a 2D array (list of lists).</p> <p>This layout is convenient for printing, serialization, or converting to a NumPy array for further analysis.</p> <p>Parameters:</p> Name Type Description Default <code>column_major_layout</code> <code>bool</code> <p>Use column-major format if set to <code>True</code>, otherwise the row-major-layout is used.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[list[int]]</code> <p>list[list[int]]: A 7x6 2D list representing the board state.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If <code>column_major_layout</code> is set to <code>False</code>.</p> Example Column-major Format:Row-major Format: <p>The returned array is in column-major format with shape <code>7 x 6</code> (<code>[column][row]</code>):</p> <ul> <li>There are 7 inner lists, one for each column of the board.</li> <li>Each inner list has 6 integers, one for each row.</li> <li>Row index <code>0</code> corresponds to the bottom row, row index <code>5</code> to the top row.</li> <li>Convention:</li> <li><code>0</code> -&gt; empty cell</li> <li><code>1</code> -&gt; Player 1 token (yellow, X)</li> <li><code>2</code> -&gt; Player 2 token (red, O)</li> </ul> <p><pre><code>import bitbully as bb\nfrom pprint import pprint\n\n# Create a position from a move sequence.\nboard = bb.Board(\"33333111\")\n\n# Extract the board as a 2D list (rows x columns).\narr = board.to_array()\n\n# Reconstruct the same position from the 2D array.\nboard2 = bb.Board(arr)\n\n# Both boards represent the same position.\nassert board == board2\nassert board.to_array() == board2.to_array()\n\n# print ther result of `board.to_array()`:\npprint(board.to_array())\n</code></pre> Expected output: <pre><code>[[0, 0, 0, 0, 0, 0],\n[2, 1, 2, 0, 0, 0],\n[0, 0, 0, 0, 0, 0],\n[1, 2, 1, 2, 1, 0],\n[0, 0, 0, 0, 0, 0],\n[0, 0, 0, 0, 0, 0],\n[0, 0, 0, 0, 0, 0]]\n</code></pre></p> <pre><code>TODO: This is not supported yet\n</code></pre> Source code in <code>src/bitbully/board.py</code> <pre><code>def to_array(self, column_major_layout: bool = True) -&gt; list[list[int]]:\n    \"\"\"Returns the board state as a 2D array (list of lists).\n\n    This layout is convenient for printing, serialization, or converting\n    to a NumPy array for further analysis.\n\n    Args:\n        column_major_layout (bool): Use column-major format if set to `True`,\n            otherwise the row-major-layout is used.\n\n    Returns:\n        list[list[int]]: A 7x6 2D list representing the board state.\n\n    Raises:\n        NotImplementedError: If `column_major_layout` is set to `False`.\n\n    Example:\n        === \"Column-major Format:\"\n\n            The returned array is in **column-major** format with shape `7 x 6`\n            (`[column][row]`):\n\n            - There are 7 inner lists, one for each column of the board.\n            - Each inner list has 6 integers, one for each row.\n            - Row index `0` corresponds to the **bottom row**,\n            row index `5` to the **top row**.\n            - Convention:\n            - `0` -&gt; empty cell\n            - `1` -&gt; Player 1 token (yellow, X)\n            - `2` -&gt; Player 2 token (red, O)\n\n            ```python\n            import bitbully as bb\n            from pprint import pprint\n\n            # Create a position from a move sequence.\n            board = bb.Board(\"33333111\")\n\n            # Extract the board as a 2D list (rows x columns).\n            arr = board.to_array()\n\n            # Reconstruct the same position from the 2D array.\n            board2 = bb.Board(arr)\n\n            # Both boards represent the same position.\n            assert board == board2\n            assert board.to_array() == board2.to_array()\n\n            # print ther result of `board.to_array()`:\n            pprint(board.to_array())\n            ```\n            Expected output:\n            ```text\n            [[0, 0, 0, 0, 0, 0],\n            [2, 1, 2, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [1, 2, 1, 2, 1, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0]]\n            ```\n\n        === \"Row-major Format:\"\n\n            ``` markdown\n            TODO: This is not supported yet\n            ```\n    \"\"\"\n    if not column_major_layout:\n        # TODO: Implement in C++\n        raise NotImplementedError(\"Row-major Layout is yet to be implemented\")\n\n    return self._board.toArray()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.to_huffman","title":"<code>to_huffman()</code>","text":"<p>Encode the current board position into a Huffman-compressed byte sequence.</p> <p>This is a high-level wrapper around <code>bitbully_core.BoardCore.toHuffman</code>. The returned int encodes the exact token layout and the side to move using the same format as the BitBully opening databases.</p> <p>The encoding is:</p> <ul> <li>Deterministic: the same position always yields the same byte sequence.</li> <li>Compact: suitable for storage (of positions with little number of tokens),   or lookups in the BitBully database format.</li> </ul> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>A Huffman-compressed representation of the current board</p> <code>int</code> <p>state.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the position does not contain exactly 8 or 12 tokens, as the   Huffman encoding is only defined for these cases.</p> Example <p>Encode a position and verify that equivalent positions have the same Huffman code:</p> <pre><code>import bitbully as bb\n\n# Two different move sequences leading to the same final position.\nb1 = bb.Board(\"01234444\")\nb2 = bb.Board(\"44440123\")\n\nh1 = b1.to_huffman()\nh2 = b2.to_huffman()\n\n# Huffman encoding is purely position-based.\nassert h1 == h2\n\nprint(f\"Huffman code: {h1}\")\n</code></pre> <p>Expected output:     <pre><code>Huffman code: 10120112\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def to_huffman(self) -&gt; int:\n    \"\"\"Encode the current board position into a Huffman-compressed byte sequence.\n\n    This is a high-level wrapper around\n    `bitbully_core.BoardCore.toHuffman`. The returned int encodes the\n    exact token layout **and** the side to move using the same format as\n    the BitBully opening databases.\n\n    The encoding is:\n\n    - Deterministic: the same position always yields the same byte sequence.\n    - Compact: suitable for storage (of positions with little number of tokens),\n      or lookups in the BitBully database format.\n\n    Returns:\n        int: A Huffman-compressed representation of the current board\n        state.\n\n    Raises:\n        NotImplementedError:\n            If the position does not contain exactly 8 or 12 tokens, as the\n              Huffman encoding is only defined for these cases.\n\n    Example:\n        Encode a position and verify that equivalent positions have the\n        same Huffman code:\n\n        ```python\n        import bitbully as bb\n\n        # Two different move sequences leading to the same final position.\n        b1 = bb.Board(\"01234444\")\n        b2 = bb.Board(\"44440123\")\n\n        h1 = b1.to_huffman()\n        h2 = b2.to_huffman()\n\n        # Huffman encoding is purely position-based.\n        assert h1 == h2\n\n        print(f\"Huffman code: {h1}\")\n        ```\n    Expected output:\n        ```text\n        Huffman code: 10120112\n        ```\n    \"\"\"\n    token_count = self.count_tokens()\n    if token_count != 8 and token_count != 12:\n        raise NotImplementedError(\"to_huffman() is only implemented for positions with 8 or 12 tokens.\")\n    return self._board.toHuffman()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.to_string","title":"<code>to_string()</code>","text":"<p>Returns a human-readable ASCII representation of the board.</p> <p>The returned string shows the current board position as a 6x7 grid, laid out exactly as it would appear when you print a <code>Board</code> instance:</p> <ul> <li>6 lines of text, one per row (top row first, bottom row last)</li> <li>7 entries per row, separated by two spaces</li> <li><code>_</code> represents an empty cell</li> <li><code>X</code> represents a token from Player 1 (yellow)</li> <li><code>O</code> represents a token from Player 2 (red)</li> </ul> <p>This is useful when you want to explicitly capture the board as a string (e.g., for logging, debugging, or embedding into error messages) instead of relying on <code>print(board)</code> or <code>repr(board)</code>.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A multi-line ASCII string representing the board state.</p> Example <p>Using <code>to_string()</code> on an empty board: <pre><code>import bitbully as bb\n\nboard = bb.Board(\"33333111\")\n\ns = board.to_string()\nprint(s)\n</code></pre></p> <p>Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def to_string(self) -&gt; str:\n    \"\"\"Returns a human-readable ASCII representation of the board.\n\n    The returned string shows the **current board position** as a 6x7 grid,\n    laid out exactly as it would appear when you print a `Board` instance:\n\n    - 6 lines of text, one per row (top row first, bottom row last)\n    - 7 entries per row, separated by two spaces\n    - `_` represents an empty cell\n    - `X` represents a token from Player 1 (yellow)\n    - `O` represents a token from Player 2 (red)\n\n    This is useful when you want to explicitly capture the board as a string\n    (e.g., for logging, debugging, or embedding into error messages) instead\n    of relying on `print(board)` or `repr(board)`.\n\n    Returns:\n        str: A multi-line ASCII string representing the board state.\n\n    Example:\n        Using `to_string()` on an empty board:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board(\"33333111\")\n\n        s = board.to_string()\n        print(s)\n        ```\n\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n    \"\"\"\n    return self._board.toString()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.uid","title":"<code>uid()</code>","text":"<p>Returns a unique identifier for the current board state.</p> <p>The UID is a deterministic integer computed from the internal bitboard representation of the position. It is stable, position-based, and uniquely tied to the exact token layout and the side to move.</p> <p>Key properties:</p> <ul> <li>Boards with the same configuration (tokens + player to move) always   produce the same UID.</li> <li>Any change to the board (e.g., after a legal move) will almost always   result in a different UID.</li> <li>Copies of a board created via the copy constructor or <code>Board.copy()</code>   naturally share the same UID as long as their states remain identical.</li> </ul> <p>Unlike <code>__hash__()</code>, the UID is not optimized for hash-table dispersion. For use in transposition tables, caching, or dictionary/set keys, prefer <code>__hash__()</code> since it provides a higher-quality hash distribution.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>A unique integer identifier for the board state.</p> Example <p>UID is an integer and not None: <pre><code>import bitbully as bb\n\nboard = bb.Board()\nu = board.uid()\n\nassert isinstance(u, int)\n# Empty board has a well-defined, stable UID.\nassert board.uid() == u\n</code></pre></p> Example <p>UID changes when the position changes: <pre><code>import bitbully as bb\n\nboard = bb.Board()\nuid_before = board.uid()\n\nassert board.play(1)  # Make a move in column 1.\n\nuid_after = board.uid()\nassert uid_after != uid_before\n</code></pre></p> Example <p>Copies share the same UID while they are identical: <pre><code>import bitbully as bb\n\nboard = bb.Board(\"0123\")\n\n# Create an independent copy of the same position.\nboard_copy = board.copy()\n\nassert board is not board_copy  # Different objects\nassert board == board_copy  # Same position\nassert board.uid() == board_copy.uid()  # Same UID\n\n# After modifying the copy, they diverge.\nassert board_copy.play(4)\nassert board != board_copy\nassert board.uid() != board_copy.uid()\n</code></pre></p> Example <p>Different move sequences leading to the same position share the same UID: <pre><code>import bitbully as bb\n\nboard_1 = bb.Board(\"01234444\")\nboard_2 = bb.Board(\"44440123\")\n\nassert board_1 is not board_2  # Different objects\nassert board_1 == board_2  # Same position\nassert board_1.uid() == board_2.uid()  # Same UID\n\n# After modifying the copy, they diverge.\nassert board_1.play(4)\nassert board_1 != board_2\nassert board_1.uid() != board_2.uid()\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def uid(self) -&gt; int:\n    \"\"\"Returns a unique identifier for the current board state.\n\n    The UID is a deterministic integer computed from the internal bitboard\n    representation of the position. It is **stable**, **position-based**, and\n    uniquely tied to the exact token layout **and** the side to move.\n\n    Key properties:\n\n    - Boards with the **same** configuration (tokens + player to move) always\n      produce the **same** UID.\n    - Any change to the board (e.g., after a legal move) will almost always\n      result in a **different** UID.\n    - Copies of a board created via the copy constructor or `Board.copy()`\n      naturally share the same UID as long as their states remain identical.\n\n    Unlike `__hash__()`, the UID is not optimized for hash-table dispersion.\n    For use in transposition tables, caching, or dictionary/set keys,\n    prefer `__hash__()` since it provides a higher-quality hash distribution.\n\n    Returns:\n        int: A unique integer identifier for the board state.\n\n    Example:\n        UID is an integer and not None:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        u = board.uid()\n\n        assert isinstance(u, int)\n        # Empty board has a well-defined, stable UID.\n        assert board.uid() == u\n        ```\n\n    Example:\n        UID changes when the position changes:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        uid_before = board.uid()\n\n        assert board.play(1)  # Make a move in column 1.\n\n        uid_after = board.uid()\n        assert uid_after != uid_before\n        ```\n\n    Example:\n        Copies share the same UID while they are identical:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board(\"0123\")\n\n        # Create an independent copy of the same position.\n        board_copy = board.copy()\n\n        assert board is not board_copy  # Different objects\n        assert board == board_copy  # Same position\n        assert board.uid() == board_copy.uid()  # Same UID\n\n        # After modifying the copy, they diverge.\n        assert board_copy.play(4)\n        assert board != board_copy\n        assert board.uid() != board_copy.uid()\n        ```\n\n    Example:\n        Different move sequences leading to the same position share the same UID:\n        ```python\n        import bitbully as bb\n\n        board_1 = bb.Board(\"01234444\")\n        board_2 = bb.Board(\"44440123\")\n\n        assert board_1 is not board_2  # Different objects\n        assert board_1 == board_2  # Same position\n        assert board_1.uid() == board_2.uid()  # Same UID\n\n        # After modifying the copy, they diverge.\n        assert board_1.play(4)\n        assert board_1 != board_2\n        assert board_1.uid() != board_2.uid()\n        ```\n    \"\"\"\n    return self._board.uid()\n</code></pre>"},{"location":"board/#src.bitbully.board.Board.winner","title":"<code>winner()</code>","text":"<p>Returns the winning player, if the game has been won.</p> <p>This helper interprets the current board under the assumption that <code>bitbully.Board.has_win</code> indicates the last move created a winning configuration. In that case, the winner is the previous player:</p> <ul> <li>If it is currently Player 1's turn, then Player 2 must have just won.</li> <li>If it is currently Player 2's turn, then Player 1 must have just won.</li> </ul> <p>If there is no winner (i.e. <code>bitbully.Board.has_win</code> is <code>False</code>), this method returns <code>None</code>.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>int | None: The winning player, or <code>None</code> if there is no winner.</p> <ul> <li><code>1</code> \u2192 Player 1 (yellow, <code>X</code>)</li> <li><code>2</code> \u2192 Player 2 (red, <code>O</code>)</li> <li><code>None</code> \u2192 No winner (game still ongoing or draw)</li> </ul> Example <p>Detecting a winner: <pre><code>import bitbully as bb\n\n# Player 1 wins with a horizontal line at the bottom.\nboard = bb.Board()\nassert board.play(\"1122334\")\n\nassert board.has_win()\nassert board.is_game_over()\n\n# It is now Player 2's turn to move next...\nassert board.current_player == 2\n\n# ...which implies Player 1 must be the winner.\nassert board.winner() == 1\n</code></pre></p> Example <p>No winner yet: <pre><code>import bitbully as bb\n\nboard = bb.Board()\nassert board.play(\"112233\")  # no connect-four yet\n\nassert not board.has_win()\nassert not board.is_game_over()\nassert board.winner() is None\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def winner(self) -&gt; int | None:\n    \"\"\"Returns the winning player, if the game has been won.\n\n    This helper interprets the current board under the assumption that\n    [`bitbully.Board.has_win`][src.bitbully.Board.has_win] indicates **the last move** created a\n    winning configuration. In that case, the winner is the *previous* player:\n\n    - If it is currently Player 1's turn, then Player 2 must have just won.\n    - If it is currently Player 2's turn, then Player 1 must have just won.\n\n    If there is no winner (i.e. [`bitbully.Board.has_win`][src.bitbully.Board.has_win] is ``False``),\n    this method returns ``None``.\n\n    Returns:\n        int | None:\n            The winning player, or ``None`` if there is no winner.\n\n            - ``1`` \u2192 Player 1 (yellow, ``X``)\n            - ``2`` \u2192 Player 2 (red, ``O``)\n            - ``None`` \u2192 No winner (game still ongoing or draw)\n\n    Example:\n        Detecting a winner:\n        ```python\n        import bitbully as bb\n\n        # Player 1 wins with a horizontal line at the bottom.\n        board = bb.Board()\n        assert board.play(\"1122334\")\n\n        assert board.has_win()\n        assert board.is_game_over()\n\n        # It is now Player 2's turn to move next...\n        assert board.current_player == 2\n\n        # ...which implies Player 1 must be the winner.\n        assert board.winner() == 1\n        ```\n\n    Example:\n        No winner yet:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        assert board.play(\"112233\")  # no connect-four yet\n\n        assert not board.has_win()\n        assert not board.is_game_over()\n        assert board.winner() is None\n        ```\n    \"\"\"\n    if not self.has_win():\n        return None\n    # Previous player = opposite of current_player\n    return 2 if self.current_player == 1 else 1\n</code></pre>"},{"location":"develop/","title":"Development (Basic)","text":""},{"location":"develop/#1-clone-the-repository","title":"1. Clone the repository","text":"<pre><code>git clone https://github.com/MarkusThill/BitBully.git\ncd BitBully\ngit submodule update --init --recursive   # Initialize and update submodules\n</code></pre> <p>BitBully uses submodules, so make sure to always clone with them initialized. If you already cloned earlier without them, run:</p> <pre><code>git submodule update --remote --merge\n</code></pre>"},{"location":"develop/#2-create-and-activate-a-virtual-environment-recommended","title":"2. Create and activate a virtual environment (recommended)","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate      # Linux/Mac\n# or\n.\\.venv\\Scripts\\activate       # Windows\n</code></pre>"},{"location":"develop/#3-install-development-dependencies","title":"3. Install development dependencies","text":"<pre><code>pip install -e .[dev]\n</code></pre> <p>This installs BitBully in editable mode plus all development tooling (ruff, mypy, pytest, coverage, commitizen, pre-commit, etc.).</p>"},{"location":"develop/#4-install-git-hooks-pre-commit","title":"4. Install Git hooks (pre-commit)","text":"<pre><code>pre-commit install --hook-type pre-commit --hook-type commit-msg --hook-type pre-push\n</code></pre> <p>This activates:</p> <ul> <li>pre-commit: formatting, linting, static checks before each commit</li> <li>commit-msg: Commitizen / conventional commit message validation</li> <li>pre-push: optional checks before pushing (e.g., running tests)</li> </ul> <p>To run all hooks manually:</p> <pre><code>pre-commit run --all-files\n</code></pre>"},{"location":"develop/#5-running-tests","title":"5. Running tests","text":"<pre><code>pytest tests/ -vv\n</code></pre>"},{"location":"develop/#6-building-wheels-locally-optional","title":"6. Building wheels locally (optional)","text":"<pre><code>python -m build\n</code></pre>"},{"location":"develop/#testing-and-ci","title":"Testing and CI","text":""},{"location":"develop/#running-tests","title":"Running Tests","text":"<p>Run unit tests using <code>pytest</code>:</p> <pre><code>pytest tests/\n</code></pre> <p>For more detailed output:</p> <pre><code>pytest tests/ -v          # verbose: show each test\npytest tests/ -vv         # very verbose: show full node IDs\n</code></pre> <p>Run only tests matching a pattern:</p> <pre><code># A boolean expression that selects tests:\n#   - containing the substring board\n#   - but not containing the substring slow\npytest tests/ -k \"board and not slow\"\n</code></pre> <pre><code>pytest tests/test_opening_book_core.py\n</code></pre> <p>Run a specific test case:</p> <pre><code>pytest tests/test_board_core_basic.py::test_can_win_1\n</code></pre> <p>Stop after the first failure:</p> <pre><code>pytest tests/ -x\n</code></pre> <p>Run with coverage (requires <code>pytest-cov</code>):</p> <pre><code>pytest tests/ --cov=bitbully --cov-report=term-missing\n</code></pre>"},{"location":"develop/#github-actions","title":"GitHub Actions","text":"<p>This project uses GitHub Actions to build and test the library. The CI workflow includes:</p> <ul> <li>Building wheels for Linux and Windows using <code>cibuildwheel</code>.</li> <li>Building source distributions (<code>sdist</code>).</li> <li>Optionally uploading artifacts to PyPI.</li> </ul> <p>The workflows are found under <code>.github/workflows/</code>.</p>"},{"location":"develop/#contributing","title":"Contributing","text":"<p>Contributions are welcome! Follow these steps:</p> <ol> <li>Fork the repository.</li> <li>Create a new branch for your changes:    <pre><code>git checkout -b feature-name\n</code></pre></li> <li>Install <code>dev</code> dependencies:    <pre><code>pip install -e .[dev]\n</code></pre></li> <li>Install pre-commit hooks:    <pre><code>pre-commit install --hook-type pre-commit --hook-type commit-msg --hook-type pre-push\n</code></pre></li> <li>Commit your changes:    <pre><code>git commit -m \"feat: Add feature or fix description\"\n</code></pre></li> <li>Push to your branch:    <pre><code>git push origin feature-name\n</code></pre></li> <li>Open a pull request.</li> </ol>"},{"location":"develop/#development","title":"Development","text":""},{"location":"develop/#usual-push-procedure","title":"Usual Push Procedure","text":"<p>If possible, also try the build on a windows-native machine since there are some subtle differences in the build process:</p> <pre><code>pytest tests/ # ensure that tests run through\nmv dist/ dist.old # if applicable\npython -m build # local build should pass\ncibuildwheel --output-dir dist # now build for the other specified platforms\ntwine check dist/* # Check package metadata in dist folder\ntwine check dist/* --strict # Check package metadata in dist folder (strict)\ngit add -u # or add whatever you want to commit\npre-commit run # make sure that this passes\ngit commit -m \"fix|feat|docs|...: message\" # commit using semantic versioning\ncz bump --dry-run\ncz bump\ngit push --atomic origin master vx.x.x # make sure that you set the correct version\n# build will now be performed on GitHub Runners\n</code></pre> <p>In case you run into an error during <code>cibuildwheel</code>, like</p> <pre><code>CMake Error: The current CMakeCache.txt directory /project/build/temp.linux-x86_64-cpython-312/CMakeCache.txt is different than the directory /workspaces/BitBully/build/temp.linux-x86_64-cpython-312 where CMakeCache.txt was created. This may result in binaries being created in the wrong place. If you are not sure, reedit the CMakeCache.txt\nCMake Error: The source \"/project/CMakeLists.txt\" does not match the source \"/workspaces/BitBully/CMakeLists.txt\" used to generate cache.  Re-run cmake with a different source directory.\n</code></pre> <p>it might help to clean up old builds:</p> <pre><code>rm -rf build/ dist/ src/bitbully/*.so src/bitbully/assets/*.so\n</code></pre> <p>You can also build pre-release versions like this.</p> <pre><code>cz bump --prerelease alpha   # Creates 1.2.3a0 if current is 1.2.3\ncz bump --prerelease beta\ncz bump --prerelease rc\ncz bump --prerelease rc --increment minor # To bump the minor version and start a pre-release\n</code></pre> <p>In this case, after pushing to the repository, only a small build for Python3.11 is performed and the results wheels are pushed to Test-PyPI instead of the real PyPi.</p>"},{"location":"develop/#generating-python-type-stubs-for-pybind11-modules","title":"Generating Python Type Stubs for Pybind11 Modules","text":"<p>To enable type checking with tools like <code>mypy</code> for Pybind11 compiled modules, you can generate a <code>.pyi</code> stub file using <code>pybind11-stubgen</code>. For example:</p> <pre><code>pip install pybind11-stubgen\npybind11-stubgen bitbully.bitbully_core -o src/\n</code></pre> <p>Notes</p> <p>The generated .pyi file contains function and class signatures with type hints, which helps <code>mypy</code> and other type checkers.</p>"},{"location":"develop/#compiler","title":"Compiler","text":"<p>The code was compiled with: gcc 13.1.0</p>"},{"location":"develop/#configure-gov-13-to-match-g-13gcc-13","title":"Configure gov-13 to match g++-13/gcc-13","text":"<p>The version of gcov has to match our compiler version, in order to be able to produce coverage reports:</p> <pre><code>sudo update-alternatives --install /usr/bin/gcov gcov /usr/bin/gcov-11 50 # for compiler version 11\nsudo update-alternatives --install /usr/bin/gcov gcov /usr/bin/gcov-13 100 # for compiler version 13 (as we have here)\nsudo update-alternatives --config gcov\n</code></pre>"},{"location":"develop/#development-debian-based-systems","title":"Development (Debian-based Systems)","text":""},{"location":"develop/#install-python-3","title":"Install Python 3","text":"<pre><code>sudo apt install python3.11\nsudo apt install python3.11-venv\n</code></pre> <p>Configure alternatives, if you have other versions of python installed:</p> <pre><code>sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.10 1\nsudo update-alternatives --install /usr/bin/python python /usr/bin/python3.11 2\nsudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.10 1\nsudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.11 2\n\nsudo update-alternatives --config python\n\nsudo update-alternatives --config python3\n</code></pre>"},{"location":"develop/#install-activate-virtualenv","title":"Install &amp; Activate virtualenv","text":"<pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre>"},{"location":"develop/#install-dependencies","title":"Install Dependencies","text":"<pre><code>pip install -e .[dev,ci]\n</code></pre> <pre><code>pre-commit install\npre-commit install --hook-type commit-msg --hook-type pre-push\n</code></pre> <p>You can run pre-commit before a commit with:</p> <pre><code>pre-commit run\n</code></pre>"},{"location":"develop/#commitizen","title":"Commitizen","text":""},{"location":"develop/#bump-version","title":"Bump Version","text":"<pre><code>cz bump --dry-run # first perform a dry run\ncz bump\ngit push origin tag x.x.x\n</code></pre>"},{"location":"develop/#push-commit-and-tag-atomically","title":"Push commit and tag atomically","text":"<pre><code>git push --atomic origin master v0.0.14\n</code></pre>"},{"location":"develop/#commit-types","title":"Commit types","text":"Commit Type Title Description Emoji <code>feat</code> Features A new feature \u2728 <code>fix</code> Bug Fixes A bug Fix \ud83d\udc1b <code>docs</code> Documentation Documentation only changes \ud83d\udcda <code>style</code> Styles Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) \ud83d\udc8e <code>refactor</code> Code Refactoring A code change that neither fixes a bug nor adds a feature \ud83d\udce6 <code>perf</code> Performance Improvements A code change that improves performance \ud83d\ude80 <code>test</code> Tests Adding missing tests or correcting existing tests \ud83d\udea8 <code>build</code> Builds Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm) \ud83d\udee0 <code>ci</code> Continuous Integrations Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs) \u2699\ufe0f <code>chore</code> Chores Other changes that don't modify src or test files \u267b\ufe0f <code>revert</code> Reverts Reverts a previous commit \ud83d\uddd1"},{"location":"develop/#publish-to-pypi","title":"Publish to PyPI","text":"<ol> <li> <p>Create a PyPi Test Account</p> </li> <li> <p>Log in to Test PyPI or create a new account.</p> </li> <li>Navigate to \"Account Settings\" \u2192 \"API Tokens\".</li> <li> <p>Generate a new API token if needed.</p> </li> <li> <p>Create a PyPI Account:</p> </li> <li> <p>Sign up on PyPI.</p> </li> <li>Set up 2FA (Two-Factor Authentication) for enhanced security.</li> <li>Install Required Tools: Ensure you have build and twine installed for building and publishing:</li> </ol> <pre><code>pip install build twine\n</code></pre> <ol> <li>Update your <code>~/.pypirc File</code>:</li> </ol> <pre><code>[ distutils ]\n  index-servers =\n  pypi\n  testpypi\n\n  [ testpypi ]\n  repository = https://test.pypi.org/legacy/\n  username = __token__\n  password = &lt;your_api_token&gt;\n\n  [ pypi ]\n  repository = https://upload.pypi.org/legacy/\n  username = __token__\n  password = &lt;your_api_token&gt;\n</code></pre>"},{"location":"develop/#build-the-package","title":"Build the Package","text":""},{"location":"develop/#check-the-readme","title":"Check the Readme","text":"<pre><code>pip install readme_renderer[md]\npython -m readme_renderer README.md\npython -m build\n</code></pre>"},{"location":"develop/#build","title":"Build","text":"<pre><code>cd /path/to/project\npython -m build\n</code></pre>"},{"location":"develop/#upload-to-test-pypi","title":"Upload to Test PyPI","text":"<p>Upload to Test pypi first:</p> <pre><code>twine upload --repository testpypi dist/*\n</code></pre> <p>Test installation:</p> <pre><code>pip install --index-url https://test.pypi.org/simple/ bitbully\n</code></pre>"},{"location":"develop/#publish-to-pypi_1","title":"Publish to PyPI","text":"<pre><code>twine upload dist/*\n</code></pre> <p>Test installation from PyPI:</p> <pre><code>pip install bitbully\n</code></pre>"},{"location":"develop/#cheatsheet-most-useful-commands","title":"Cheatsheet: Most Useful Commands","text":""},{"location":"develop/#version-control-git","title":"Version Control (Git)","text":"<ol> <li><code>git status</code> \u2013 Check repository status.</li> <li><code>git add -u</code> \u2013 Stage all changes.</li> <li><code>git add &lt;files&gt;</code> \u2013 Stage specific files.</li> <li><code>git commit -m \"&lt;message&gt;\"</code> \u2013 Commit changes with a message.</li> <li><code>git commit --amend</code> \u2013 Modify the last commit.</li> <li><code>git push --atomic origin master v&lt;version&gt;</code> \u2013 Atomically pushes master branch and tags</li> <li><code>git push</code> \u2013 Push changes to the remote repository.</li> <li><code>git tag -l</code>, <code>git tag --list</code> \u2013 List tags.</li> <li><code>git tag -d &lt;tag&gt;</code> \u2013 Delete a local tag.</li> <li><code>git push origin --delete &lt;tag&gt;</code> \u2013 Delete a remote tag.</li> <li><code>git diff</code> \u2013 Show differences between changes.</li> <li><code>git fetch</code> \u2013 Fetch changes from the remote repository.</li> <li><code>git fetch upstream</code> \u2013 Fetches changes from the upstream repository</li> <li><code>git rebase &lt;branch&gt;</code> \u2013 Rebase the current branch.</li> <li><code>git merge &lt;branch&gt;</code> \u2013 Merge a branch into the current branch.</li> <li><code>git merge upstream/main</code> \u2013 Merge changes from upstream/main branch</li> <li><code>git checkout &lt;file&gt;</code> \u2013 Revert changes in a specific file</li> </ol>"},{"location":"develop/#git-submodule-commands","title":"Git Submodule Commands","text":"<ol> <li><code>git submodule status</code> \u2013 Show the status of submodules.</li> <li><code>git submodule add &lt;repo-url&gt; &lt;path&gt;</code> \u2013 Add a new submodule.</li> <li><code>git submodule update --init --recursive</code> \u2013 Initialize and update submodules.</li> <li><code>git submodule add -b &lt;branch&gt; &lt;repo-url&gt; &lt;path&gt;</code> \u2013 Add a submodule tracking a specific branch.</li> </ol>"},{"location":"develop/#formatting-and-linting","title":"Formatting and Linting","text":"<ol> <li><code>ruff format &lt;file&gt;</code> \u2013 Format Python code using Ruff.</li> <li><code>ruff format .</code> \u2013 Format all files using Ruff</li> <li><code>ruff check --fix</code> \u2013 Run Ruff checks and apply automatic fixes</li> <li><code>ruff check --unsafe-fixes --fix</code> \u2013 Run Ruff checks with unsafe fixes</li> <li><code>ruff format notebooks/*</code> \u2013 Format Jupyter notebook files</li> <li><code>ruff clean</code> \u2013 Clean Ruff cache and temporary files</li> <li><code>clang-format &lt;file&gt;</code> \u2013 Format C++ code using Clang-Format.</li> </ol>"},{"location":"develop/#cmake-commands","title":"CMake Commands","text":"<ol> <li><code>cmake --version</code> \u2013 Check the version of CMake.</li> <li><code>cmake &lt;options&gt;</code> \u2013 Generate build files based on <code>CMakeLists.txt</code>.</li> </ol>"},{"location":"develop/#testing-and-debugging","title":"Testing and Debugging","text":"<ol> <li><code>gdb --version</code> \u2013 Check the version of GDB (GNU Debugger).</li> <li><code>gdb &lt;program&gt;</code> \u2013 Debug a program.</li> </ol>"},{"location":"develop/#python-environment-management","title":"Python Environment Management","text":"<ol> <li><code>python3 --version</code> \u2013 Check Python version.</li> <li><code>python3 -m venv &lt;name&gt;</code> \u2013 Create a virtual environment.</li> <li><code>source &lt;venv&gt;/bin/activate</code> \u2013 Activate a virtual environment.</li> <li><code>deactivate</code> \u2013 Deactivate the virtual environment.</li> </ol>"},{"location":"develop/#dependency-and-package-management","title":"Dependency and Package Management","text":"<ol> <li><code>pip install &lt;package&gt;</code> \u2013 Install a Python package.</li> <li><code>pip install -e .</code> \u2013 Install the package in editable mode.</li> <li><code>pip uninstall &lt;package&gt;</code> \u2013 Uninstall a Python package.</li> <li><code>pip freeze</code> \u2013 List installed packages.</li> <li><code>gem install &lt;gem&gt;</code> \u2013 Install a Ruby gem.</li> <li><code>bundle install</code> \u2013 Install Ruby gem dependencies.</li> <li><code>pip install /path/to/&lt;package.whl&gt;</code> \u2013 Install a locally built wheel.</li> <li><code>pip uninstall &lt;package&gt;</code> \u2013 Uninstall a Python package.</li> </ol>"},{"location":"develop/#building-and-publishing-python-packages","title":"Building and Publishing Python Packages","text":"<ol> <li><code>python -m build</code> \u2013 Build a Python package.</li> <li><code>twine upload dist/*</code> \u2013 Upload the package to PyPI.</li> <li><code>twine check dist/*</code> \u2013 Check package metadata in dist folder</li> <li><code>twine check dist/* --strict</code> \u2013 Strictly check package metadata in dist fol</li> <li><code>python -m build --wheel</code> \u2013 Build only the wheel package.</li> <li><code>python -m build --sdist</code> \u2013 Build only the source distribution.</li> <li><code>python -m build --platform-tag</code> \u2013 Add a specific platform tag to the build.</li> </ol>"},{"location":"develop/#cibuildwheel","title":"CIBuildWheel","text":"<ol> <li><code>cibuildwheel --output-dir &lt;dir&gt;</code> \u2013 Build Python wheels for multiple platforms.</li> <li><code>cibuildwheel --output-dir &lt;dir&gt; --verbose</code> \u2013 Build wheels with detailed output.</li> <li><code>cibuildwheel --output-dir &lt;dir&gt; --platform &lt;platform&gt;</code> \u2013 Specify a platform for the build (e.g., <code>linux</code>, <code>macos</code>,    or <code>windows</code>). However, usually, defined in the <code>pyproject.toml</code>.</li> </ol>"},{"location":"develop/#pre-commit-commands","title":"Pre-Commit Commands","text":"<ol> <li><code>pre-commit install --hook-type &lt;type&gt;</code> \u2013 Install specific pre-commit hooks (e.g., <code>commit-msg</code>, <code>pre-push</code>).</li> <li><code>pre-commit migrate-config</code> \u2013 Migrate <code>.pre-commit-config.yaml</code> to the latest format.</li> <li><code>pre-commit autoupdate</code> \u2013 Update all pre-commit hooks to their latest versions.</li> <li><code>pre-commit run --all-files</code> \u2013 Run hooks on all files.</li> </ol>"},{"location":"develop/#testing-and-cicd","title":"Testing and CI/CD","text":"<ol> <li><code>pre-commit install</code> \u2013 Install pre-commit hooks.</li> <li><code>pre-commit run</code> \u2013 Run all pre-commit hooks.</li> <li><code>ctest</code> \u2013 Run CMake-based tests.</li> <li><code>cibuildwheel --output-dir dist</code> \u2013 Build Python wheels.</li> </ol>"},{"location":"develop/#commitizen-cz","title":"Commitizen (cz)","text":"<ol> <li><code>cz init</code> \u2013 Initialize Commitizen configuration.</li> <li><code>cz bump</code> \u2013 Automate version bump.</li> <li><code>cz bump --dry-run</code> \u2013 Simulate version bump.</li> </ol>"},{"location":"develop/#doxygen","title":"Doxygen","text":"<ol> <li><code>sudo apt install doxygen</code>  \u2013 Install Doxygen using APT</li> <li><code>apt show doxygen</code> \u2013 displays detailed information about the doxygen package</li> <li><code>doxygen -g Doxyfile</code> \u2013 generates a default configuration file named Doxyfile for Doxygen</li> <li><code>doxygen Doxyfile</code> \u2013 Generate Doxgen Docs based on configuration in <code>Doxyfile</code></li> <li><code>python3 -m http.server 8000 --directory docs/html/</code> \u2013 Serve documentation locally on port <code>8000</code></li> <li><code>doxygen -w html header.html footer.html style.css</code> \u2013 Generate template files for customizing Doxygen's output.</li> <li><code>doxygen --version</code> - get version</li> </ol> <p>Installation script (used in <code>doxygen.yml</code>):</p> <pre><code>export DOXY_VERSION=1.13.1\necho \"Installing doxgen v$DOXY_VERSION\"\nsudo apt-get update &amp;&amp; sudo apt-get install -y graphviz\nmkdir doxygen-installer\nwget \"https://www.doxygen.nl/files/doxygen-${DOXY_VERSION}.linux.bin.tar.gz\"\nmv \"doxygen-${DOXY_VERSION}.linux.bin.tar.gz\" doxygen-installer\ncd doxygen-installer\ngunzip \"doxygen-${DOXY_VERSION}.linux.bin.tar.gz\"\ntar xf \"doxygen-${DOXY_VERSION}.linux.bin.tar\"\ncd \"doxygen-${DOXY_VERSION}\"\nls -laht\nsudo make install\n</code></pre>"},{"location":"develop/#configuration-and-logs","title":"Configuration and Logs","text":"<ol> <li><code>nano ~/.bashrc</code> \u2013 Edit the bash configuration file.</li> <li><code>cat &lt;file&gt;</code> \u2013 View file contents.</li> <li><code>pip show &lt;package&gt;</code> \u2013 Display package details.</li> <li><code>sudo apt install &lt;package&gt;</code> \u2013 Install a package using APT.</li> </ol>"},{"location":"develop/#mkdocs","title":"mkdocs","text":"<ol> <li><code>pip install mkdocs-material mkdocstrings[python] pymdown-extensions</code> - mkdocs extensions</li> <li><code>mkdocs build</code></li> <li><code>mkdocs serve</code></li> </ol>"},{"location":"develop/#nodejs-and-npm","title":"Node.js and NPM","text":"<ol> <li><code>nvm install &lt;version&gt;</code> \u2013 Install a specific Node.js version.</li> <li><code>node -v</code> \u2013 Check Node.js version.</li> <li><code>npm -v</code> \u2013 Check NPM version.</li> <li><code>npm install --save-dev &lt;package&gt;</code> \u2013 Install a development dependency.</li> <li><code>npx prettier . --check</code> \u2013 Check code formatting with Prettier.</li> <li><code>npx prettier . --write</code> \u2013 Format code with Prettier.</li> </ol>"},{"location":"develop/#docker","title":"Docker","text":"<ol> <li><code>docker compose pull</code> \u2013 Pull updated images for the services.</li> <li><code>docker compose up</code> \u2013 Start Docker Compose services.</li> <li><code>docker compose up --help</code> \u2013 Display help for Docker Compose.</li> </ol>"},{"location":"develop/#ruby-and-rbenv","title":"Ruby and Rbenv","text":"<ol> <li><code>rbenv install &lt;version&gt;</code> \u2013 Install a specific Ruby version.</li> <li><code>rbenv local &lt;version&gt;</code> \u2013 Set a local Ruby version for a project.</li> <li><code>gem install bundle</code> \u2013 Install the Bundler gem.</li> <li><code>bundle install</code> \u2013 Install Ruby project dependencies.</li> </ol>"},{"location":"develop/#jekyll","title":"Jekyll","text":"<ol> <li><code>bundle exec jekyll serve --incremental</code> \u2013 Run a Jekyll server incrementally.</li> <li><code>bundle exec jekyll serve --lsi</code> \u2013 Run Jekyll with LSI (Latent Semantic Indexing).</li> <li><code>bundle install</code> \u2013 Install dependencies from the Gemfile.</li> </ol>"},{"location":"develop/#miscellaneous","title":"Miscellaneous","text":"<ol> <li><code>ls</code> \u2013 List directory contents.</li> <li><code>cd &lt;path&gt;</code> \u2013 Change directory.</li> <li><code>history | grep &lt;keyword&gt;</code> \u2013 Search command history.</li> <li><code>htop</code> \u2013 Display interactive process viewer.</li> <li><code>tmux</code> \u2013 Start a new tmux session.</li> </ol>"},{"location":"develop/#github-snake","title":"GitHub Snake","text":""},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installing-bitbully","title":"Installing BitBully","text":"<p>Install BitBully via pip:</p> LatestWith GUI Support (Jupyter Notebboks)Version x.y.z <pre><code>pip install bitbully\n</code></pre> <pre><code>pip install bitbully[gui]\n</code></pre> <pre><code>pip install bitbully==x.y.z\n</code></pre>"},{"location":"getting_started/#usage","title":"Usage","text":""},{"location":"getting_started/#simple-example","title":"Simple Example","text":"<pre><code>from bitbully import Board, BitBully\n\n# Create an empty Connect Four board\nboard = Board()  # Board is empty at the start\n\n# Players YELLOW and RED alternately drop 5 tokens into the center column (column 3)\nfor _ in range(5):\n    board.play_move(3)  # Place token in center column (index 3)\n\n# RED places one token into the second column from the left (column 1)\nboard.play_move(1)\n\nprint(board)\n# Expected output:\n#  _  _  _  _  _  _  _\n#  _  _  _  X  _  _  _\n#  _  _  _  O  _  _  _\n#  _  _  _  X  _  _  _\n#  _  _  _  O  _  _  _\n#  _  O  _  X  _  _  _\n\n# Use the BitBully AI to evaluate the current board position\nbb_agent = BitBully()\nscores = bb_agent.score_next_moves(board)\nprint(\"Move scores:\", scores)\n# Expected output: [-2, 1, -2, -3, 0, 0, -3]\n\n# Now YELLOW must also play in column 1 to win the game\n# (column indices start at 0, so column 1 is the second from the left)\n</code></pre>"},{"location":"gui_c4/","title":"gui_c4","text":"<p>GUI module for the BitBully Connect-4 interactive widget.</p>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4","title":"<code>GuiC4</code>","text":"<p>A class which allows to create an interactive Connect-4 widget.</p> <p>GuiC4 is an interactive Connect-4 graphical user interface (GUI) implemented using Matplotlib, IPython widgets, and a backend agent from the BitBully engine. It provides the following main features:</p> <ul> <li>Interactive Game Board: Presents a dynamic 6-row by 7-column     Connect-4 board with clickable board cells.</li> <li>Matplotlib Integration: Utilizes Matplotlib figures     to render high-quality game visuals directly within Jupyter notebook environments.</li> <li>User Interaction: Captures and processes mouse clicks and button events, enabling     intuitive gameplay via either direct board interaction or button controls.</li> <li>Undo/Redo Moves: Supports undo and redo functionalities, allowing users to     navigate through their move history during gameplay.</li> <li>Automated Agent Moves: Incorporates BitBully, a Connect-4 backend engine, enabling     computer-generated moves and board evaluations.</li> <li>Game State Handling: Detects game-over scenarios, including win/draw conditions,     and provides immediate user feedback through popup alerts.</li> </ul> <p>Attributes:</p> Name Type Description <code>notify_output</code> <code>Output</code> <p>Output widget for notifications and popups.</p> <p>Examples:</p> <p>Generally, you should this method to retreive and display the widget.</p> <pre><code>&gt;&gt;&gt; %matplotlib ipympl\n&gt;&gt;&gt; c4gui = GuiC4()\n&gt;&gt;&gt; display(c4gui.get_widget())\n</code></pre> Source code in <code>src/bitbully/gui_c4.py</code> <pre><code>class GuiC4:\n    \"\"\"A class which allows to create an interactive Connect-4 widget.\n\n    GuiC4 is an interactive Connect-4 graphical user interface (GUI) implemented using\n    Matplotlib, IPython widgets, and a backend agent from the BitBully engine. It\n    provides the following main features:\n\n    - Interactive Game Board: Presents a dynamic 6-row by 7-column\n        Connect-4 board with clickable board cells.\n    - Matplotlib Integration: Utilizes Matplotlib figures\n        to render high-quality game visuals directly within Jupyter notebook environments.\n    - User Interaction: Captures and processes mouse clicks and button events, enabling\n        intuitive gameplay via either direct board interaction or button controls.\n    - Undo/Redo Moves: Supports undo and redo functionalities, allowing users to\n        navigate through their move history during gameplay.\n    - Automated Agent Moves: Incorporates BitBully, a Connect-4 backend engine, enabling\n        computer-generated moves and board evaluations.\n    - Game State Handling: Detects game-over scenarios, including win/draw conditions,\n        and provides immediate user feedback through popup alerts.\n\n    Attributes:\n        notify_output (widgets.Output): Output widget for notifications and popups.\n\n    Examples:\n            Generally, you should this method to retreive and display the widget.\n\n            ```pycon\n            &gt;&gt;&gt; %matplotlib ipympl\n            &gt;&gt;&gt; c4gui = GuiC4()\n            &gt;&gt;&gt; display(c4gui.get_widget())\n            ```\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Init the GuiC4 widget.\"\"\"\n        # Create a logger with the class name\n        self.m_logger = logging.getLogger(self.__class__.__name__)\n        self.m_logger.setLevel(logging.DEBUG)  # Set the logging level\n\n        # Create a console handler (optional)\n        ch = logging.StreamHandler()\n        ch.setLevel(logging.INFO)  # Set level for the handler\n\n        # Create a formatter and add it to the handler\n        formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n        ch.setFormatter(formatter)\n\n        # Add the handler to the logger\n        self.m_logger.addHandler(ch)\n\n        # Avoid adding handlers multiple times\n        self.m_logger.propagate = False\n        assets_pth = Path(str(importlib.resources.files(\"bitbully\").joinpath(\"assets\")))\n        png_empty = plt.imread(assets_pth.joinpath(\"empty.png\"), format=None)\n        png_empty_m = plt.imread(assets_pth.joinpath(\"empty_m.png\"), format=None)\n        png_empty_r = plt.imread(assets_pth.joinpath(\"empty_r.png\"), format=None)\n        png_red = plt.imread(assets_pth.joinpath(\"red.png\"), format=None)\n        png_red_m = plt.imread(assets_pth.joinpath(\"red_m.png\"), format=None)\n        png_yellow = plt.imread(assets_pth.joinpath(\"yellow.png\"), format=None)\n        png_yellow_m = plt.imread(assets_pth.joinpath(\"yellow_m.png\"), format=None)\n        self.m_png = {\n            0: {\"plain\": png_empty, \"corner\": png_empty_m, \"underline\": png_empty_r},\n            1: {\"plain\": png_yellow, \"corner\": png_yellow_m},\n            2: {\"plain\": png_red, \"corner\": png_red_m},\n        }\n\n        self.m_n_row, self.m_n_col = 6, 7\n\n        # TODO: probably not needed:\n        self.m_height = np.zeros(7, dtype=np.int32)\n\n        self.m_board_size = 3.5\n        # self.m_player = 1\n        self.is_busy = False\n\n        self.last_event_time = time.time()\n\n        # Create board first\n        self._create_board()\n\n        # Generate buttons for inserting the tokens:\n        self._create_buttons()\n\n        # Create control buttons\n        self._create_control_buttons()\n\n        # Capture clicks on the field\n        _ = self.m_fig.canvas.mpl_connect(\"button_press_event\", self._on_field_click)\n\n        # Movelist\n        self.m_movelist: list[tuple[int, int, int]] = []\n\n        # Redo list\n        self.m_redolist: list[tuple[int, int, int]] = []\n\n        # Gameover flag:\n        self.m_gameover = False\n\n        # C4 agent\n        import bitbully_databases as bbd\n\n        # TODO: allow choosing opening book\n        db_path: str = bbd.BitBullyDatabases.get_database_path(\"12-ply-dist\")\n        self.bitbully_agent = bitbully_core.BitBullyCore(Path(db_path))\n\n    def _reset(self) -&gt; None:\n        self.m_movelist = []\n        self.m_redolist = []\n        self.m_height = np.zeros(7, dtype=np.int32)\n        self.m_gameover = False\n\n        for im in self.ims:\n            im.set_data(self.m_png[0][\"plain\"])\n\n        self.m_fig.canvas.draw_idle()\n        self.m_fig.canvas.flush_events()\n        self._update_insert_buttons()\n\n    def _get_fig_size_px(self) -&gt; npt.NDArray[np.float64]:\n        # Get the size in inches\n        size_in_inches = self.m_fig.get_size_inches()\n        self.m_logger.debug(\"Figure size in inches: %f\", size_in_inches)\n\n        # Get the DPI\n        dpi = self.m_fig.dpi\n        self.m_logger.debug(\"Figure DPI: %d\", dpi)\n\n        # Convert to pixels\n        return size_in_inches * dpi\n\n    def _create_control_buttons(self) -&gt; None:\n        self.m_control_buttons = {}\n\n        # Create buttons for each column\n        self.m_logger.debug(\"Figure size: \", self._get_fig_size_px())\n\n        fig_size_px = self._get_fig_size_px()\n        wh = f\"{-3 + (fig_size_px[1] / self.m_n_row)}px\"\n        btn_layout = Layout(height=wh, width=wh)\n\n        button = Button(description=\"\ud83d\udd04\", tooltip=\"Reset Game\", layout=btn_layout)\n        button.on_click(lambda b: self._reset())\n        self.m_control_buttons[\"reset\"] = button\n\n        button = Button(description=\"\u21a9\ufe0f\", tooltip=\"Undo Move\", layout=btn_layout)\n        button.disabled = True\n        button.on_click(lambda b: self._undo_move())\n        self.m_control_buttons[\"undo\"] = button\n\n        button = Button(description=\"\u21aa\ufe0f\", tooltip=\"Redo Move\", layout=btn_layout)\n        button.disabled = True\n        button.on_click(lambda b: self._redo_move())\n        self.m_control_buttons[\"redo\"] = button\n\n        button = Button(description=\"\ud83d\udd79\ufe0f\", tooltip=\"Computer Move\", layout=btn_layout)\n        button.on_click(lambda b: self._computer_move())\n        self.m_control_buttons[\"move\"] = button\n\n        button = Button(description=\"\ud83d\udcca\", tooltip=\"Evaluate Board\", layout=btn_layout)\n        self.m_control_buttons[\"evaluate\"] = button\n\n    def _computer_move(self) -&gt; None:\n        self.is_busy = True\n        self._update_insert_buttons()\n        b = bitbully_core.BoardCore()\n        assert b.setBoard([mv[1] for mv in self.m_movelist])\n        move_scores = self.bitbully_agent.scoreMoves(b)\n        self.is_busy = False\n        self._insert_token(int(np.argmax(move_scores)))\n\n    def _create_board(self) -&gt; None:\n        self.output = Output()\n\n        with self.output:\n            fig, axs = plt.subplots(\n                self.m_n_row,\n                self.m_n_col,\n                figsize=(\n                    self.m_board_size / self.m_n_row * self.m_n_col,\n                    self.m_board_size,\n                ),\n            )\n            axs = axs.flatten()\n            self.ims = []\n            for ax in axs:\n                self.ims.append(ax.imshow(self.m_png[0][\"plain\"], animated=True))\n                ax.axis(\"off\")\n                ax.set_xticklabels([])\n                ax.set_yticklabels([])\n\n            fig.tight_layout()\n            plt.subplots_adjust(wspace=0.05, hspace=0.05, left=0.0, right=1.0, top=1.0, bottom=0.0)\n            fig.suptitle(\"\")\n            fig.set_facecolor(\"darkgray\")\n            fig.canvas.toolbar_visible = False  # type: ignore[attr-defined]\n            fig.canvas.resizable = False  # type: ignore[attr-defined]\n            fig.canvas.toolbar_visible = False  # type: ignore[attr-defined]\n            fig.canvas.header_visible = False  # type: ignore[attr-defined]\n            fig.canvas.footer_visible = False  # type: ignore[attr-defined]\n            fig.canvas.capture_scroll = True  # type: ignore[attr-defined]\n            plt.show(block=False)\n\n        self.m_fig = fig\n        self.m_axs = axs\n\n    notify_output: widgets.Output = widgets.Output()\n    display(notify_output)\n\n    @notify_output.capture()\n    def _popup(self, text: str) -&gt; None:\n        clear_output()\n        display(Javascript(f\"alert('{text}')\"))\n\n    def _is_legal_move(self, col: int) -&gt; bool:\n        return not self.m_height[col] &gt;= self.m_n_row\n\n    def _insert_token(self, col: int, reset_redo_list: bool = True) -&gt; None:\n        if self.is_busy:\n            return\n        self.is_busy = True\n\n        for button in self.m_insert_buttons:\n            button.disabled = True\n\n        board = bitbully_core.BoardCore()\n        board.setBoard([mv[1] for mv in self.m_movelist])\n        if self.m_gameover or not board.play(col):\n            self._update_insert_buttons()\n            self.is_busy = False\n            return\n\n        try:\n            # Get player\n            player = 1 if not self.m_movelist else 3 - self.m_movelist[-1][0]\n            self.m_movelist.append((player, col, self.m_height[col]))\n            self._paint_token()\n            self.m_height[col] += 1\n\n            # Usually, after a move is performed, there is no possibility to\n            # redo a move again\n            if reset_redo_list:\n                self.m_redolist = []\n\n            self._check_winner(board)\n\n        except Exception as e:\n            self.m_logger.error(\"Error: %s\", str(e))\n            raise\n        finally:\n            time.sleep(0.5)  # debounce button\n            # Re-enable all buttons (if columns not full)\n            self.is_busy = False\n            self._update_insert_buttons()\n\n    def _redo_move(self) -&gt; None:\n        if len(self.m_redolist) &lt; 1:\n            return\n        _p, col, _row = self.m_redolist.pop()\n        self._insert_token(col, reset_redo_list=False)\n\n    def _undo_move(self) -&gt; None:\n        if len(self.m_movelist) &lt; 1:\n            return\n\n        if self.is_busy:\n            return\n        self.is_busy = True\n\n        try:\n            _p, col, row = mv = self.m_movelist.pop()\n            self.m_redolist.append(mv)\n\n            self.m_height[col] -= 1\n            assert row == self.m_height[col]\n\n            img_idx = self._get_img_idx(col, row)\n\n            self.ims[img_idx].set_data(self.m_png[0][\"plain\"])\n            self.m_axs[img_idx].draw_artist(self.ims[img_idx])\n            if len(self.m_movelist) &gt; 0:\n                self._paint_token()\n            else:\n                self.m_fig.canvas.blit(self.ims[img_idx].get_clip_box())\n                self.m_fig.canvas.flush_events()\n\n            self.m_gameover = False\n\n        except Exception as e:\n            self.m_logger.error(\"Error: %s\", str(e))\n            raise\n        finally:\n            # Re-enable all buttons (if columns not full)\n            self.is_busy = False\n            self._update_insert_buttons()\n\n            time.sleep(0.5)  # debounce button\n\n    def _update_insert_buttons(self) -&gt; None:\n        for button, col in zip(self.m_insert_buttons, range(self.m_n_col)):\n            button.disabled = bool(self.m_height[col] &gt;= self.m_n_row) or self.m_gameover or self.is_busy\n\n        self.m_control_buttons[\"undo\"].disabled = len(self.m_movelist) &lt; 1 or self.is_busy\n        self.m_control_buttons[\"redo\"].disabled = len(self.m_redolist) &lt; 1 or self.is_busy\n        self.m_control_buttons[\"move\"].disabled = self.m_gameover or self.is_busy\n        self.m_control_buttons[\"evaluate\"].disabled = self.m_gameover or self.is_busy\n\n    def _get_img_idx(self, col: int, row: int) -&gt; int:\n        \"\"\"Translates a column and row ID into the corresponding image ID.\n\n        Args:\n            col (int): column (0-6) of the considered board cell.\n            row (int): row (0-5) of the considered board cell.\n\n        Returns:\n            int: The corresponding image id (0-41).\n        \"\"\"\n        self.m_logger.debug(\"Got column: %d\", col)\n\n        return col % self.m_n_col + (self.m_n_row - row - 1) * self.m_n_col\n\n    def _paint_token(self) -&gt; None:\n        if len(self.m_movelist) &lt; 1:\n            return\n\n        p, col, row = self.m_movelist[-1]\n        img_idx = self._get_img_idx(col, row)\n        self.m_logger.debug(\"Paint token: %d\", img_idx)\n\n        #\n        # no need to reset background, since we anyhow overwrite it again\n        # self.m_fig.canvas.restore_region(self.m_background[img_idx])\n        self.ims[img_idx].set_data(self.m_png[p][\"corner\"])\n\n        # see: https://matplotlib.org/3.4.3/Matplotlib.pdf\n        #      2.3.1 Faster rendering by using blitting\n        blit_boxes = []\n        self.m_axs[img_idx].draw_artist(self.ims[img_idx])\n        blit_boxes.append(self.ims[img_idx].get_clip_box())\n        # self.m_fig.canvas.blit()\n\n        if len(self.m_movelist) &gt; 1:\n            # Remove the white corners for the second-to-last move\n            # TODO: redundant code above\n            p, col, row = self.m_movelist[-2]\n            img_idx = self._get_img_idx(col, row)\n            self.ims[img_idx].set_data(self.m_png[p][\"plain\"])\n            self.m_axs[img_idx].draw_artist(self.ims[img_idx])\n            blit_boxes.append(self.ims[img_idx].get_clip_box())\n\n        self.m_fig.canvas.blit(blit_boxes[0])\n\n        # self.m_fig.canvas.restore_region(self.m_background[img_idx])\n        # self.m_fig.canvas.blit(self.ims[img_idx].get_clip_box())\n        # self.m_fig.canvas.draw_idle()\n        self.m_fig.canvas.flush_events()\n\n    def _create_buttons(self) -&gt; None:\n        # Create buttons for each column\n        self.m_logger.debug(\"Figure size: \", self._get_fig_size_px())\n\n        fig_size_px = self._get_fig_size_px()\n\n        self.m_insert_buttons = []\n        for col in range(self.m_n_col):\n            button = Button(\n                description=\"\u23ec\",\n                layout=Layout(width=f\"{-3 + (fig_size_px[0] / self.m_n_col)}px\", height=\"50px\"),\n            )\n            button.on_click(lambda b, col=col: self._insert_token(col))\n            self.m_insert_buttons.append(button)\n\n    def _create_column_labels(self) -&gt; HBox:\n        \"\"\"Creates a row with the column labels 'a' to 'g'.\n\n        Returns:\n            HBox: A row of textboxes containing the columns labels 'a' to 'g'.\n        \"\"\"\n        fig_size_px = self._get_fig_size_px()\n        width = f\"{-3 + (fig_size_px[0] / self.m_n_col)}px\"\n        textboxes = [\n            widgets.Label(\n                value=chr(ord(\"a\") + i),\n                layout=Layout(justify_content=\"center\", align_items=\"center\", width=width),\n            )\n            for i in range(self.m_n_col)\n        ]\n        return HBox(\n            textboxes,\n            layout=Layout(\n                display=\"flex\",\n                flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n                justify_content=\"center\",  # Left alignment\n                align_items=\"center\",  # Top alignment\n            ),\n        )\n\n    def _on_field_click(self, event: mpl_backend_bases.Event) -&gt; None:\n        \"\"\"Based on the column where the click was detected, insert a token.\n\n        Args:\n            event (mpl_backend_bases.Event): A matplotlib mouse event.\n        \"\"\"\n        if isinstance(event, mpl_backend_bases.MouseEvent):\n            ix, iy = event.xdata, event.ydata\n            self.m_logger.debug(\"click (x,y): %d, %d\", ix, iy)\n            idx = np.where(self.m_axs == event.inaxes)[0][0] % self.m_n_col\n            self._insert_token(idx)\n\n    def get_widget(self) -&gt; AppLayout:\n        \"\"\"Get the widget.\n\n        Examples:\n            Generally, you should this method to retreive and display the widget.\n\n            ```pycon\n            &gt;&gt;&gt; %matplotlib ipympl\n            &gt;&gt;&gt; c4gui = GuiC4()\n            &gt;&gt;&gt; display(c4gui.get_widget())\n            ```\n\n        Returns:\n            AppLayout: the widget.\n        \"\"\"\n        # Arrange buttons in a row\n        insert_button_row = HBox(\n            self.m_insert_buttons,\n            layout=Layout(\n                display=\"flex\",\n                flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n                justify_content=\"center\",  # Left alignment\n                align_items=\"center\",  # Top alignment\n            ),\n        )\n        control_buttons_col = HBox(\n            [VBox(list(self.m_control_buttons.values()))],\n            layout=Layout(\n                display=\"flex\",\n                flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n                justify_content=\"flex-end\",  # Left alignment\n                align_items=\"center\",  # Top alignment\n            ),\n        )\n\n        tb = self._create_column_labels()\n\n        return AppLayout(\n            header=None,\n            left_sidebar=control_buttons_col,\n            center=VBox(\n                [insert_button_row, self.output, tb],\n                layout=Layout(\n                    display=\"flex\",\n                    flex_flow=\"column wrap\",\n                    justify_content=\"flex-start\",  # Left alignment\n                    align_items=\"flex-start\",  # Top alignment\n                ),\n            ),\n            footer=None,\n            right_sidebar=None,\n        )\n\n    def _check_winner(self, board: bitbully_core.BoardCore) -&gt; None:\n        \"\"\"Check for Win or draw.\"\"\"\n        if board.hasWin():\n            winner = \"Yellow\" if board.movesLeft() % 2 else \"Red\"\n            self._popup(f\"Game over! {winner} wins!\")\n            self.m_gameover = True\n        if board.movesLeft() == 0:\n            self._popup(\"Game over! Draw!\")\n            self.m_gameover = True\n\n    def destroy(self) -&gt; None:\n        \"\"\"Destroy and release the acquired resources.\"\"\"\n        plt.close(self.m_fig)\n        del self.bitbully_agent\n        del self.m_axs\n        del self.m_fig\n        del self.output\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.__init__","title":"<code>__init__()</code>","text":"<p>Init the GuiC4 widget.</p> Source code in <code>src/bitbully/gui_c4.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Init the GuiC4 widget.\"\"\"\n    # Create a logger with the class name\n    self.m_logger = logging.getLogger(self.__class__.__name__)\n    self.m_logger.setLevel(logging.DEBUG)  # Set the logging level\n\n    # Create a console handler (optional)\n    ch = logging.StreamHandler()\n    ch.setLevel(logging.INFO)  # Set level for the handler\n\n    # Create a formatter and add it to the handler\n    formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n    ch.setFormatter(formatter)\n\n    # Add the handler to the logger\n    self.m_logger.addHandler(ch)\n\n    # Avoid adding handlers multiple times\n    self.m_logger.propagate = False\n    assets_pth = Path(str(importlib.resources.files(\"bitbully\").joinpath(\"assets\")))\n    png_empty = plt.imread(assets_pth.joinpath(\"empty.png\"), format=None)\n    png_empty_m = plt.imread(assets_pth.joinpath(\"empty_m.png\"), format=None)\n    png_empty_r = plt.imread(assets_pth.joinpath(\"empty_r.png\"), format=None)\n    png_red = plt.imread(assets_pth.joinpath(\"red.png\"), format=None)\n    png_red_m = plt.imread(assets_pth.joinpath(\"red_m.png\"), format=None)\n    png_yellow = plt.imread(assets_pth.joinpath(\"yellow.png\"), format=None)\n    png_yellow_m = plt.imread(assets_pth.joinpath(\"yellow_m.png\"), format=None)\n    self.m_png = {\n        0: {\"plain\": png_empty, \"corner\": png_empty_m, \"underline\": png_empty_r},\n        1: {\"plain\": png_yellow, \"corner\": png_yellow_m},\n        2: {\"plain\": png_red, \"corner\": png_red_m},\n    }\n\n    self.m_n_row, self.m_n_col = 6, 7\n\n    # TODO: probably not needed:\n    self.m_height = np.zeros(7, dtype=np.int32)\n\n    self.m_board_size = 3.5\n    # self.m_player = 1\n    self.is_busy = False\n\n    self.last_event_time = time.time()\n\n    # Create board first\n    self._create_board()\n\n    # Generate buttons for inserting the tokens:\n    self._create_buttons()\n\n    # Create control buttons\n    self._create_control_buttons()\n\n    # Capture clicks on the field\n    _ = self.m_fig.canvas.mpl_connect(\"button_press_event\", self._on_field_click)\n\n    # Movelist\n    self.m_movelist: list[tuple[int, int, int]] = []\n\n    # Redo list\n    self.m_redolist: list[tuple[int, int, int]] = []\n\n    # Gameover flag:\n    self.m_gameover = False\n\n    # C4 agent\n    import bitbully_databases as bbd\n\n    # TODO: allow choosing opening book\n    db_path: str = bbd.BitBullyDatabases.get_database_path(\"12-ply-dist\")\n    self.bitbully_agent = bitbully_core.BitBullyCore(Path(db_path))\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.destroy","title":"<code>destroy()</code>","text":"<p>Destroy and release the acquired resources.</p> Source code in <code>src/bitbully/gui_c4.py</code> <pre><code>def destroy(self) -&gt; None:\n    \"\"\"Destroy and release the acquired resources.\"\"\"\n    plt.close(self.m_fig)\n    del self.bitbully_agent\n    del self.m_axs\n    del self.m_fig\n    del self.output\n</code></pre>"},{"location":"gui_c4/#src.bitbully.gui_c4.GuiC4.get_widget","title":"<code>get_widget()</code>","text":"<p>Get the widget.</p> <p>Examples:</p> <p>Generally, you should this method to retreive and display the widget.</p> <pre><code>&gt;&gt;&gt; %matplotlib ipympl\n&gt;&gt;&gt; c4gui = GuiC4()\n&gt;&gt;&gt; display(c4gui.get_widget())\n</code></pre> <p>Returns:</p> Name Type Description <code>AppLayout</code> <code>AppLayout</code> <p>the widget.</p> Source code in <code>src/bitbully/gui_c4.py</code> <pre><code>def get_widget(self) -&gt; AppLayout:\n    \"\"\"Get the widget.\n\n    Examples:\n        Generally, you should this method to retreive and display the widget.\n\n        ```pycon\n        &gt;&gt;&gt; %matplotlib ipympl\n        &gt;&gt;&gt; c4gui = GuiC4()\n        &gt;&gt;&gt; display(c4gui.get_widget())\n        ```\n\n    Returns:\n        AppLayout: the widget.\n    \"\"\"\n    # Arrange buttons in a row\n    insert_button_row = HBox(\n        self.m_insert_buttons,\n        layout=Layout(\n            display=\"flex\",\n            flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n            justify_content=\"center\",  # Left alignment\n            align_items=\"center\",  # Top alignment\n        ),\n    )\n    control_buttons_col = HBox(\n        [VBox(list(self.m_control_buttons.values()))],\n        layout=Layout(\n            display=\"flex\",\n            flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n            justify_content=\"flex-end\",  # Left alignment\n            align_items=\"center\",  # Top alignment\n        ),\n    )\n\n    tb = self._create_column_labels()\n\n    return AppLayout(\n        header=None,\n        left_sidebar=control_buttons_col,\n        center=VBox(\n            [insert_button_row, self.output, tb],\n            layout=Layout(\n                display=\"flex\",\n                flex_flow=\"column wrap\",\n                justify_content=\"flex-start\",  # Left alignment\n                align_items=\"flex-start\",  # Top alignment\n            ),\n        ),\n        footer=None,\n        right_sidebar=None,\n    )\n</code></pre>"},{"location":"user_guide/","title":"BitBully User Guide","text":""}]}