{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"python/","title":"BitBully API Reference","text":""},{"location":"python/#main","title":"Main","text":"<p>Currently, a dummy module.</p> <p>GUI module for the BitBully Connect-4 interactive widget.</p>"},{"location":"python/#src.bitbully.main.greet","title":"<code>greet(name)</code>","text":"<p>A dummy function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name to print.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A dummy sentence.</p> Source code in <code>src/bitbully/main.py</code> <pre><code>def greet(name: str) -&gt; str:\n    \"\"\"A dummy function.\n\n    Args:\n        name (str): the name to print.\n\n    Returns:\n        str: A dummy sentence.\n    \"\"\"\n    return f\"Hello world, {name}!\"\n</code></pre>"},{"location":"python/#src.bitbully.gui_c4.GuiC4","title":"<code>GuiC4</code>","text":"<p>A class which allows to create an interactive Connect-4 widget.</p> <p>GuiC4 is an interactive Connect-4 graphical user interface (GUI) implemented using Matplotlib, IPython widgets, and a backend agent from the BitBully engine. It provides the following main features:</p> <ul> <li>Interactive Game Board: Presents a dynamic 6-row by 7-column   Connect-4 board with clickable board cells.</li> <li>Matplotlib Integration: Utilizes Matplotlib figures   to render high-quality game visuals directly within Jupyter notebook environments.</li> <li>User Interaction: Captures and processes mouse clicks and button events, enabling   intuitive gameplay via either direct board interaction or button controls.</li> <li>Undo/Redo Moves: Supports undo and redo functionalities, allowing users to   navigate through their move history during gameplay.</li> <li>Automated Agent Moves: Incorporates BitBully, a Connect-4 backend engine, enabling   computer-generated moves and board evaluations.</li> <li>Game State Handling: Detects game-over scenarios, including win/draw conditions,   and provides immediate user feedback through popup alerts.</li> </ul> <p>Examples:</p> <p>Generally, you should this method to retreive and display the widget.</p> <pre><code>&gt;&gt;&gt; %matplotlib ipympl\n&gt;&gt;&gt; c4gui = GuiC4()\n&gt;&gt;&gt; display(c4gui.get_widget())\n</code></pre> Source code in <code>src/bitbully/gui_c4.py</code> <pre><code>class GuiC4:\n    \"\"\"A class which allows to create an interactive Connect-4 widget.\n\n    GuiC4 is an interactive Connect-4 graphical user interface (GUI) implemented using\n    Matplotlib, IPython widgets, and a backend agent from the BitBully engine. It\n    provides the following main features:\n\n    - Interactive Game Board: Presents a dynamic 6-row by 7-column\n      Connect-4 board with clickable board cells.\n    - Matplotlib Integration: Utilizes Matplotlib figures\n      to render high-quality game visuals directly within Jupyter notebook environments.\n    - User Interaction: Captures and processes mouse clicks and button events, enabling\n      intuitive gameplay via either direct board interaction or button controls.\n    - Undo/Redo Moves: Supports undo and redo functionalities, allowing users to\n      navigate through their move history during gameplay.\n    - Automated Agent Moves: Incorporates BitBully, a Connect-4 backend engine, enabling\n      computer-generated moves and board evaluations.\n    - Game State Handling: Detects game-over scenarios, including win/draw conditions,\n      and provides immediate user feedback through popup alerts.\n\n    Examples:\n        Generally, you should this method to retreive and display the widget.\n\n        ```pycon\n        &gt;&gt;&gt; %matplotlib ipympl\n        &gt;&gt;&gt; c4gui = GuiC4()\n        &gt;&gt;&gt; display(c4gui.get_widget())\n        ```\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Init the GuiC4 widget.\"\"\"\n        # Create a logger with the class name\n        self.m_logger = logging.getLogger(self.__class__.__name__)\n        self.m_logger.setLevel(logging.DEBUG)  # Set the logging level\n\n        # Create a console handler (optional)\n        ch = logging.StreamHandler()\n        ch.setLevel(logging.INFO)  # Set level for the handler\n\n        # Create a formatter and add it to the handler\n        formatter = logging.Formatter(\n            \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n        )\n        ch.setFormatter(formatter)\n\n        # Add the handler to the logger\n        self.m_logger.addHandler(ch)\n\n        # Avoid adding handlers multiple times\n        self.m_logger.propagate = False\n        assets_pth = Path(str(importlib.resources.files(\"bitbully\").joinpath(\"assets\")))\n        png_empty = plt.imread(assets_pth.joinpath(\"empty.png\"), format=None)\n        png_empty_m = plt.imread(assets_pth.joinpath(\"empty_m.png\"), format=None)\n        png_empty_r = plt.imread(assets_pth.joinpath(\"empty_r.png\"), format=None)\n        png_red = plt.imread(assets_pth.joinpath(\"red.png\"), format=None)\n        png_red_m = plt.imread(assets_pth.joinpath(\"red_m.png\"), format=None)\n        png_yellow = plt.imread(assets_pth.joinpath(\"yellow.png\"), format=None)\n        png_yellow_m = plt.imread(assets_pth.joinpath(\"yellow_m.png\"), format=None)\n        self.m_png = {\n            0: {\"plain\": png_empty, \"corner\": png_empty_m, \"underline\": png_empty_r},\n            1: {\"plain\": png_yellow, \"corner\": png_yellow_m},\n            2: {\"plain\": png_red, \"corner\": png_red_m},\n        }\n\n        self.m_n_row, self.m_n_col = 6, 7\n\n        # TODO: probably not needed:\n        self.m_height = np.zeros(7, dtype=np.int32)\n\n        self.m_board_size = 3.5\n        # self.m_player = 1\n        self.is_busy = False\n\n        self.last_event_time = time.time()\n\n        # Create board first\n        self._create_board()\n\n        # Generate buttons for inserting the tokens:\n        self._create_buttons()\n\n        # Create control buttons\n        self._create_control_buttons()\n\n        # Capture clicks on the field\n        _ = self.m_fig.canvas.mpl_connect(\"button_press_event\", self._on_field_click)\n\n        # Movelist\n        self.m_movelist: list[tuple[int, int, int]] = []\n\n        # Redo list\n        self.m_redolist: list[tuple[int, int, int]] = []\n\n        # Gameover flag:\n        self.m_gameover = False\n\n        # C4 agent\n        db_path = importlib.resources.files(\"bitbully\").joinpath(\n            \"assets/book_12ply_distances.dat\"\n        )\n        self.bitbully_agent = bitbully_core.BitBully(db_path)\n\n    def _reset(self) -&gt; None:\n        self.m_movelist = []\n        self.m_redolist = []\n        self.m_height = np.zeros(7, dtype=np.int32)\n        self.m_gameover = False\n\n        for im in self.ims:\n            im.set_data(self.m_png[0][\"plain\"])\n\n        self.m_fig.canvas.draw_idle()\n        self.m_fig.canvas.flush_events()\n        self._update_insert_buttons()\n\n    def _get_fig_size_px(self) -&gt; npt.NDArray[np.float32]:\n        # Get the size in inches\n        size_in_inches = self.m_fig.get_size_inches()\n        self.m_logger.debug(\"Figure size in inches: %f\", size_in_inches)\n\n        # Get the DPI\n        dpi = self.m_fig.dpi\n        self.m_logger.debug(\"Figure DPI: %d\", dpi)\n\n        # Convert to pixels\n        return size_in_inches * dpi\n\n    def _create_control_buttons(self) -&gt; None:\n        self.m_control_buttons = {}\n\n        # Create buttons for each column\n        self.m_logger.debug(\"Figure size: \", self._get_fig_size_px())\n\n        fig_size_px = self._get_fig_size_px()\n        wh = f\"{-3 + (fig_size_px[1] / self.m_n_row)}px\"\n        btn_layout = Layout(height=wh, width=wh)\n\n        button = Button(description=\"\ud83d\udd04\", tooltip=\"Reset Game\", layout=btn_layout)\n        button.on_click(lambda b: self._reset())\n        self.m_control_buttons[\"reset\"] = button\n\n        button = Button(description=\"\u21a9\ufe0f\", tooltip=\"Undo Move\", layout=btn_layout)\n        button.disabled = True\n        button.on_click(lambda b: self._undo_move())\n        self.m_control_buttons[\"undo\"] = button\n\n        button = Button(description=\"\u21aa\ufe0f\", tooltip=\"Redo Move\", layout=btn_layout)\n        button.disabled = True\n        button.on_click(lambda b: self._redo_move())\n        self.m_control_buttons[\"redo\"] = button\n\n        button = Button(description=\"\ud83d\udd79\ufe0f\", tooltip=\"Computer Move\", layout=btn_layout)\n        button.on_click(lambda b: self._computer_move())\n        self.m_control_buttons[\"move\"] = button\n\n        button = Button(description=\"\ud83d\udcca\", tooltip=\"Evaluate Board\", layout=btn_layout)\n        self.m_control_buttons[\"evaluate\"] = button\n\n    def _computer_move(self) -&gt; None:\n        self.is_busy = True\n        self._update_insert_buttons()\n        b = bitbully_core.Board()\n        assert b.setBoard([mv[1] for mv in self.m_movelist])\n        move_scores = self.bitbully_agent.scoreMoves(b)\n        self.is_busy = False\n        self._insert_token(int(np.argmax(move_scores)))\n\n    def _create_board(self) -&gt; None:\n        self.output = Output()\n\n        with self.output:\n            fig, axs = plt.subplots(\n                self.m_n_row,\n                self.m_n_col,\n                figsize=(\n                    self.m_board_size / self.m_n_row * self.m_n_col,\n                    self.m_board_size,\n                ),\n            )\n            axs = axs.flatten()\n            self.ims = []\n            for ax in axs:\n                self.ims.append(ax.imshow(self.m_png[0][\"plain\"], animated=True))\n                ax.axis(\"off\")\n                ax.set_xticklabels([])\n                ax.set_yticklabels([])\n\n            fig.tight_layout()\n            plt.subplots_adjust(\n                wspace=0.05, hspace=0.05, left=0.0, right=1.0, top=1.0, bottom=0.0\n            )\n            fig.suptitle(\"\")\n            fig.set_facecolor(\"darkgray\")\n            fig.canvas.toolbar_visible = False  # type: ignore[attr-defined]\n            fig.canvas.resizable = False  # type: ignore[attr-defined]\n            fig.canvas.toolbar_visible = False  # type: ignore[attr-defined]\n            fig.canvas.header_visible = False  # type: ignore[attr-defined]\n            fig.canvas.footer_visible = False  # type: ignore[attr-defined]\n            fig.canvas.capture_scroll = True  # type: ignore[attr-defined]\n            plt.show(block=False)\n\n        self.m_fig = fig\n        self.m_axs = axs\n\n    notify_output = widgets.Output()\n    display(notify_output)\n\n    @notify_output.capture()\n    def _popup(self, text: str) -&gt; None:\n        clear_output()\n        display(Javascript(f\"alert('{text}')\"))\n\n    def _is_legal_move(self, col: int) -&gt; bool:\n        return not self.m_height[col] &gt;= self.m_n_row\n\n    def _insert_token(self, col: int, reset_redo_list: bool = True) -&gt; None:\n        if self.is_busy:\n            return\n        self.is_busy = True\n\n        for button in self.m_insert_buttons:\n            button.disabled = True\n\n        board = bitbully_core.Board()\n        board.setBoard([mv[1] for mv in self.m_movelist])\n        if self.m_gameover or not board.playMove(col):\n            self._update_insert_buttons()\n            self.is_busy = False\n            return\n\n        try:\n            # Get player\n            player = 1 if not self.m_movelist else 3 - self.m_movelist[-1][0]\n            self.m_movelist.append((player, col, self.m_height[col]))\n            self._paint_token()\n            self.m_height[col] += 1\n\n            # Usually, after a move is performed, there is no possibility to\n            # redo a move again\n            if reset_redo_list:\n                self.m_redolist = []\n\n            self._check_winner(board)\n\n        except Exception as e:\n            self.m_logger.error(\"Error: %s\", str(e))\n            raise\n        finally:\n            time.sleep(0.5)  # debounce button\n            # Re-enable all buttons (if columns not full)\n            self.is_busy = False\n            self._update_insert_buttons()\n\n    def _redo_move(self) -&gt; None:\n        if len(self.m_redolist) &lt; 1:\n            return\n        _p, col, _row = self.m_redolist.pop()\n        self._insert_token(col, reset_redo_list=False)\n\n    def _undo_move(self) -&gt; None:\n        if len(self.m_movelist) &lt; 1:\n            return\n\n        if self.is_busy:\n            return\n        self.is_busy = True\n\n        try:\n            _p, col, row = mv = self.m_movelist.pop()\n            self.m_redolist.append(mv)\n\n            self.m_height[col] -= 1\n            assert row == self.m_height[col]\n\n            img_idx = self._get_img_idx(col, row)\n\n            self.ims[img_idx].set_data(self.m_png[0][\"plain\"])\n            self.m_axs[img_idx].draw_artist(self.ims[img_idx])\n            if len(self.m_movelist) &gt; 0:\n                self._paint_token()\n            else:\n                self.m_fig.canvas.blit(self.ims[img_idx].get_clip_box())\n                self.m_fig.canvas.flush_events()\n\n            self.m_gameover = False\n\n        except Exception as e:\n            self.m_logger.error(\"Error: %s\", str(e))\n            raise\n        finally:\n            # Re-enable all buttons (if columns not full)\n            self.is_busy = False\n            self._update_insert_buttons()\n\n            time.sleep(0.5)  # debounce button\n\n    def _update_insert_buttons(self) -&gt; None:\n        for button, col in zip(self.m_insert_buttons, range(self.m_n_col)):\n            button.disabled = (\n                bool(self.m_height[col] &gt;= self.m_n_row)\n                or self.m_gameover\n                or self.is_busy\n            )\n\n        self.m_control_buttons[\"undo\"].disabled = (\n            len(self.m_movelist) &lt; 1 or self.is_busy\n        )\n        self.m_control_buttons[\"redo\"].disabled = (\n            len(self.m_redolist) &lt; 1 or self.is_busy\n        )\n        self.m_control_buttons[\"move\"].disabled = self.m_gameover or self.is_busy\n        self.m_control_buttons[\"evaluate\"].disabled = self.m_gameover or self.is_busy\n\n    def _get_img_idx(self, col: int, row: int) -&gt; int:\n        \"\"\"Translates a column and row ID into the corresponding image ID.\n\n        Args:\n            col (int): column (0-6) of the considered board cell.\n            row (int): row (0-5) of the considered board cell.\n\n        Returns:\n            int: The corresponding image id (0-41).\n        \"\"\"\n        self.m_logger.debug(\"Got column: %d\", col)\n\n        return col % self.m_n_col + (self.m_n_row - row - 1) * self.m_n_col\n\n    def _paint_token(self) -&gt; None:\n        if len(self.m_movelist) &lt; 1:\n            return\n\n        p, col, row = self.m_movelist[-1]\n        img_idx = self._get_img_idx(col, row)\n        self.m_logger.debug(\"Paint token: %d\", img_idx)\n\n        #\n        # no need to reset background, since we anyhow overwrite it again\n        # self.m_fig.canvas.restore_region(self.m_background[img_idx])\n        self.ims[img_idx].set_data(self.m_png[p][\"corner\"])\n\n        # see: https://matplotlib.org/3.4.3/Matplotlib.pdf\n        #      2.3.1 Faster rendering by using blitting\n        blit_boxes = []\n        self.m_axs[img_idx].draw_artist(self.ims[img_idx])\n        blit_boxes.append(self.ims[img_idx].get_clip_box())\n        # self.m_fig.canvas.blit()\n\n        if len(self.m_movelist) &gt; 1:\n            # Remove the white corners for the second-to-last move\n            # TODO: redundant code above\n            p, col, row = self.m_movelist[-2]\n            img_idx = self._get_img_idx(col, row)\n            self.ims[img_idx].set_data(self.m_png[p][\"plain\"])\n            self.m_axs[img_idx].draw_artist(self.ims[img_idx])\n            blit_boxes.append(self.ims[img_idx].get_clip_box())\n\n        self.m_fig.canvas.blit(blit_boxes[0])\n\n        # self.m_fig.canvas.restore_region(self.m_background[img_idx])\n        # self.m_fig.canvas.blit(self.ims[img_idx].get_clip_box())\n        # self.m_fig.canvas.draw_idle()\n        self.m_fig.canvas.flush_events()\n\n    def _create_buttons(self) -&gt; None:\n        # Create buttons for each column\n        self.m_logger.debug(\"Figure size: \", self._get_fig_size_px())\n\n        fig_size_px = self._get_fig_size_px()\n\n        self.m_insert_buttons = []\n        for col in range(self.m_n_col):\n            button = Button(\n                description=\"\u23ec\",\n                layout=Layout(\n                    width=f\"{-3 + (fig_size_px[0] / self.m_n_col)}px\", height=\"50px\"\n                ),\n            )\n            button.on_click(lambda b, col=col: self._insert_token(col))\n            self.m_insert_buttons.append(button)\n\n    def _create_column_labels(self) -&gt; HBox:\n        \"\"\"Creates a row with the column labels 'a' to 'g'.\n\n        Returns:\n            HBox: A row of textboxes containing the columns labels 'a' to 'g'.\n        \"\"\"\n        fig_size_px = self._get_fig_size_px()\n        width = f\"{-3 + (fig_size_px[0] / self.m_n_col)}px\"\n        textboxes = [\n            widgets.Label(\n                value=chr(ord(\"a\") + i),\n                layout=Layout(\n                    justify_content=\"center\", align_items=\"center\", width=width\n                ),\n            )\n            for i in range(self.m_n_col)\n        ]\n        return HBox(\n            textboxes,\n            layout=Layout(\n                display=\"flex\",\n                flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n                justify_content=\"center\",  # Left alignment\n                align_items=\"center\",  # Top alignment\n            ),\n        )\n\n    def _on_field_click(self, event: mpl.backend_bases.Event) -&gt; None:\n        \"\"\"Based on the column where the click was detected, insert a token.\n\n        Args:\n            event (mpl.backend_bases.Event): A matplotlib mouse event.\n        \"\"\"\n        if isinstance(event, mpl.backend_bases.MouseEvent):\n            ix, iy = event.xdata, event.ydata\n            self.m_logger.debug(\"click (x,y): %d, %d\", ix, iy)\n            idx = np.where(self.m_axs == event.inaxes)[0][0] % self.m_n_col\n            self._insert_token(idx)\n\n    def get_widget(self) -&gt; AppLayout:\n        \"\"\"Get the widget.\n\n        Examples:\n            Generally, you should this method to retreive and display the widget.\n\n            ```pycon\n            &gt;&gt;&gt; %matplotlib ipympl\n            &gt;&gt;&gt; c4gui = GuiC4()\n            &gt;&gt;&gt; display(c4gui.get_widget())\n            ```\n\n        Returns:\n            AppLayout: the widget.\n        \"\"\"\n        # Arrange buttons in a row\n        insert_button_row = HBox(\n            self.m_insert_buttons,\n            layout=Layout(\n                display=\"flex\",\n                flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n                justify_content=\"center\",  # Left alignment\n                align_items=\"center\",  # Top alignment\n            ),\n        )\n        control_buttons_col = HBox(\n            [VBox(list(self.m_control_buttons.values()))],\n            layout=Layout(\n                display=\"flex\",\n                flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n                justify_content=\"flex-end\",  # Left alignment\n                align_items=\"center\",  # Top alignment\n            ),\n        )\n\n        tb = self._create_column_labels()\n\n        return AppLayout(\n            header=None,\n            left_sidebar=control_buttons_col,\n            center=VBox(\n                [insert_button_row, self.output, tb],\n                layout=Layout(\n                    display=\"flex\",\n                    flex_flow=\"column wrap\",\n                    justify_content=\"flex-start\",  # Left alignment\n                    align_items=\"flex-start\",  # Top alignment\n                ),\n            ),\n            footer=None,\n            right_sidebar=None,\n        )\n\n    def _check_winner(self, board: bitbully_core.Board) -&gt; None:\n        \"\"\"Check for Win or draw.\"\"\"\n        if board.hasWin():\n            winner = \"Yellow\" if board.movesLeft() % 2 else \"Red\"\n            self._popup(f\"Game over! {winner} wins!\")\n            self.m_gameover = True\n        if board.movesLeft() == 0:\n            self._popup(\"Game over! Draw!\")\n            self.m_gameover = True\n\n    def destroy(self) -&gt; None:\n        \"\"\"Destroy and release the acquired resources.\"\"\"\n        plt.close(self.m_fig)\n        del self.bitbully_agent\n        del self.m_axs\n        del self.m_fig\n        del self.output\n</code></pre>"},{"location":"python/#src.bitbully.gui_c4.GuiC4.__init__","title":"<code>__init__()</code>","text":"<p>Init the GuiC4 widget.</p> Source code in <code>src/bitbully/gui_c4.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Init the GuiC4 widget.\"\"\"\n    # Create a logger with the class name\n    self.m_logger = logging.getLogger(self.__class__.__name__)\n    self.m_logger.setLevel(logging.DEBUG)  # Set the logging level\n\n    # Create a console handler (optional)\n    ch = logging.StreamHandler()\n    ch.setLevel(logging.INFO)  # Set level for the handler\n\n    # Create a formatter and add it to the handler\n    formatter = logging.Formatter(\n        \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n    )\n    ch.setFormatter(formatter)\n\n    # Add the handler to the logger\n    self.m_logger.addHandler(ch)\n\n    # Avoid adding handlers multiple times\n    self.m_logger.propagate = False\n    assets_pth = Path(str(importlib.resources.files(\"bitbully\").joinpath(\"assets\")))\n    png_empty = plt.imread(assets_pth.joinpath(\"empty.png\"), format=None)\n    png_empty_m = plt.imread(assets_pth.joinpath(\"empty_m.png\"), format=None)\n    png_empty_r = plt.imread(assets_pth.joinpath(\"empty_r.png\"), format=None)\n    png_red = plt.imread(assets_pth.joinpath(\"red.png\"), format=None)\n    png_red_m = plt.imread(assets_pth.joinpath(\"red_m.png\"), format=None)\n    png_yellow = plt.imread(assets_pth.joinpath(\"yellow.png\"), format=None)\n    png_yellow_m = plt.imread(assets_pth.joinpath(\"yellow_m.png\"), format=None)\n    self.m_png = {\n        0: {\"plain\": png_empty, \"corner\": png_empty_m, \"underline\": png_empty_r},\n        1: {\"plain\": png_yellow, \"corner\": png_yellow_m},\n        2: {\"plain\": png_red, \"corner\": png_red_m},\n    }\n\n    self.m_n_row, self.m_n_col = 6, 7\n\n    # TODO: probably not needed:\n    self.m_height = np.zeros(7, dtype=np.int32)\n\n    self.m_board_size = 3.5\n    # self.m_player = 1\n    self.is_busy = False\n\n    self.last_event_time = time.time()\n\n    # Create board first\n    self._create_board()\n\n    # Generate buttons for inserting the tokens:\n    self._create_buttons()\n\n    # Create control buttons\n    self._create_control_buttons()\n\n    # Capture clicks on the field\n    _ = self.m_fig.canvas.mpl_connect(\"button_press_event\", self._on_field_click)\n\n    # Movelist\n    self.m_movelist: list[tuple[int, int, int]] = []\n\n    # Redo list\n    self.m_redolist: list[tuple[int, int, int]] = []\n\n    # Gameover flag:\n    self.m_gameover = False\n\n    # C4 agent\n    db_path = importlib.resources.files(\"bitbully\").joinpath(\n        \"assets/book_12ply_distances.dat\"\n    )\n    self.bitbully_agent = bitbully_core.BitBully(db_path)\n</code></pre>"},{"location":"python/#src.bitbully.gui_c4.GuiC4.destroy","title":"<code>destroy()</code>","text":"<p>Destroy and release the acquired resources.</p> Source code in <code>src/bitbully/gui_c4.py</code> <pre><code>def destroy(self) -&gt; None:\n    \"\"\"Destroy and release the acquired resources.\"\"\"\n    plt.close(self.m_fig)\n    del self.bitbully_agent\n    del self.m_axs\n    del self.m_fig\n    del self.output\n</code></pre>"},{"location":"python/#src.bitbully.gui_c4.GuiC4.get_widget","title":"<code>get_widget()</code>","text":"<p>Get the widget.</p> <p>Examples:</p> <p>Generally, you should this method to retreive and display the widget.</p> <pre><code>&gt;&gt;&gt; %matplotlib ipympl\n&gt;&gt;&gt; c4gui = GuiC4()\n&gt;&gt;&gt; display(c4gui.get_widget())\n</code></pre> <p>Returns:</p> Name Type Description <code>AppLayout</code> <code>AppLayout</code> <p>the widget.</p> Source code in <code>src/bitbully/gui_c4.py</code> <pre><code>def get_widget(self) -&gt; AppLayout:\n    \"\"\"Get the widget.\n\n    Examples:\n        Generally, you should this method to retreive and display the widget.\n\n        ```pycon\n        &gt;&gt;&gt; %matplotlib ipympl\n        &gt;&gt;&gt; c4gui = GuiC4()\n        &gt;&gt;&gt; display(c4gui.get_widget())\n        ```\n\n    Returns:\n        AppLayout: the widget.\n    \"\"\"\n    # Arrange buttons in a row\n    insert_button_row = HBox(\n        self.m_insert_buttons,\n        layout=Layout(\n            display=\"flex\",\n            flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n            justify_content=\"center\",  # Left alignment\n            align_items=\"center\",  # Top alignment\n        ),\n    )\n    control_buttons_col = HBox(\n        [VBox(list(self.m_control_buttons.values()))],\n        layout=Layout(\n            display=\"flex\",\n            flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n            justify_content=\"flex-end\",  # Left alignment\n            align_items=\"center\",  # Top alignment\n        ),\n    )\n\n    tb = self._create_column_labels()\n\n    return AppLayout(\n        header=None,\n        left_sidebar=control_buttons_col,\n        center=VBox(\n            [insert_button_row, self.output, tb],\n            layout=Layout(\n                display=\"flex\",\n                flex_flow=\"column wrap\",\n                justify_content=\"flex-start\",  # Left alignment\n                align_items=\"flex-start\",  # Top alignment\n            ),\n        ),\n        footer=None,\n        right_sidebar=None,\n    )\n</code></pre>"}]}