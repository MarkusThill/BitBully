{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"BitBully: A fast and perfect-playing Connect-4 Agent for Python 3 &amp; C/C++","text":"<p>BitBully is a high-performance Connect-4 solver built using C++ and Python bindings, leveraging advanced algorithms and optimized bitwise operations. It provides tools for solving and analyzing Connect-4 games efficiently, designed for both developers and researchers.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installing-bitbully","title":"Installing BitBully","text":"<p>Install BitBully via pip:</p> LatestVersion x.y.z <pre><code>pip install bitbully\n</code></pre> <pre><code>pip install bitbully==x.y.z\n</code></pre>"},{"location":"getting_started/#usage","title":"Usage","text":""},{"location":"getting_started/#simple-example","title":"Simple Example","text":"<pre><code>from bitbully import Board, BitBully\n\n# Create an empty Connect Four board\nboard = Board()  # Board is empty at the start\n\n# Players YELLOW and RED alternately drop 5 tokens into the center column (column 3)\nfor _ in range(5):\n    board.play_move(3)  # Place token in center column (index 3)\n\n# RED places one token into the second column from the left (column 1)\nboard.play_move(1)\n\nprint(board)\n# Expected output:\n#  _  _  _  _  _  _  _\n#  _  _  _  X  _  _  _\n#  _  _  _  O  _  _  _\n#  _  _  _  X  _  _  _\n#  _  _  _  O  _  _  _\n#  _  O  _  X  _  _  _\n\n# Use the BitBully AI to evaluate the current board position\nbb_agent = BitBully()\nscores = bb_agent.score_next_moves(board)\nprint(\"Move scores:\", scores)\n# Expected output: [-2, 1, -2, -3, 0, 0, -3]\n\n# Now YELLOW must also play in column 1 to win the game\n# (column indices start at 0, so column 1 is the second from the left)\n</code></pre>"},{"location":"python/","title":"BitBully API Reference","text":""},{"location":"python/#main","title":"Main","text":"<p>BitBully: A Connect Four AI agent with opening book support.</p> <p>This module defines the Board class for managing the state of a Connect Four game.</p> <p>GUI module for the BitBully Connect-4 interactive widget.</p>"},{"location":"python/#src.bitbully.bitbully.BitBully","title":"<code>BitBully</code>","text":"<p>A Connect Four AI agent with opening book support.</p> Source code in <code>src/bitbully/bitbully.py</code> <pre><code>class BitBully:\n    \"\"\"A Connect Four AI agent with opening book support.\"\"\"\n\n    def __init__(self, opening_book: Literal[\"default\", \"8-ply\", \"12-ply\", \"12-ply-dist\"] | None = \"default\") -&gt; None:\n        \"\"\"Initializes the BitBully agent with the specified opening book.\n\n        Args:\n            opening_book (Literal[\"default\", \"8-ply\", \"12-ply\", \"12-ply-dist\"] | None):\n                The type of opening book to use. Options are:\n                - \"default\": Uses the default 12-ply distance-based opening book.\n                - \"8-ply\": Uses an 8-ply opening book.\n                - \"12-ply\": Uses a 12-ply opening book.\n                - \"12-ply-dist\": Uses a 12-ply distance-based opening book.\n                - None: No opening book will be used.\n        \"\"\"\n        from pathlib import Path\n\n        import bitbully_databases as bbd\n\n        self.opening_book_type = opening_book\n\n        if opening_book:\n            db_path = bbd.BitBullyDatabases.get_database_path(opening_book)\n            self.bitbully_agent = bitbully_core.BitBullyCore(Path(db_path))\n        else:\n            self.bitbully_agent = bitbully_core.BitBullyCore()\n\n    def score_next_moves(self, board: Board) -&gt; list[int]:\n        \"\"\"Scores all possible moves for the given board state.\n\n        Args:\n            board (Board):\n                The current board state.\n\n        Returns:\n            list[int]: A list of scores for each column (0-6).\n        \"\"\"\n        return self.bitbully_agent.scoreMoves(board._board)\n</code></pre>"},{"location":"python/#src.bitbully.bitbully.BitBully.__init__","title":"<code>__init__(opening_book='default')</code>","text":"<p>Initializes the BitBully agent with the specified opening book.</p> <p>Parameters:</p> Name Type Description Default <code>opening_book</code> <code>Literal['default', '8-ply', '12-ply', '12-ply-dist'] | None</code> <p>The type of opening book to use. Options are: - \"default\": Uses the default 12-ply distance-based opening book. - \"8-ply\": Uses an 8-ply opening book. - \"12-ply\": Uses a 12-ply opening book. - \"12-ply-dist\": Uses a 12-ply distance-based opening book. - None: No opening book will be used.</p> <code>'default'</code> Source code in <code>src/bitbully/bitbully.py</code> <pre><code>def __init__(self, opening_book: Literal[\"default\", \"8-ply\", \"12-ply\", \"12-ply-dist\"] | None = \"default\") -&gt; None:\n    \"\"\"Initializes the BitBully agent with the specified opening book.\n\n    Args:\n        opening_book (Literal[\"default\", \"8-ply\", \"12-ply\", \"12-ply-dist\"] | None):\n            The type of opening book to use. Options are:\n            - \"default\": Uses the default 12-ply distance-based opening book.\n            - \"8-ply\": Uses an 8-ply opening book.\n            - \"12-ply\": Uses a 12-ply opening book.\n            - \"12-ply-dist\": Uses a 12-ply distance-based opening book.\n            - None: No opening book will be used.\n    \"\"\"\n    from pathlib import Path\n\n    import bitbully_databases as bbd\n\n    self.opening_book_type = opening_book\n\n    if opening_book:\n        db_path = bbd.BitBullyDatabases.get_database_path(opening_book)\n        self.bitbully_agent = bitbully_core.BitBullyCore(Path(db_path))\n    else:\n        self.bitbully_agent = bitbully_core.BitBullyCore()\n</code></pre>"},{"location":"python/#src.bitbully.bitbully.BitBully.score_next_moves","title":"<code>score_next_moves(board)</code>","text":"<p>Scores all possible moves for the given board state.</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Board</code> <p>The current board state.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: A list of scores for each column (0-6).</p> Source code in <code>src/bitbully/bitbully.py</code> <pre><code>def score_next_moves(self, board: Board) -&gt; list[int]:\n    \"\"\"Scores all possible moves for the given board state.\n\n    Args:\n        board (Board):\n            The current board state.\n\n    Returns:\n        list[int]: A list of scores for each column (0-6).\n    \"\"\"\n    return self.bitbully_agent.scoreMoves(board._board)\n</code></pre>"},{"location":"python/#src.bitbully.board.Board","title":"<code>Board</code>","text":"<p>Represents the state of a Connect Four board. Mostly a thin wrapper around BoardCore.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>class Board:\n    \"\"\"Represents the state of a Connect Four board. Mostly a thin wrapper around BoardCore.\"\"\"\n\n    def __init__(self, init_with: Sequence[Sequence[int]] | Sequence[int] | str | None = None) -&gt; None:\n        \"\"\"Initializes a Board instance.\n\n        Args:\n            init_with (Sequence[Sequence[int]] | Sequence[int] | str | None):\n                Optional initial board state. Accepts:\n                - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7\n                - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3])\n                - String: A move sequence of columns as string (e.g., \"002233\")\n                - None for an empty board\n\n        Raises:\n            ValueError: If the provided initial board state is invalid.\n\n        Example:\n            You can initialize an empty board in multiple ways:\n            ```python\n            import bitbully as bb\n\n            # Create an empty board using the default constructor.\n            board = bb.Board()  # Starts with no tokens placed.\n\n            # Alternatively, initialize the board explicitly from a 2D list.\n            # Each inner list represents a column (7 columns total, 6 rows each).\n            # A value of 0 indicates an empty cell; 1 and 2 would represent player tokens.\n            board = bb.Board([[0] * 6 for _ in range(7)])  # Equivalent to an empty board.\n\n            # You can also set up a specific board position manually using a 6 x 7 layout,\n            # where each inner list represents a row instead of a column.\n            # (Both layouts are accepted by BitBully for convenience.)\n            # For more complex examples using 2D arrays, see the examples below.\n            board = bb.Board([[0] * 7 for _ in range(6)])  # Also equivalent to an empty board.\n\n            # Display the board in text form.\n            # The __repr__ method shows the current state (useful for debugging or interactive use).\n            board\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            ```\n\n        The recommended way to initialize an empty board is simply `Board()`.\n\n        Example:\n            You can also initialize a board with a sequence of moves:\n            ```python\n            import bitbully as bb\n\n            # Initialize a board with a sequence of moves played in the center column.\n\n            # The list [3, 3, 3] represents three moves in column index 3 (zero-based).\n            # Moves alternate automatically between Player 1 (yellow, X) and Player 2 (red, O).\n            # After these three moves, the center column will contain:\n            #   - Row 0: Player 1 token (bottom)\n            #   - Row 1: Player 2 token\n            #   - Row 2: Player 1 token\n            board = bb.Board([3, 3, 3])\n\n            # Display the resulting board.\n            # The textual output shows the tokens placed in the center column.\n            board\n            ```\n\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  _  _  X  _  _  _\n            ```\n\n        Example:\n            You can also initialize a board using a string containing a move sequence:\n            ```python\n            import bitbully as bb\n\n            # Initialize a board using a compact move string.\n\n            # The string \"33333111\" represents a sequence of eight moves:\n            #   3 3 3 3 3 \u2192 five moves in the center column (index 3)\n            #   1 1 1 \u2192 three moves in the second column (index 1)\n            #\n            # Moves are applied in order, alternating automatically between Player 1 (yellow, X)\n            # and Player 2 (red, O), just as if you had called `board.play()` repeatedly.\n            #\n            # This shorthand is convenient for reproducing board states or test positions\n            # without having to provide long move lists.\n\n            board = bb.Board(\"33333111\")\n\n            # Display the resulting board.\n            # The printed layout shows how the tokens stack in each column.\n            board\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  O  _  X  _  _  _\n            _  X  _  O  _  _  _\n            _  O  _  X  _  _  _\n            ```\n\n        Example:\n            You can also initialize a board using a 2D array (list of lists):\n            ```python\n            import bitbully as bb\n\n            # Use a 6 x 7 list (rows x columns) to set up a specific board position manually.\n\n            # Each inner list represents a row of the Connect-4 grid.\n            # Convention:\n            #   - 0 \u2192 empty cell\n            #   - 1 \u2192 Player 1 token (yellow, X)\n            #   - 2 \u2192 Player 2 token (red, O)\n            #\n            # The top list corresponds to the *top row* (row index 5),\n            # and the bottom list corresponds to the *bottom row* (row index 0).\n            # This layout matches the typical visual display of the board.\n\n            board_array = [\n                [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n                [0, 0, 0, 1, 0, 0, 0],  # Row 4: Player 1 token in column 3\n                [0, 0, 0, 2, 0, 0, 0],  # Row 3: Player 2 token in column 3\n                [0, 2, 0, 1, 0, 0, 0],  # Row 2: tokens in columns 1 and 3\n                [0, 1, 0, 2, 0, 0, 0],  # Row 1: tokens in columns 1 and 3\n                [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom): tokens stacked lowest\n            ]\n\n            # Create a Board instance directly from the 2D list.\n            # This allows reconstructing arbitrary positions (e.g., from test data or saved states)\n            # without replaying the move sequence.\n            board = bb.Board(board_array)\n\n            # Display the resulting board state in text form.\n            board\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  O  _  X  _  _  _\n            _  X  _  O  _  _  _\n            _  O  _  X  _  _  _\n            ```\n\n        Example:\n            You can also initialize a board using a 2D (7 x 6) array with columns as inner lists:\n            ```python\n            import bitbully as bb\n\n            # Use a 7 x 6 list (columns x rows) to set up a specific board position manually.\n\n            # Each inner list represents a **column** of the Connect-4 board, from left (index 0)\n            # to right (index 6). Each column contains six entries \u2014 one for each row, from\n            # bottom (index 0) to top (index 5).\n            #\n            # Convention:\n            #   - 0 \u2192 empty cell\n            #   - 1 \u2192 Player 1 token (yellow, X)\n            #   - 2 \u2192 Player 2 token (red, O)\n            #\n            # This column-major layout matches the internal representation used by BitBully,\n            # where tokens are dropped into columns rather than filled row by row.\n\n            board_array = [\n                [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)\n                [2, 1, 2, 0, 0, 0],  # Column 1\n                [0, 0, 0, 0, 0, 0],  # Column 2\n                [1, 2, 1, 2, 1, 0],  # Column 3 (center)\n                [0, 0, 0, 0, 0, 0],  # Column 4\n                [0, 0, 0, 0, 0, 0],  # Column 5\n                [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)\n            ]\n\n            # Create a Board instance directly from the 2D list.\n            # This allows reconstructing any arbitrary position (e.g., test cases, saved games)\n            # without replaying all moves individually.\n            board = bb.Board(board_array)\n\n            # Display the resulting board.\n            # The text output shows tokens as they would appear in a real Connect-4 grid.\n            board\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  O  _  X  _  _  _\n            _  X  _  O  _  _  _\n            _  O  _  X  _  _  _\n            ```\n        \"\"\"\n        self._board = bitbully_core.BoardCore()\n        if init_with is not None and not self.reset_board(init_with):\n            raise ValueError(\n                \"Invalid initial board state provided. Check the examples in the docstring for valid formats.\"\n            )\n\n    def __eq__(self, value: object) -&gt; bool:\n        \"\"\"Checks equality between two Board instances.\n\n        Notes:\n            - Equality checks in BitBully compare the *exact board state* (bit patterns),\n              not just the move history.\n            - Two different move sequences can still yield the same position if they\n              result in identical token configurations.\n            - This is useful for comparing solver states, verifying test positions,\n              or detecting transpositions in search algorithms.\n\n        Args:\n            value (object): The other Board instance to compare against.\n\n        Returns:\n            bool: True if both boards are equal, False otherwise.\n\n        Raises:\n            NotImplementedError: If the other value is not a Board instance.\n\n        Example:\n            ```python\n            import bitbully as bb\n\n            # Create two boards that should represent *identical* game states.\n            board1 = bb.Board()\n            assert board1.play(\"33333111\")\n\n            board2 = bb.Board()\n            # Play the same position step by step using a different but equivalent sequence.\n            # Internally, the final bitboard state will match `board1`.\n            assert board2.play(\"31133331\")\n\n            # Boards with identical token placements are considered equal.\n            # Equality (`==`) and inequality (`!=`) operators are overloaded for convenience.\n            assert board1 == board2\n            assert not (board1 != board2)\n\n            # ------------------------------------------------------------------------------\n\n            # Create two boards that differ by one move.\n            board1 = bb.Board(\"33333111\")\n            board2 = bb.Board(\"33333112\")  # One extra move in the last column (index 2)\n\n            # Since the token layout differs, equality no longer holds.\n            assert board1 != board2\n            assert not (board1 == board2)\n            ```\n        \"\"\"\n        if not isinstance(value, Board):\n            raise NotImplementedError(\"Can only compare with another Board instance.\")\n        return bool(self._board == value._board)\n\n    def __ne__(self, value: object) -&gt; bool:\n        \"\"\"Checks inequality between two Board instances.\n\n        See the documentation for [`src.bitbully.Board.__eq__`][src.bitbully.Board.__eq__] for details.\n\n        Args:\n            value (object): The other Board instance to compare against.\n\n        Returns:\n            bool: True if both boards are not equal, False otherwise.\n        \"\"\"\n        return not self.__eq__(value)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Returns a string representation of the Board instance.\"\"\"\n        return f\"{self._board}\"\n\n    def all_positions(self, up_to_n_ply: int, exactly_n: bool) -&gt; list[Board]:\n        \"\"\"Finds all positions on the board up to a certain ply.\n\n        Args:\n            up_to_n_ply (int): The maximum ply depth to search.\n            exactly_n (bool): If True, only returns positions at exactly N ply.\n\n        Returns:\n            list[Board]: A list of Board instances representing all positions.\n        \"\"\"\n        # TODO: Implement this method properly. Need to convert BoardCore instances to Board.\n        # return self._board.all_positions(up_to_n_ply, exactly_n)\n        return [Board()]\n\n    def can_win_next(self, move: int | None = None) -&gt; bool:\n        \"\"\"Checks if the current player can win in the next move.\n\n        Args:\n            move (int | None): Optional column to check for an immediate win. If None, checks all columns.\n\n        Returns:\n            bool: True if the current player can win next, False otherwise.\n\n        See also: [`bitbully.Board.has_win`][src.bitbully.Board.has_win].\n\n        Example:\n            ```python\n            import bitbully as bb\n\n            # Create a board from a move string.\n            # The string \"332311\" represents a short sequence of alternating moves\n            # that results in a nearly winning position for Player 1 (yellow, X).\n            board = bb.Board(\"332311\")\n\n            # Display the current board state (see below)\n            print(board)\n\n            # Player 1 (yellow, X) \u2014 who is next to move \u2014 can win immediately\n            # by placing a token in either column 0 or column 4.\n            assert board.can_win_next(0)\n            assert board.can_win_next(4)\n\n            # However, playing in other columns does not result in an instant win.\n            assert not board.can_win_next(2)\n            assert not board.can_win_next(3)\n\n            # You can also call `can_win_next()` without arguments to perform a general check.\n            # It returns True if the current player has *any* winning move available.\n            assert board.can_win_next()\n            ```\n            The board we created above looks like this:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  O  _  _  _\n            _  O  _  O  _  _  _\n            _  X  X  X  _  _  _\n            ```\n        \"\"\"\n        if move is None:\n            return self._board.canWin()\n        return bool(self._board.canWin(move))\n\n    def copy(self) -&gt; Board:\n        \"\"\"Creates a copy of the current Board instance.\n\n        Returns:\n            Board: A new Board instance that is a copy of the current one.\n        \"\"\"\n        new_board = Board()\n        new_board._board = self._board.copy()\n        return new_board\n\n    def count_tokens(self) -&gt; int:\n        \"\"\"Counts the total number of tokens on the board.\n\n        Returns:\n            int: The total number of tokens.\n        \"\"\"\n        return self._board.countTokens()\n\n    def get_legal_moves(self) -&gt; list[int]:\n        \"\"\"Returns a list of legal moves (columns) that can be played.\n\n        Returns:\n            list[int]: A list of column indices (0-6) where a move can be played.\n\n        Raises:\n            NotImplementedError: If the method is not implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"get_legal_moves is not implemented yet.\")\n\n    def has_win(self) -&gt; bool:\n        \"\"\"Checks if the current player has a winning position.\n\n        Returns:\n            bool: True if the current player has a winning position (4-in-a-row), False otherwise.\n\n        Unlike `can_win_next()`, which checks whether the current player *could* win\n        on their next move, the `has_win()` method determines whether a winning\n        condition already exists on the board.\n        This method is typically used right after a move to verify whether the game\n        has been won.\n\n        See also: [`bitbully.Board.can_win_next`][src.bitbully.Board.can_win_next].\n\n        Example:\n            ```python\n            import bitbully as bb\n\n            # Initialize a board from a move sequence.\n            # The string \"332311\" represents a position where Player 1 (yellow, X)\n            # is one move away from winning.\n            board = bb.Board(\"332311\")\n\n            # At this stage, Player 1 has not yet won, but can win immediately\n            # by placing a token in either column 0 or column 4.\n            assert not board.has_win()\n            assert board.can_win_next(0)  # Check column 0\n            assert board.can_win_next(4)  # Check column 4\n            assert board.can_win_next()  # General check (any winning move)\n\n            # Simulate Player 1 playing in column 4 \u2014 this completes\n            # a horizontal line of four tokens and wins the game.\n            assert board.play(4)\n\n            # Display the updated board to visualize the winning position.\n            print(board)\n\n            # The board now contains a winning configuration:\n            # Player 1 (yellow, X) has achieved a Connect-4.\n            assert board.has_win()\n            ```\n            Board from above, expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  O  _  _  _\n            _  O  _  O  _  _  _\n            _  X  X  X  X  _  _\n            ```\n        \"\"\"\n        return self._board.hasWin()\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Returns a hash of the Board instance for use in hash-based collections.\n\n        Returns:\n            int: The hash value of the Board instance.\n\n        Example:\n            ```python\n            import bitbully as bb\n\n            # Create two boards that represent the same final position.\n            # The first board is initialized directly from a move string.\n            board1 = bb.Board(\"33333111\")\n\n            # The second board is built incrementally by playing an equivalent sequence of moves.\n            # Even though the order of intermediate plays differs, the final layout of tokens\n            # (and thus the internal bitboard state) will be identical to `board1`.\n            board2 = bb.Board()\n            board2.play(\"31133331\")\n\n            # Boards with identical configurations produce the same hash value.\n            # This allows them to be used efficiently as keys in dictionaries or members of sets.\n            assert hash(board1) == hash(board2)\n\n            # Display the board's hash value.\n            hash(board1)\n            ```\n            Expected output:\n            ```text\n            971238920548618160\n            ```\n        \"\"\"\n        return self._board.hash()\n\n    def is_legal_move(self, move: int) -&gt; bool:\n        \"\"\"Checks if a move (column) is legal.\n\n        Args:\n            move (int): The column index (0-6) to check.\n\n        Returns:\n            bool: True if the move is legal, False otherwise.\n        \"\"\"\n        return self._board.isLegalMove(move)\n\n    def mirror(self) -&gt; Board:\n        \"\"\"Returns a new Board instance that is the mirror image of the current board.\n\n        Returns:\n            Board: A new Board instance that is the mirror image.\n        \"\"\"\n        new_board = Board()\n        new_board._board = self._board.mirror()\n        return new_board\n\n    def moves_left(self) -&gt; int:\n        \"\"\"Returns the number of moves left until the board is full.\n\n        Returns:\n            int: The number of moves left (0-42).\n        \"\"\"\n        return self._board.movesLeft()\n\n    def play(self, move: int | Sequence[int] | str) -&gt; bool:\n        \"\"\"Plays one or more moves for the current player.\n\n        The method updates the internal board state by dropping tokens\n        into the specified columns. Input can be:\n        - a single integer (column index 0 to 6),\n        - an iterable sequence of integers (e.g., `[3, 1, 3]` or `range(7)`),\n        - or a string of digits (e.g., `\"33333111\"`) representing the move order.\n\n        Args:\n            move (int | Sequence[int] | str):\n                The column index or sequence of column indices where tokens should be placed.\n\n        Returns:\n            bool: True if the move was played successfully, False if the move was illegal.\n\n\n        Example:\n            Play a sequence of moves into the center column (column index 3):\n            ```python\n            import bitbully as bb\n\n            board = bb.Board()\n            assert board.play([3, 3, 3])  # returns True on successful move\n            board\n            ```\n\n            Expected output:\n\n            ```\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  _  _  X  _  _  _\n            ```\n\n        Example:\n            Play a sequence of moves across all columns:\n            ```python\n            import bitbully as bb\n\n            board = bb.Board()\n            assert board.play(range(7))  # returns True on successful move\n            board\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            X  O  X  O  X  O  X\n            ```\n\n        Example:\n            Play a sequence using a string:\n            ```python\n            import bitbully as bb\n\n            board = bb.Board()\n            assert board.play(\"33333111\")  # returns True on successful move\n            board\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  O  _  X  _  _  _\n            _  X  _  O  _  _  _\n            _  O  _  X  _  _  _\n            ```\n        \"\"\"\n        # Case 1: string -&gt; pass through directly\n        if isinstance(move, str):\n            return self._board.play(move)\n\n        # Case 2: int -&gt; pass through directly\n        if isinstance(move, int):\n            return self._board.play(move)\n\n        # From here on, move is a Sequence[...] (but not str or int).\n        move_list: list[int] = [int(v) for v in cast(Sequence[Any], move)]\n        return self._board.play(move_list)\n\n    def reset_board(self, board: Sequence[int] | Sequence[Sequence[int]] | str | None = None) -&gt; bool:\n        \"\"\"Resets the board or sets (overrides) the board to a specific state.\n\n        Args:\n            board (Sequence[int] | Sequence[Sequence[int]] | str | None):\n                The new board state. Accepts:\n                - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7\n                - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3])\n                - String: A move sequence of columns as string (e.g., \"002233...\")\n                - None: to reset to an empty board\n\n        Returns:\n            bool: True if the board was set successfully, False otherwise.\n\n        Example:\n            Reset the board to an empty state:\n            ```python\n            import bitbully as bb\n\n            # Create a temporary board position from a move string.\n            # The string \"0123456\" plays one token in each column (0-6) in sequence.\n            board = bb.Board(\"0123456\")\n\n            # Reset the board to an empty state.\n            # Calling `reset_board()` clears all tokens and restores the starting position.\n            # No moves \u2192 an empty board.\n            assert board.reset_board()\n            board\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            ```\n\n        Example:\n            (Re-)Set the board using a move sequence string:\n            ```python\n            import bitbully as bb\n\n            # This is just a temporary setup; it will be replaced below.\n            board = bb.Board(\"0123456\")\n\n            # Set the board state directly from a move sequence.\n            # The list [3, 3, 3] represents three consecutive moves in the center column (index 3).\n            # Moves alternate automatically between Player 1 (yellow) and Player 2 (red).\n            #\n            # The `reset_board()` method clears the current position and replays the given moves\n            # from an empty board \u2014 effectively overriding any existing board state.\n            assert board.reset_board([3, 3, 3])\n\n            # Display the updated board to verify the new position.\n            board\n            ```\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  _  _  O  _  _  _\n            _  _  _  X  _  _  _\n            ```\n\n        Example:\n            You can also set the board using other formats, such as a 2D array or a string.\n            See the examples in the [`bitbully.Board.__init__`][src.bitbully.Board.__init__] docstring for details.\n\n            ```python\n            # Briefly demonstrate the different input formats accepted by `reset_board()`.\n            import bitbully as bb\n\n            # Create an empty board instance\n            board = bb.Board()\n\n            # Variant 1: From a list of moves (integers)\n            # Each number represents a column index (0-6); moves alternate between players.\n            assert board.reset_board([3, 3, 3])\n\n            # Variant 2: From a compact move string\n            # Equivalent to the list above \u2014 useful for quick testing or serialization.\n            assert board.reset_board(\"33333111\")\n\n            # Variant 3: From a 2D list in row-major format (6 x 7)\n            # Each inner list represents a row (top to bottom).\n            # 0 = empty, 1 = Player 1, 2 = Player 2.\n            board_array = [\n                [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n                [0, 0, 0, 1, 0, 0, 0],  # Row 4\n                [0, 0, 0, 2, 0, 0, 0],  # Row 3\n                [0, 2, 0, 1, 0, 0, 0],  # Row 2\n                [0, 1, 0, 2, 0, 0, 0],  # Row 1\n                [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom)\n            ]\n            assert board.reset_board(board_array)\n\n            # Variant 4: From a 2D list in column-major format (7 x 6)\n            # Each inner list represents a column (left to right); this matches BitBully's internal layout.\n            board_array = [\n                [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)\n                [2, 1, 2, 1, 0, 0],  # Column 1\n                [0, 0, 0, 0, 0, 0],  # Column 2\n                [1, 2, 1, 2, 1, 0],  # Column 3 (center)\n                [0, 0, 0, 0, 0, 0],  # Column 4\n                [2, 1, 2, 0, 0, 0],  # Column 5\n                [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)\n            ]\n            assert board.reset_board(board_array)\n\n            # Display the final board state in text form\n            board\n            ```\n\n            Expected output:\n            ```text\n            _  _  _  _  _  _  _\n            _  _  _  X  _  _  _\n            _  X  _  O  _  _  _\n            _  O  _  X  _  O  _\n            _  X  _  O  _  X  _\n            _  O  _  X  _  O  _\n            ```\n        \"\"\"\n        if board is None:\n            return self._board.setBoard([])\n        if isinstance(board, str):\n            return self._board.setBoard(board)\n\n        # From here on, board is a Sequence[...] (but not str).\n        # Distinguish 2D vs 1D by inspecting the first element.\n        if len(board) &gt; 0 and isinstance(board[0], Sequence) and not isinstance(board[0], (str, bytes)):\n            # Case 2: 2D -&gt; list[list[int]]\n            # Convert inner sequences to lists of ints\n            grid: list[list[int]] = [[int(v) for v in row] for row in cast(Sequence[Sequence[Any]], board)]\n            return self._board.setBoard(grid)\n\n        # Case 3: 1D -&gt; list[int]\n        moves: list[int] = [int(v) for v in cast(Sequence[Any], board)]\n        return self._board.setBoard(moves)\n\n    def to_array(self) -&gt; list[list[int]]:\n        \"\"\"Returns the board state as a 2D array (list of lists).\n\n        Returns:\n            list[list[int]]: A 2D list representing the board state.\n        \"\"\"\n        return self._board.toArray()\n\n    def to_string(self) -&gt; str:\n        \"\"\"Returns a string representation of the board to print on the command line.\n\n        Returns:\n            str: A string representing the board (e.g., \"002233...\").\n        \"\"\"\n        return self._board.toString()\n\n    def uid(self) -&gt; int:\n        \"\"\"Returns a unique identifier for the current board state.\n\n        Returns:\n            int: A unique integer identifier for the board state.\n        \"\"\"\n        return self._board.uid()\n\n    @staticmethod\n    def random_board(n_ply: int, forbid_direct_win: bool) -&gt; None:\n        \"\"\"Generates a random board state by playing a specified number of random moves.\n\n        Args:\n            n_ply (int): The number of random moves to play on the board.\n            forbid_direct_win (bool): If True, the board will have a state that would result in an immediate win.\n        \"\"\"\n        bitbully_core.BoardCore.randomBoard(n_ply, forbid_direct_win)\n\n    def reset(self) -&gt; None:\n        \"\"\"Resets the board to an empty state.\"\"\"\n        self._board = bitbully_core.BoardCore()\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.__eq__","title":"<code>__eq__(value)</code>","text":"<p>Checks equality between two Board instances.</p> Notes <ul> <li>Equality checks in BitBully compare the exact board state (bit patterns),   not just the move history.</li> <li>Two different move sequences can still yield the same position if they   result in identical token configurations.</li> <li>This is useful for comparing solver states, verifying test positions,   or detecting transpositions in search algorithms.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>object</code> <p>The other Board instance to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if both boards are equal, False otherwise.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the other value is not a Board instance.</p> Example <pre><code>import bitbully as bb\n\n# Create two boards that should represent *identical* game states.\nboard1 = bb.Board()\nassert board1.play(\"33333111\")\n\nboard2 = bb.Board()\n# Play the same position step by step using a different but equivalent sequence.\n# Internally, the final bitboard state will match `board1`.\nassert board2.play(\"31133331\")\n\n# Boards with identical token placements are considered equal.\n# Equality (`==`) and inequality (`!=`) operators are overloaded for convenience.\nassert board1 == board2\nassert not (board1 != board2)\n\n# ------------------------------------------------------------------------------\n\n# Create two boards that differ by one move.\nboard1 = bb.Board(\"33333111\")\nboard2 = bb.Board(\"33333112\")  # One extra move in the last column (index 2)\n\n# Since the token layout differs, equality no longer holds.\nassert board1 != board2\nassert not (board1 == board2)\n</code></pre> Source code in <code>src/bitbully/board.py</code> <pre><code>def __eq__(self, value: object) -&gt; bool:\n    \"\"\"Checks equality between two Board instances.\n\n    Notes:\n        - Equality checks in BitBully compare the *exact board state* (bit patterns),\n          not just the move history.\n        - Two different move sequences can still yield the same position if they\n          result in identical token configurations.\n        - This is useful for comparing solver states, verifying test positions,\n          or detecting transpositions in search algorithms.\n\n    Args:\n        value (object): The other Board instance to compare against.\n\n    Returns:\n        bool: True if both boards are equal, False otherwise.\n\n    Raises:\n        NotImplementedError: If the other value is not a Board instance.\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        # Create two boards that should represent *identical* game states.\n        board1 = bb.Board()\n        assert board1.play(\"33333111\")\n\n        board2 = bb.Board()\n        # Play the same position step by step using a different but equivalent sequence.\n        # Internally, the final bitboard state will match `board1`.\n        assert board2.play(\"31133331\")\n\n        # Boards with identical token placements are considered equal.\n        # Equality (`==`) and inequality (`!=`) operators are overloaded for convenience.\n        assert board1 == board2\n        assert not (board1 != board2)\n\n        # ------------------------------------------------------------------------------\n\n        # Create two boards that differ by one move.\n        board1 = bb.Board(\"33333111\")\n        board2 = bb.Board(\"33333112\")  # One extra move in the last column (index 2)\n\n        # Since the token layout differs, equality no longer holds.\n        assert board1 != board2\n        assert not (board1 == board2)\n        ```\n    \"\"\"\n    if not isinstance(value, Board):\n        raise NotImplementedError(\"Can only compare with another Board instance.\")\n    return bool(self._board == value._board)\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns a hash of the Board instance for use in hash-based collections.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The hash value of the Board instance.</p> Example <p><pre><code>import bitbully as bb\n\n# Create two boards that represent the same final position.\n# The first board is initialized directly from a move string.\nboard1 = bb.Board(\"33333111\")\n\n# The second board is built incrementally by playing an equivalent sequence of moves.\n# Even though the order of intermediate plays differs, the final layout of tokens\n# (and thus the internal bitboard state) will be identical to `board1`.\nboard2 = bb.Board()\nboard2.play(\"31133331\")\n\n# Boards with identical configurations produce the same hash value.\n# This allows them to be used efficiently as keys in dictionaries or members of sets.\nassert hash(board1) == hash(board2)\n\n# Display the board's hash value.\nhash(board1)\n</code></pre> Expected output: <pre><code>971238920548618160\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Returns a hash of the Board instance for use in hash-based collections.\n\n    Returns:\n        int: The hash value of the Board instance.\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        # Create two boards that represent the same final position.\n        # The first board is initialized directly from a move string.\n        board1 = bb.Board(\"33333111\")\n\n        # The second board is built incrementally by playing an equivalent sequence of moves.\n        # Even though the order of intermediate plays differs, the final layout of tokens\n        # (and thus the internal bitboard state) will be identical to `board1`.\n        board2 = bb.Board()\n        board2.play(\"31133331\")\n\n        # Boards with identical configurations produce the same hash value.\n        # This allows them to be used efficiently as keys in dictionaries or members of sets.\n        assert hash(board1) == hash(board2)\n\n        # Display the board's hash value.\n        hash(board1)\n        ```\n        Expected output:\n        ```text\n        971238920548618160\n        ```\n    \"\"\"\n    return self._board.hash()\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.__init__","title":"<code>__init__(init_with=None)</code>","text":"<p>Initializes a Board instance.</p> <p>Parameters:</p> Name Type Description Default <code>init_with</code> <code>Sequence[Sequence[int]] | Sequence[int] | str | None</code> <p>Optional initial board state. Accepts: - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7 - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3]) - String: A move sequence of columns as string (e.g., \"002233\") - None for an empty board</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided initial board state is invalid.</p> Example <p>You can initialize an empty board in multiple ways: <pre><code>import bitbully as bb\n\n# Create an empty board using the default constructor.\nboard = bb.Board()  # Starts with no tokens placed.\n\n# Alternatively, initialize the board explicitly from a 2D list.\n# Each inner list represents a column (7 columns total, 6 rows each).\n# A value of 0 indicates an empty cell; 1 and 2 would represent player tokens.\nboard = bb.Board([[0] * 6 for _ in range(7)])  # Equivalent to an empty board.\n\n# You can also set up a specific board position manually using a 6 x 7 layout,\n# where each inner list represents a row instead of a column.\n# (Both layouts are accepted by BitBully for convenience.)\n# For more complex examples using 2D arrays, see the examples below.\nboard = bb.Board([[0] * 7 for _ in range(6)])  # Also equivalent to an empty board.\n\n# Display the board in text form.\n# The __repr__ method shows the current state (useful for debugging or interactive use).\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n</code></pre></p> <p>The recommended way to initialize an empty board is simply <code>Board()</code>.</p> Example <p>You can also initialize a board with a sequence of moves: <pre><code>import bitbully as bb\n\n# Initialize a board with a sequence of moves played in the center column.\n\n# The list [3, 3, 3] represents three moves in column index 3 (zero-based).\n# Moves alternate automatically between Player 1 (yellow, X) and Player 2 (red, O).\n# After these three moves, the center column will contain:\n#   - Row 0: Player 1 token (bottom)\n#   - Row 1: Player 2 token\n#   - Row 2: Player 1 token\nboard = bb.Board([3, 3, 3])\n\n# Display the resulting board.\n# The textual output shows the tokens placed in the center column.\nboard\n</code></pre></p> <p>Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n</code></pre></p> Example <p>You can also initialize a board using a string containing a move sequence: <pre><code>import bitbully as bb\n\n# Initialize a board using a compact move string.\n\n# The string \"33333111\" represents a sequence of eight moves:\n#   3 3 3 3 3 \u2192 five moves in the center column (index 3)\n#   1 1 1 \u2192 three moves in the second column (index 1)\n#\n# Moves are applied in order, alternating automatically between Player 1 (yellow, X)\n# and Player 2 (red, O), just as if you had called `board.play()` repeatedly.\n#\n# This shorthand is convenient for reproducing board states or test positions\n# without having to provide long move lists.\n\nboard = bb.Board(\"33333111\")\n\n# Display the resulting board.\n# The printed layout shows how the tokens stack in each column.\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Example <p>You can also initialize a board using a 2D array (list of lists): <pre><code>import bitbully as bb\n\n# Use a 6 x 7 list (rows x columns) to set up a specific board position manually.\n\n# Each inner list represents a row of the Connect-4 grid.\n# Convention:\n#   - 0 \u2192 empty cell\n#   - 1 \u2192 Player 1 token (yellow, X)\n#   - 2 \u2192 Player 2 token (red, O)\n#\n# The top list corresponds to the *top row* (row index 5),\n# and the bottom list corresponds to the *bottom row* (row index 0).\n# This layout matches the typical visual display of the board.\n\nboard_array = [\n    [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n    [0, 0, 0, 1, 0, 0, 0],  # Row 4: Player 1 token in column 3\n    [0, 0, 0, 2, 0, 0, 0],  # Row 3: Player 2 token in column 3\n    [0, 2, 0, 1, 0, 0, 0],  # Row 2: tokens in columns 1 and 3\n    [0, 1, 0, 2, 0, 0, 0],  # Row 1: tokens in columns 1 and 3\n    [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom): tokens stacked lowest\n]\n\n# Create a Board instance directly from the 2D list.\n# This allows reconstructing arbitrary positions (e.g., from test data or saved states)\n# without replaying the move sequence.\nboard = bb.Board(board_array)\n\n# Display the resulting board state in text form.\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Example <p>You can also initialize a board using a 2D (7 x 6) array with columns as inner lists: <pre><code>import bitbully as bb\n\n# Use a 7 x 6 list (columns x rows) to set up a specific board position manually.\n\n# Each inner list represents a **column** of the Connect-4 board, from left (index 0)\n# to right (index 6). Each column contains six entries \u2014 one for each row, from\n# bottom (index 0) to top (index 5).\n#\n# Convention:\n#   - 0 \u2192 empty cell\n#   - 1 \u2192 Player 1 token (yellow, X)\n#   - 2 \u2192 Player 2 token (red, O)\n#\n# This column-major layout matches the internal representation used by BitBully,\n# where tokens are dropped into columns rather than filled row by row.\n\nboard_array = [\n    [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)\n    [2, 1, 2, 0, 0, 0],  # Column 1\n    [0, 0, 0, 0, 0, 0],  # Column 2\n    [1, 2, 1, 2, 1, 0],  # Column 3 (center)\n    [0, 0, 0, 0, 0, 0],  # Column 4\n    [0, 0, 0, 0, 0, 0],  # Column 5\n    [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)\n]\n\n# Create a Board instance directly from the 2D list.\n# This allows reconstructing any arbitrary position (e.g., test cases, saved games)\n# without replaying all moves individually.\nboard = bb.Board(board_array)\n\n# Display the resulting board.\n# The text output shows tokens as they would appear in a real Connect-4 grid.\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def __init__(self, init_with: Sequence[Sequence[int]] | Sequence[int] | str | None = None) -&gt; None:\n    \"\"\"Initializes a Board instance.\n\n    Args:\n        init_with (Sequence[Sequence[int]] | Sequence[int] | str | None):\n            Optional initial board state. Accepts:\n            - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7\n            - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3])\n            - String: A move sequence of columns as string (e.g., \"002233\")\n            - None for an empty board\n\n    Raises:\n        ValueError: If the provided initial board state is invalid.\n\n    Example:\n        You can initialize an empty board in multiple ways:\n        ```python\n        import bitbully as bb\n\n        # Create an empty board using the default constructor.\n        board = bb.Board()  # Starts with no tokens placed.\n\n        # Alternatively, initialize the board explicitly from a 2D list.\n        # Each inner list represents a column (7 columns total, 6 rows each).\n        # A value of 0 indicates an empty cell; 1 and 2 would represent player tokens.\n        board = bb.Board([[0] * 6 for _ in range(7)])  # Equivalent to an empty board.\n\n        # You can also set up a specific board position manually using a 6 x 7 layout,\n        # where each inner list represents a row instead of a column.\n        # (Both layouts are accepted by BitBully for convenience.)\n        # For more complex examples using 2D arrays, see the examples below.\n        board = bb.Board([[0] * 7 for _ in range(6)])  # Also equivalent to an empty board.\n\n        # Display the board in text form.\n        # The __repr__ method shows the current state (useful for debugging or interactive use).\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        ```\n\n    The recommended way to initialize an empty board is simply `Board()`.\n\n    Example:\n        You can also initialize a board with a sequence of moves:\n        ```python\n        import bitbully as bb\n\n        # Initialize a board with a sequence of moves played in the center column.\n\n        # The list [3, 3, 3] represents three moves in column index 3 (zero-based).\n        # Moves alternate automatically between Player 1 (yellow, X) and Player 2 (red, O).\n        # After these three moves, the center column will contain:\n        #   - Row 0: Player 1 token (bottom)\n        #   - Row 1: Player 2 token\n        #   - Row 2: Player 1 token\n        board = bb.Board([3, 3, 3])\n\n        # Display the resulting board.\n        # The textual output shows the tokens placed in the center column.\n        board\n        ```\n\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        ```\n\n    Example:\n        You can also initialize a board using a string containing a move sequence:\n        ```python\n        import bitbully as bb\n\n        # Initialize a board using a compact move string.\n\n        # The string \"33333111\" represents a sequence of eight moves:\n        #   3 3 3 3 3 \u2192 five moves in the center column (index 3)\n        #   1 1 1 \u2192 three moves in the second column (index 1)\n        #\n        # Moves are applied in order, alternating automatically between Player 1 (yellow, X)\n        # and Player 2 (red, O), just as if you had called `board.play()` repeatedly.\n        #\n        # This shorthand is convenient for reproducing board states or test positions\n        # without having to provide long move lists.\n\n        board = bb.Board(\"33333111\")\n\n        # Display the resulting board.\n        # The printed layout shows how the tokens stack in each column.\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n\n    Example:\n        You can also initialize a board using a 2D array (list of lists):\n        ```python\n        import bitbully as bb\n\n        # Use a 6 x 7 list (rows x columns) to set up a specific board position manually.\n\n        # Each inner list represents a row of the Connect-4 grid.\n        # Convention:\n        #   - 0 \u2192 empty cell\n        #   - 1 \u2192 Player 1 token (yellow, X)\n        #   - 2 \u2192 Player 2 token (red, O)\n        #\n        # The top list corresponds to the *top row* (row index 5),\n        # and the bottom list corresponds to the *bottom row* (row index 0).\n        # This layout matches the typical visual display of the board.\n\n        board_array = [\n            [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n            [0, 0, 0, 1, 0, 0, 0],  # Row 4: Player 1 token in column 3\n            [0, 0, 0, 2, 0, 0, 0],  # Row 3: Player 2 token in column 3\n            [0, 2, 0, 1, 0, 0, 0],  # Row 2: tokens in columns 1 and 3\n            [0, 1, 0, 2, 0, 0, 0],  # Row 1: tokens in columns 1 and 3\n            [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom): tokens stacked lowest\n        ]\n\n        # Create a Board instance directly from the 2D list.\n        # This allows reconstructing arbitrary positions (e.g., from test data or saved states)\n        # without replaying the move sequence.\n        board = bb.Board(board_array)\n\n        # Display the resulting board state in text form.\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n\n    Example:\n        You can also initialize a board using a 2D (7 x 6) array with columns as inner lists:\n        ```python\n        import bitbully as bb\n\n        # Use a 7 x 6 list (columns x rows) to set up a specific board position manually.\n\n        # Each inner list represents a **column** of the Connect-4 board, from left (index 0)\n        # to right (index 6). Each column contains six entries \u2014 one for each row, from\n        # bottom (index 0) to top (index 5).\n        #\n        # Convention:\n        #   - 0 \u2192 empty cell\n        #   - 1 \u2192 Player 1 token (yellow, X)\n        #   - 2 \u2192 Player 2 token (red, O)\n        #\n        # This column-major layout matches the internal representation used by BitBully,\n        # where tokens are dropped into columns rather than filled row by row.\n\n        board_array = [\n            [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)\n            [2, 1, 2, 0, 0, 0],  # Column 1\n            [0, 0, 0, 0, 0, 0],  # Column 2\n            [1, 2, 1, 2, 1, 0],  # Column 3 (center)\n            [0, 0, 0, 0, 0, 0],  # Column 4\n            [0, 0, 0, 0, 0, 0],  # Column 5\n            [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)\n        ]\n\n        # Create a Board instance directly from the 2D list.\n        # This allows reconstructing any arbitrary position (e.g., test cases, saved games)\n        # without replaying all moves individually.\n        board = bb.Board(board_array)\n\n        # Display the resulting board.\n        # The text output shows tokens as they would appear in a real Connect-4 grid.\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n    \"\"\"\n    self._board = bitbully_core.BoardCore()\n    if init_with is not None and not self.reset_board(init_with):\n        raise ValueError(\n            \"Invalid initial board state provided. Check the examples in the docstring for valid formats.\"\n        )\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.__ne__","title":"<code>__ne__(value)</code>","text":"<p>Checks inequality between two Board instances.</p> <p>See the documentation for <code>src.bitbully.Board.__eq__</code> for details.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>object</code> <p>The other Board instance to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if both boards are not equal, False otherwise.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def __ne__(self, value: object) -&gt; bool:\n    \"\"\"Checks inequality between two Board instances.\n\n    See the documentation for [`src.bitbully.Board.__eq__`][src.bitbully.Board.__eq__] for details.\n\n    Args:\n        value (object): The other Board instance to compare against.\n\n    Returns:\n        bool: True if both boards are not equal, False otherwise.\n    \"\"\"\n    return not self.__eq__(value)\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the Board instance.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Returns a string representation of the Board instance.\"\"\"\n    return f\"{self._board}\"\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.all_positions","title":"<code>all_positions(up_to_n_ply, exactly_n)</code>","text":"<p>Finds all positions on the board up to a certain ply.</p> <p>Parameters:</p> Name Type Description Default <code>up_to_n_ply</code> <code>int</code> <p>The maximum ply depth to search.</p> required <code>exactly_n</code> <code>bool</code> <p>If True, only returns positions at exactly N ply.</p> required <p>Returns:</p> Type Description <code>list[Board]</code> <p>list[Board]: A list of Board instances representing all positions.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def all_positions(self, up_to_n_ply: int, exactly_n: bool) -&gt; list[Board]:\n    \"\"\"Finds all positions on the board up to a certain ply.\n\n    Args:\n        up_to_n_ply (int): The maximum ply depth to search.\n        exactly_n (bool): If True, only returns positions at exactly N ply.\n\n    Returns:\n        list[Board]: A list of Board instances representing all positions.\n    \"\"\"\n    # TODO: Implement this method properly. Need to convert BoardCore instances to Board.\n    # return self._board.all_positions(up_to_n_ply, exactly_n)\n    return [Board()]\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.can_win_next","title":"<code>can_win_next(move=None)</code>","text":"<p>Checks if the current player can win in the next move.</p> <p>Parameters:</p> Name Type Description Default <code>move</code> <code>int | None</code> <p>Optional column to check for an immediate win. If None, checks all columns.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the current player can win next, False otherwise.</p> <p>See also: <code>bitbully.Board.has_win</code>.</p> Example <p><pre><code>import bitbully as bb\n\n# Create a board from a move string.\n# The string \"332311\" represents a short sequence of alternating moves\n# that results in a nearly winning position for Player 1 (yellow, X).\nboard = bb.Board(\"332311\")\n\n# Display the current board state (see below)\nprint(board)\n\n# Player 1 (yellow, X) \u2014 who is next to move \u2014 can win immediately\n# by placing a token in either column 0 or column 4.\nassert board.can_win_next(0)\nassert board.can_win_next(4)\n\n# However, playing in other columns does not result in an instant win.\nassert not board.can_win_next(2)\nassert not board.can_win_next(3)\n\n# You can also call `can_win_next()` without arguments to perform a general check.\n# It returns True if the current player has *any* winning move available.\nassert board.can_win_next()\n</code></pre> The board we created above looks like this: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  O  _  _  _\n_  O  _  O  _  _  _\n_  X  X  X  _  _  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def can_win_next(self, move: int | None = None) -&gt; bool:\n    \"\"\"Checks if the current player can win in the next move.\n\n    Args:\n        move (int | None): Optional column to check for an immediate win. If None, checks all columns.\n\n    Returns:\n        bool: True if the current player can win next, False otherwise.\n\n    See also: [`bitbully.Board.has_win`][src.bitbully.Board.has_win].\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        # Create a board from a move string.\n        # The string \"332311\" represents a short sequence of alternating moves\n        # that results in a nearly winning position for Player 1 (yellow, X).\n        board = bb.Board(\"332311\")\n\n        # Display the current board state (see below)\n        print(board)\n\n        # Player 1 (yellow, X) \u2014 who is next to move \u2014 can win immediately\n        # by placing a token in either column 0 or column 4.\n        assert board.can_win_next(0)\n        assert board.can_win_next(4)\n\n        # However, playing in other columns does not result in an instant win.\n        assert not board.can_win_next(2)\n        assert not board.can_win_next(3)\n\n        # You can also call `can_win_next()` without arguments to perform a general check.\n        # It returns True if the current player has *any* winning move available.\n        assert board.can_win_next()\n        ```\n        The board we created above looks like this:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  O  _  _  _\n        _  X  X  X  _  _  _\n        ```\n    \"\"\"\n    if move is None:\n        return self._board.canWin()\n    return bool(self._board.canWin(move))\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.copy","title":"<code>copy()</code>","text":"<p>Creates a copy of the current Board instance.</p> <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>A new Board instance that is a copy of the current one.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def copy(self) -&gt; Board:\n    \"\"\"Creates a copy of the current Board instance.\n\n    Returns:\n        Board: A new Board instance that is a copy of the current one.\n    \"\"\"\n    new_board = Board()\n    new_board._board = self._board.copy()\n    return new_board\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.count_tokens","title":"<code>count_tokens()</code>","text":"<p>Counts the total number of tokens on the board.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The total number of tokens.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def count_tokens(self) -&gt; int:\n    \"\"\"Counts the total number of tokens on the board.\n\n    Returns:\n        int: The total number of tokens.\n    \"\"\"\n    return self._board.countTokens()\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.get_legal_moves","title":"<code>get_legal_moves()</code>","text":"<p>Returns a list of legal moves (columns) that can be played.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: A list of column indices (0-6) where a move can be played.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented yet.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def get_legal_moves(self) -&gt; list[int]:\n    \"\"\"Returns a list of legal moves (columns) that can be played.\n\n    Returns:\n        list[int]: A list of column indices (0-6) where a move can be played.\n\n    Raises:\n        NotImplementedError: If the method is not implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"get_legal_moves is not implemented yet.\")\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.has_win","title":"<code>has_win()</code>","text":"<p>Checks if the current player has a winning position.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the current player has a winning position (4-in-a-row), False otherwise.</p> <p>Unlike <code>can_win_next()</code>, which checks whether the current player could win on their next move, the <code>has_win()</code> method determines whether a winning condition already exists on the board. This method is typically used right after a move to verify whether the game has been won.</p> <p>See also: <code>bitbully.Board.can_win_next</code>.</p> Example <p><pre><code>import bitbully as bb\n\n# Initialize a board from a move sequence.\n# The string \"332311\" represents a position where Player 1 (yellow, X)\n# is one move away from winning.\nboard = bb.Board(\"332311\")\n\n# At this stage, Player 1 has not yet won, but can win immediately\n# by placing a token in either column 0 or column 4.\nassert not board.has_win()\nassert board.can_win_next(0)  # Check column 0\nassert board.can_win_next(4)  # Check column 4\nassert board.can_win_next()  # General check (any winning move)\n\n# Simulate Player 1 playing in column 4 \u2014 this completes\n# a horizontal line of four tokens and wins the game.\nassert board.play(4)\n\n# Display the updated board to visualize the winning position.\nprint(board)\n\n# The board now contains a winning configuration:\n# Player 1 (yellow, X) has achieved a Connect-4.\nassert board.has_win()\n</code></pre> Board from above, expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  O  _  _  _\n_  O  _  O  _  _  _\n_  X  X  X  X  _  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def has_win(self) -&gt; bool:\n    \"\"\"Checks if the current player has a winning position.\n\n    Returns:\n        bool: True if the current player has a winning position (4-in-a-row), False otherwise.\n\n    Unlike `can_win_next()`, which checks whether the current player *could* win\n    on their next move, the `has_win()` method determines whether a winning\n    condition already exists on the board.\n    This method is typically used right after a move to verify whether the game\n    has been won.\n\n    See also: [`bitbully.Board.can_win_next`][src.bitbully.Board.can_win_next].\n\n    Example:\n        ```python\n        import bitbully as bb\n\n        # Initialize a board from a move sequence.\n        # The string \"332311\" represents a position where Player 1 (yellow, X)\n        # is one move away from winning.\n        board = bb.Board(\"332311\")\n\n        # At this stage, Player 1 has not yet won, but can win immediately\n        # by placing a token in either column 0 or column 4.\n        assert not board.has_win()\n        assert board.can_win_next(0)  # Check column 0\n        assert board.can_win_next(4)  # Check column 4\n        assert board.can_win_next()  # General check (any winning move)\n\n        # Simulate Player 1 playing in column 4 \u2014 this completes\n        # a horizontal line of four tokens and wins the game.\n        assert board.play(4)\n\n        # Display the updated board to visualize the winning position.\n        print(board)\n\n        # The board now contains a winning configuration:\n        # Player 1 (yellow, X) has achieved a Connect-4.\n        assert board.has_win()\n        ```\n        Board from above, expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  O  _  _  _\n        _  X  X  X  X  _  _\n        ```\n    \"\"\"\n    return self._board.hasWin()\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.is_legal_move","title":"<code>is_legal_move(move)</code>","text":"<p>Checks if a move (column) is legal.</p> <p>Parameters:</p> Name Type Description Default <code>move</code> <code>int</code> <p>The column index (0-6) to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the move is legal, False otherwise.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def is_legal_move(self, move: int) -&gt; bool:\n    \"\"\"Checks if a move (column) is legal.\n\n    Args:\n        move (int): The column index (0-6) to check.\n\n    Returns:\n        bool: True if the move is legal, False otherwise.\n    \"\"\"\n    return self._board.isLegalMove(move)\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.mirror","title":"<code>mirror()</code>","text":"<p>Returns a new Board instance that is the mirror image of the current board.</p> <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>A new Board instance that is the mirror image.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def mirror(self) -&gt; Board:\n    \"\"\"Returns a new Board instance that is the mirror image of the current board.\n\n    Returns:\n        Board: A new Board instance that is the mirror image.\n    \"\"\"\n    new_board = Board()\n    new_board._board = self._board.mirror()\n    return new_board\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.moves_left","title":"<code>moves_left()</code>","text":"<p>Returns the number of moves left until the board is full.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of moves left (0-42).</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def moves_left(self) -&gt; int:\n    \"\"\"Returns the number of moves left until the board is full.\n\n    Returns:\n        int: The number of moves left (0-42).\n    \"\"\"\n    return self._board.movesLeft()\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.play","title":"<code>play(move)</code>","text":"<p>Plays one or more moves for the current player.</p> <p>The method updates the internal board state by dropping tokens into the specified columns. Input can be: - a single integer (column index 0 to 6), - an iterable sequence of integers (e.g., <code>[3, 1, 3]</code> or <code>range(7)</code>), - or a string of digits (e.g., <code>\"33333111\"</code>) representing the move order.</p> <p>Parameters:</p> Name Type Description Default <code>move</code> <code>int | Sequence[int] | str</code> <p>The column index or sequence of column indices where tokens should be placed.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the move was played successfully, False if the move was illegal.</p> Example <p>Play a sequence of moves into the center column (column index 3): <pre><code>import bitbully as bb\n\nboard = bb.Board()\nassert board.play([3, 3, 3])  # returns True on successful move\nboard\n</code></pre></p> <p>Expected output:</p> <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n</code></pre> Example <p>Play a sequence of moves across all columns: <pre><code>import bitbully as bb\n\nboard = bb.Board()\nassert board.play(range(7))  # returns True on successful move\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\nX  O  X  O  X  O  X\n</code></pre></p> Example <p>Play a sequence using a string: <pre><code>import bitbully as bb\n\nboard = bb.Board()\nassert board.play(\"33333111\")  # returns True on successful move\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  O  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  _  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def play(self, move: int | Sequence[int] | str) -&gt; bool:\n    \"\"\"Plays one or more moves for the current player.\n\n    The method updates the internal board state by dropping tokens\n    into the specified columns. Input can be:\n    - a single integer (column index 0 to 6),\n    - an iterable sequence of integers (e.g., `[3, 1, 3]` or `range(7)`),\n    - or a string of digits (e.g., `\"33333111\"`) representing the move order.\n\n    Args:\n        move (int | Sequence[int] | str):\n            The column index or sequence of column indices where tokens should be placed.\n\n    Returns:\n        bool: True if the move was played successfully, False if the move was illegal.\n\n\n    Example:\n        Play a sequence of moves into the center column (column index 3):\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        assert board.play([3, 3, 3])  # returns True on successful move\n        board\n        ```\n\n        Expected output:\n\n        ```\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        ```\n\n    Example:\n        Play a sequence of moves across all columns:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        assert board.play(range(7))  # returns True on successful move\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        X  O  X  O  X  O  X\n        ```\n\n    Example:\n        Play a sequence using a string:\n        ```python\n        import bitbully as bb\n\n        board = bb.Board()\n        assert board.play(\"33333111\")  # returns True on successful move\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  O  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  _  _\n        ```\n    \"\"\"\n    # Case 1: string -&gt; pass through directly\n    if isinstance(move, str):\n        return self._board.play(move)\n\n    # Case 2: int -&gt; pass through directly\n    if isinstance(move, int):\n        return self._board.play(move)\n\n    # From here on, move is a Sequence[...] (but not str or int).\n    move_list: list[int] = [int(v) for v in cast(Sequence[Any], move)]\n    return self._board.play(move_list)\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.random_board","title":"<code>random_board(n_ply, forbid_direct_win)</code>  <code>staticmethod</code>","text":"<p>Generates a random board state by playing a specified number of random moves.</p> <p>Parameters:</p> Name Type Description Default <code>n_ply</code> <code>int</code> <p>The number of random moves to play on the board.</p> required <code>forbid_direct_win</code> <code>bool</code> <p>If True, the board will have a state that would result in an immediate win.</p> required Source code in <code>src/bitbully/board.py</code> <pre><code>@staticmethod\ndef random_board(n_ply: int, forbid_direct_win: bool) -&gt; None:\n    \"\"\"Generates a random board state by playing a specified number of random moves.\n\n    Args:\n        n_ply (int): The number of random moves to play on the board.\n        forbid_direct_win (bool): If True, the board will have a state that would result in an immediate win.\n    \"\"\"\n    bitbully_core.BoardCore.randomBoard(n_ply, forbid_direct_win)\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.reset","title":"<code>reset()</code>","text":"<p>Resets the board to an empty state.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the board to an empty state.\"\"\"\n    self._board = bitbully_core.BoardCore()\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.reset_board","title":"<code>reset_board(board=None)</code>","text":"<p>Resets the board or sets (overrides) the board to a specific state.</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Sequence[int] | Sequence[Sequence[int]] | str | None</code> <p>The new board state. Accepts: - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7 - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3]) - String: A move sequence of columns as string (e.g., \"002233...\") - None: to reset to an empty board</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the board was set successfully, False otherwise.</p> Example <p>Reset the board to an empty state: <pre><code>import bitbully as bb\n\n# Create a temporary board position from a move string.\n# The string \"0123456\" plays one token in each column (0-6) in sequence.\nboard = bb.Board(\"0123456\")\n\n# Reset the board to an empty state.\n# Calling `reset_board()` clears all tokens and restores the starting position.\n# No moves \u2192 an empty board.\nassert board.reset_board()\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n</code></pre></p> Example <p>(Re-)Set the board using a move sequence string: <pre><code>import bitbully as bb\n\n# This is just a temporary setup; it will be replaced below.\nboard = bb.Board(\"0123456\")\n\n# Set the board state directly from a move sequence.\n# The list [3, 3, 3] represents three consecutive moves in the center column (index 3).\n# Moves alternate automatically between Player 1 (yellow) and Player 2 (red).\n#\n# The `reset_board()` method clears the current position and replays the given moves\n# from an empty board \u2014 effectively overriding any existing board state.\nassert board.reset_board([3, 3, 3])\n\n# Display the updated board to verify the new position.\nboard\n</code></pre> Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  _  _  O  _  _  _\n_  _  _  X  _  _  _\n</code></pre></p> Example <p>You can also set the board using other formats, such as a 2D array or a string. See the examples in the <code>bitbully.Board.__init__</code> docstring for details.</p> <pre><code># Briefly demonstrate the different input formats accepted by `reset_board()`.\nimport bitbully as bb\n\n# Create an empty board instance\nboard = bb.Board()\n\n# Variant 1: From a list of moves (integers)\n# Each number represents a column index (0-6); moves alternate between players.\nassert board.reset_board([3, 3, 3])\n\n# Variant 2: From a compact move string\n# Equivalent to the list above \u2014 useful for quick testing or serialization.\nassert board.reset_board(\"33333111\")\n\n# Variant 3: From a 2D list in row-major format (6 x 7)\n# Each inner list represents a row (top to bottom).\n# 0 = empty, 1 = Player 1, 2 = Player 2.\nboard_array = [\n    [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n    [0, 0, 0, 1, 0, 0, 0],  # Row 4\n    [0, 0, 0, 2, 0, 0, 0],  # Row 3\n    [0, 2, 0, 1, 0, 0, 0],  # Row 2\n    [0, 1, 0, 2, 0, 0, 0],  # Row 1\n    [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom)\n]\nassert board.reset_board(board_array)\n\n# Variant 4: From a 2D list in column-major format (7 x 6)\n# Each inner list represents a column (left to right); this matches BitBully's internal layout.\nboard_array = [\n    [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)\n    [2, 1, 2, 1, 0, 0],  # Column 1\n    [0, 0, 0, 0, 0, 0],  # Column 2\n    [1, 2, 1, 2, 1, 0],  # Column 3 (center)\n    [0, 0, 0, 0, 0, 0],  # Column 4\n    [2, 1, 2, 0, 0, 0],  # Column 5\n    [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)\n]\nassert board.reset_board(board_array)\n\n# Display the final board state in text form\nboard\n</code></pre> <p>Expected output: <pre><code>_  _  _  _  _  _  _\n_  _  _  X  _  _  _\n_  X  _  O  _  _  _\n_  O  _  X  _  O  _\n_  X  _  O  _  X  _\n_  O  _  X  _  O  _\n</code></pre></p> Source code in <code>src/bitbully/board.py</code> <pre><code>def reset_board(self, board: Sequence[int] | Sequence[Sequence[int]] | str | None = None) -&gt; bool:\n    \"\"\"Resets the board or sets (overrides) the board to a specific state.\n\n    Args:\n        board (Sequence[int] | Sequence[Sequence[int]] | str | None):\n            The new board state. Accepts:\n            - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7\n            - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3])\n            - String: A move sequence of columns as string (e.g., \"002233...\")\n            - None: to reset to an empty board\n\n    Returns:\n        bool: True if the board was set successfully, False otherwise.\n\n    Example:\n        Reset the board to an empty state:\n        ```python\n        import bitbully as bb\n\n        # Create a temporary board position from a move string.\n        # The string \"0123456\" plays one token in each column (0-6) in sequence.\n        board = bb.Board(\"0123456\")\n\n        # Reset the board to an empty state.\n        # Calling `reset_board()` clears all tokens and restores the starting position.\n        # No moves \u2192 an empty board.\n        assert board.reset_board()\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        ```\n\n    Example:\n        (Re-)Set the board using a move sequence string:\n        ```python\n        import bitbully as bb\n\n        # This is just a temporary setup; it will be replaced below.\n        board = bb.Board(\"0123456\")\n\n        # Set the board state directly from a move sequence.\n        # The list [3, 3, 3] represents three consecutive moves in the center column (index 3).\n        # Moves alternate automatically between Player 1 (yellow) and Player 2 (red).\n        #\n        # The `reset_board()` method clears the current position and replays the given moves\n        # from an empty board \u2014 effectively overriding any existing board state.\n        assert board.reset_board([3, 3, 3])\n\n        # Display the updated board to verify the new position.\n        board\n        ```\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  _  _  O  _  _  _\n        _  _  _  X  _  _  _\n        ```\n\n    Example:\n        You can also set the board using other formats, such as a 2D array or a string.\n        See the examples in the [`bitbully.Board.__init__`][src.bitbully.Board.__init__] docstring for details.\n\n        ```python\n        # Briefly demonstrate the different input formats accepted by `reset_board()`.\n        import bitbully as bb\n\n        # Create an empty board instance\n        board = bb.Board()\n\n        # Variant 1: From a list of moves (integers)\n        # Each number represents a column index (0-6); moves alternate between players.\n        assert board.reset_board([3, 3, 3])\n\n        # Variant 2: From a compact move string\n        # Equivalent to the list above \u2014 useful for quick testing or serialization.\n        assert board.reset_board(\"33333111\")\n\n        # Variant 3: From a 2D list in row-major format (6 x 7)\n        # Each inner list represents a row (top to bottom).\n        # 0 = empty, 1 = Player 1, 2 = Player 2.\n        board_array = [\n            [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)\n            [0, 0, 0, 1, 0, 0, 0],  # Row 4\n            [0, 0, 0, 2, 0, 0, 0],  # Row 3\n            [0, 2, 0, 1, 0, 0, 0],  # Row 2\n            [0, 1, 0, 2, 0, 0, 0],  # Row 1\n            [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom)\n        ]\n        assert board.reset_board(board_array)\n\n        # Variant 4: From a 2D list in column-major format (7 x 6)\n        # Each inner list represents a column (left to right); this matches BitBully's internal layout.\n        board_array = [\n            [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)\n            [2, 1, 2, 1, 0, 0],  # Column 1\n            [0, 0, 0, 0, 0, 0],  # Column 2\n            [1, 2, 1, 2, 1, 0],  # Column 3 (center)\n            [0, 0, 0, 0, 0, 0],  # Column 4\n            [2, 1, 2, 0, 0, 0],  # Column 5\n            [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)\n        ]\n        assert board.reset_board(board_array)\n\n        # Display the final board state in text form\n        board\n        ```\n\n        Expected output:\n        ```text\n        _  _  _  _  _  _  _\n        _  _  _  X  _  _  _\n        _  X  _  O  _  _  _\n        _  O  _  X  _  O  _\n        _  X  _  O  _  X  _\n        _  O  _  X  _  O  _\n        ```\n    \"\"\"\n    if board is None:\n        return self._board.setBoard([])\n    if isinstance(board, str):\n        return self._board.setBoard(board)\n\n    # From here on, board is a Sequence[...] (but not str).\n    # Distinguish 2D vs 1D by inspecting the first element.\n    if len(board) &gt; 0 and isinstance(board[0], Sequence) and not isinstance(board[0], (str, bytes)):\n        # Case 2: 2D -&gt; list[list[int]]\n        # Convert inner sequences to lists of ints\n        grid: list[list[int]] = [[int(v) for v in row] for row in cast(Sequence[Sequence[Any]], board)]\n        return self._board.setBoard(grid)\n\n    # Case 3: 1D -&gt; list[int]\n    moves: list[int] = [int(v) for v in cast(Sequence[Any], board)]\n    return self._board.setBoard(moves)\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.to_array","title":"<code>to_array()</code>","text":"<p>Returns the board state as a 2D array (list of lists).</p> <p>Returns:</p> Type Description <code>list[list[int]]</code> <p>list[list[int]]: A 2D list representing the board state.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def to_array(self) -&gt; list[list[int]]:\n    \"\"\"Returns the board state as a 2D array (list of lists).\n\n    Returns:\n        list[list[int]]: A 2D list representing the board state.\n    \"\"\"\n    return self._board.toArray()\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.to_string","title":"<code>to_string()</code>","text":"<p>Returns a string representation of the board to print on the command line.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representing the board (e.g., \"002233...\").</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def to_string(self) -&gt; str:\n    \"\"\"Returns a string representation of the board to print on the command line.\n\n    Returns:\n        str: A string representing the board (e.g., \"002233...\").\n    \"\"\"\n    return self._board.toString()\n</code></pre>"},{"location":"python/#src.bitbully.board.Board.uid","title":"<code>uid()</code>","text":"<p>Returns a unique identifier for the current board state.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>A unique integer identifier for the board state.</p> Source code in <code>src/bitbully/board.py</code> <pre><code>def uid(self) -&gt; int:\n    \"\"\"Returns a unique identifier for the current board state.\n\n    Returns:\n        int: A unique integer identifier for the board state.\n    \"\"\"\n    return self._board.uid()\n</code></pre>"},{"location":"python/#src.bitbully.gui_c4.GuiC4","title":"<code>GuiC4</code>","text":"<p>A class which allows to create an interactive Connect-4 widget.</p> <p>GuiC4 is an interactive Connect-4 graphical user interface (GUI) implemented using Matplotlib, IPython widgets, and a backend agent from the BitBully engine. It provides the following main features:</p> <ul> <li>Interactive Game Board: Presents a dynamic 6-row by 7-column     Connect-4 board with clickable board cells.</li> <li>Matplotlib Integration: Utilizes Matplotlib figures     to render high-quality game visuals directly within Jupyter notebook environments.</li> <li>User Interaction: Captures and processes mouse clicks and button events, enabling     intuitive gameplay via either direct board interaction or button controls.</li> <li>Undo/Redo Moves: Supports undo and redo functionalities, allowing users to     navigate through their move history during gameplay.</li> <li>Automated Agent Moves: Incorporates BitBully, a Connect-4 backend engine, enabling     computer-generated moves and board evaluations.</li> <li>Game State Handling: Detects game-over scenarios, including win/draw conditions,     and provides immediate user feedback through popup alerts.</li> </ul> <p>Attributes:</p> Name Type Description <code>notify_output</code> <code>Output</code> <p>Output widget for notifications and popups.</p> <p>Examples:</p> <p>Generally, you should this method to retreive and display the widget.</p> <pre><code>&gt;&gt;&gt; %matplotlib ipympl\n&gt;&gt;&gt; c4gui = GuiC4()\n&gt;&gt;&gt; display(c4gui.get_widget())\n</code></pre> Source code in <code>src/bitbully/gui_c4.py</code> <pre><code>class GuiC4:\n    \"\"\"A class which allows to create an interactive Connect-4 widget.\n\n    GuiC4 is an interactive Connect-4 graphical user interface (GUI) implemented using\n    Matplotlib, IPython widgets, and a backend agent from the BitBully engine. It\n    provides the following main features:\n\n    - Interactive Game Board: Presents a dynamic 6-row by 7-column\n        Connect-4 board with clickable board cells.\n    - Matplotlib Integration: Utilizes Matplotlib figures\n        to render high-quality game visuals directly within Jupyter notebook environments.\n    - User Interaction: Captures and processes mouse clicks and button events, enabling\n        intuitive gameplay via either direct board interaction or button controls.\n    - Undo/Redo Moves: Supports undo and redo functionalities, allowing users to\n        navigate through their move history during gameplay.\n    - Automated Agent Moves: Incorporates BitBully, a Connect-4 backend engine, enabling\n        computer-generated moves and board evaluations.\n    - Game State Handling: Detects game-over scenarios, including win/draw conditions,\n        and provides immediate user feedback through popup alerts.\n\n    Attributes:\n        notify_output (widgets.Output): Output widget for notifications and popups.\n\n    Examples:\n            Generally, you should this method to retreive and display the widget.\n\n            ```pycon\n            &gt;&gt;&gt; %matplotlib ipympl\n            &gt;&gt;&gt; c4gui = GuiC4()\n            &gt;&gt;&gt; display(c4gui.get_widget())\n            ```\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Init the GuiC4 widget.\"\"\"\n        # Create a logger with the class name\n        self.m_logger = logging.getLogger(self.__class__.__name__)\n        self.m_logger.setLevel(logging.DEBUG)  # Set the logging level\n\n        # Create a console handler (optional)\n        ch = logging.StreamHandler()\n        ch.setLevel(logging.INFO)  # Set level for the handler\n\n        # Create a formatter and add it to the handler\n        formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n        ch.setFormatter(formatter)\n\n        # Add the handler to the logger\n        self.m_logger.addHandler(ch)\n\n        # Avoid adding handlers multiple times\n        self.m_logger.propagate = False\n        assets_pth = Path(str(importlib.resources.files(\"bitbully\").joinpath(\"assets\")))\n        png_empty = plt.imread(assets_pth.joinpath(\"empty.png\"), format=None)\n        png_empty_m = plt.imread(assets_pth.joinpath(\"empty_m.png\"), format=None)\n        png_empty_r = plt.imread(assets_pth.joinpath(\"empty_r.png\"), format=None)\n        png_red = plt.imread(assets_pth.joinpath(\"red.png\"), format=None)\n        png_red_m = plt.imread(assets_pth.joinpath(\"red_m.png\"), format=None)\n        png_yellow = plt.imread(assets_pth.joinpath(\"yellow.png\"), format=None)\n        png_yellow_m = plt.imread(assets_pth.joinpath(\"yellow_m.png\"), format=None)\n        self.m_png = {\n            0: {\"plain\": png_empty, \"corner\": png_empty_m, \"underline\": png_empty_r},\n            1: {\"plain\": png_yellow, \"corner\": png_yellow_m},\n            2: {\"plain\": png_red, \"corner\": png_red_m},\n        }\n\n        self.m_n_row, self.m_n_col = 6, 7\n\n        # TODO: probably not needed:\n        self.m_height = np.zeros(7, dtype=np.int32)\n\n        self.m_board_size = 3.5\n        # self.m_player = 1\n        self.is_busy = False\n\n        self.last_event_time = time.time()\n\n        # Create board first\n        self._create_board()\n\n        # Generate buttons for inserting the tokens:\n        self._create_buttons()\n\n        # Create control buttons\n        self._create_control_buttons()\n\n        # Capture clicks on the field\n        _ = self.m_fig.canvas.mpl_connect(\"button_press_event\", self._on_field_click)\n\n        # Movelist\n        self.m_movelist: list[tuple[int, int, int]] = []\n\n        # Redo list\n        self.m_redolist: list[tuple[int, int, int]] = []\n\n        # Gameover flag:\n        self.m_gameover = False\n\n        # C4 agent\n        import bitbully_databases as bbd\n\n        # TODO: allow choosing opening book\n        db_path: str = bbd.BitBullyDatabases.get_database_path(\"12-ply-dist\")\n        self.bitbully_agent = bitbully_core.BitBullyCore(Path(db_path))\n\n    def _reset(self) -&gt; None:\n        self.m_movelist = []\n        self.m_redolist = []\n        self.m_height = np.zeros(7, dtype=np.int32)\n        self.m_gameover = False\n\n        for im in self.ims:\n            im.set_data(self.m_png[0][\"plain\"])\n\n        self.m_fig.canvas.draw_idle()\n        self.m_fig.canvas.flush_events()\n        self._update_insert_buttons()\n\n    def _get_fig_size_px(self) -&gt; npt.NDArray[np.float64]:\n        # Get the size in inches\n        size_in_inches = self.m_fig.get_size_inches()\n        self.m_logger.debug(\"Figure size in inches: %f\", size_in_inches)\n\n        # Get the DPI\n        dpi = self.m_fig.dpi\n        self.m_logger.debug(\"Figure DPI: %d\", dpi)\n\n        # Convert to pixels\n        return size_in_inches * dpi\n\n    def _create_control_buttons(self) -&gt; None:\n        self.m_control_buttons = {}\n\n        # Create buttons for each column\n        self.m_logger.debug(\"Figure size: \", self._get_fig_size_px())\n\n        fig_size_px = self._get_fig_size_px()\n        wh = f\"{-3 + (fig_size_px[1] / self.m_n_row)}px\"\n        btn_layout = Layout(height=wh, width=wh)\n\n        button = Button(description=\"\ud83d\udd04\", tooltip=\"Reset Game\", layout=btn_layout)\n        button.on_click(lambda b: self._reset())\n        self.m_control_buttons[\"reset\"] = button\n\n        button = Button(description=\"\u21a9\ufe0f\", tooltip=\"Undo Move\", layout=btn_layout)\n        button.disabled = True\n        button.on_click(lambda b: self._undo_move())\n        self.m_control_buttons[\"undo\"] = button\n\n        button = Button(description=\"\u21aa\ufe0f\", tooltip=\"Redo Move\", layout=btn_layout)\n        button.disabled = True\n        button.on_click(lambda b: self._redo_move())\n        self.m_control_buttons[\"redo\"] = button\n\n        button = Button(description=\"\ud83d\udd79\ufe0f\", tooltip=\"Computer Move\", layout=btn_layout)\n        button.on_click(lambda b: self._computer_move())\n        self.m_control_buttons[\"move\"] = button\n\n        button = Button(description=\"\ud83d\udcca\", tooltip=\"Evaluate Board\", layout=btn_layout)\n        self.m_control_buttons[\"evaluate\"] = button\n\n    def _computer_move(self) -&gt; None:\n        self.is_busy = True\n        self._update_insert_buttons()\n        b = bitbully_core.BoardCore()\n        assert b.setBoard([mv[1] for mv in self.m_movelist])\n        move_scores = self.bitbully_agent.scoreMoves(b)\n        self.is_busy = False\n        self._insert_token(int(np.argmax(move_scores)))\n\n    def _create_board(self) -&gt; None:\n        self.output = Output()\n\n        with self.output:\n            fig, axs = plt.subplots(\n                self.m_n_row,\n                self.m_n_col,\n                figsize=(\n                    self.m_board_size / self.m_n_row * self.m_n_col,\n                    self.m_board_size,\n                ),\n            )\n            axs = axs.flatten()\n            self.ims = []\n            for ax in axs:\n                self.ims.append(ax.imshow(self.m_png[0][\"plain\"], animated=True))\n                ax.axis(\"off\")\n                ax.set_xticklabels([])\n                ax.set_yticklabels([])\n\n            fig.tight_layout()\n            plt.subplots_adjust(wspace=0.05, hspace=0.05, left=0.0, right=1.0, top=1.0, bottom=0.0)\n            fig.suptitle(\"\")\n            fig.set_facecolor(\"darkgray\")\n            fig.canvas.toolbar_visible = False  # type: ignore[attr-defined]\n            fig.canvas.resizable = False  # type: ignore[attr-defined]\n            fig.canvas.toolbar_visible = False  # type: ignore[attr-defined]\n            fig.canvas.header_visible = False  # type: ignore[attr-defined]\n            fig.canvas.footer_visible = False  # type: ignore[attr-defined]\n            fig.canvas.capture_scroll = True  # type: ignore[attr-defined]\n            plt.show(block=False)\n\n        self.m_fig = fig\n        self.m_axs = axs\n\n    notify_output: widgets.Output = widgets.Output()\n    display(notify_output)\n\n    @notify_output.capture()\n    def _popup(self, text: str) -&gt; None:\n        clear_output()\n        display(Javascript(f\"alert('{text}')\"))\n\n    def _is_legal_move(self, col: int) -&gt; bool:\n        return not self.m_height[col] &gt;= self.m_n_row\n\n    def _insert_token(self, col: int, reset_redo_list: bool = True) -&gt; None:\n        if self.is_busy:\n            return\n        self.is_busy = True\n\n        for button in self.m_insert_buttons:\n            button.disabled = True\n\n        board = bitbully_core.BoardCore()\n        board.setBoard([mv[1] for mv in self.m_movelist])\n        if self.m_gameover or not board.play(col):\n            self._update_insert_buttons()\n            self.is_busy = False\n            return\n\n        try:\n            # Get player\n            player = 1 if not self.m_movelist else 3 - self.m_movelist[-1][0]\n            self.m_movelist.append((player, col, self.m_height[col]))\n            self._paint_token()\n            self.m_height[col] += 1\n\n            # Usually, after a move is performed, there is no possibility to\n            # redo a move again\n            if reset_redo_list:\n                self.m_redolist = []\n\n            self._check_winner(board)\n\n        except Exception as e:\n            self.m_logger.error(\"Error: %s\", str(e))\n            raise\n        finally:\n            time.sleep(0.5)  # debounce button\n            # Re-enable all buttons (if columns not full)\n            self.is_busy = False\n            self._update_insert_buttons()\n\n    def _redo_move(self) -&gt; None:\n        if len(self.m_redolist) &lt; 1:\n            return\n        _p, col, _row = self.m_redolist.pop()\n        self._insert_token(col, reset_redo_list=False)\n\n    def _undo_move(self) -&gt; None:\n        if len(self.m_movelist) &lt; 1:\n            return\n\n        if self.is_busy:\n            return\n        self.is_busy = True\n\n        try:\n            _p, col, row = mv = self.m_movelist.pop()\n            self.m_redolist.append(mv)\n\n            self.m_height[col] -= 1\n            assert row == self.m_height[col]\n\n            img_idx = self._get_img_idx(col, row)\n\n            self.ims[img_idx].set_data(self.m_png[0][\"plain\"])\n            self.m_axs[img_idx].draw_artist(self.ims[img_idx])\n            if len(self.m_movelist) &gt; 0:\n                self._paint_token()\n            else:\n                self.m_fig.canvas.blit(self.ims[img_idx].get_clip_box())\n                self.m_fig.canvas.flush_events()\n\n            self.m_gameover = False\n\n        except Exception as e:\n            self.m_logger.error(\"Error: %s\", str(e))\n            raise\n        finally:\n            # Re-enable all buttons (if columns not full)\n            self.is_busy = False\n            self._update_insert_buttons()\n\n            time.sleep(0.5)  # debounce button\n\n    def _update_insert_buttons(self) -&gt; None:\n        for button, col in zip(self.m_insert_buttons, range(self.m_n_col)):\n            button.disabled = bool(self.m_height[col] &gt;= self.m_n_row) or self.m_gameover or self.is_busy\n\n        self.m_control_buttons[\"undo\"].disabled = len(self.m_movelist) &lt; 1 or self.is_busy\n        self.m_control_buttons[\"redo\"].disabled = len(self.m_redolist) &lt; 1 or self.is_busy\n        self.m_control_buttons[\"move\"].disabled = self.m_gameover or self.is_busy\n        self.m_control_buttons[\"evaluate\"].disabled = self.m_gameover or self.is_busy\n\n    def _get_img_idx(self, col: int, row: int) -&gt; int:\n        \"\"\"Translates a column and row ID into the corresponding image ID.\n\n        Args:\n            col (int): column (0-6) of the considered board cell.\n            row (int): row (0-5) of the considered board cell.\n\n        Returns:\n            int: The corresponding image id (0-41).\n        \"\"\"\n        self.m_logger.debug(\"Got column: %d\", col)\n\n        return col % self.m_n_col + (self.m_n_row - row - 1) * self.m_n_col\n\n    def _paint_token(self) -&gt; None:\n        if len(self.m_movelist) &lt; 1:\n            return\n\n        p, col, row = self.m_movelist[-1]\n        img_idx = self._get_img_idx(col, row)\n        self.m_logger.debug(\"Paint token: %d\", img_idx)\n\n        #\n        # no need to reset background, since we anyhow overwrite it again\n        # self.m_fig.canvas.restore_region(self.m_background[img_idx])\n        self.ims[img_idx].set_data(self.m_png[p][\"corner\"])\n\n        # see: https://matplotlib.org/3.4.3/Matplotlib.pdf\n        #      2.3.1 Faster rendering by using blitting\n        blit_boxes = []\n        self.m_axs[img_idx].draw_artist(self.ims[img_idx])\n        blit_boxes.append(self.ims[img_idx].get_clip_box())\n        # self.m_fig.canvas.blit()\n\n        if len(self.m_movelist) &gt; 1:\n            # Remove the white corners for the second-to-last move\n            # TODO: redundant code above\n            p, col, row = self.m_movelist[-2]\n            img_idx = self._get_img_idx(col, row)\n            self.ims[img_idx].set_data(self.m_png[p][\"plain\"])\n            self.m_axs[img_idx].draw_artist(self.ims[img_idx])\n            blit_boxes.append(self.ims[img_idx].get_clip_box())\n\n        self.m_fig.canvas.blit(blit_boxes[0])\n\n        # self.m_fig.canvas.restore_region(self.m_background[img_idx])\n        # self.m_fig.canvas.blit(self.ims[img_idx].get_clip_box())\n        # self.m_fig.canvas.draw_idle()\n        self.m_fig.canvas.flush_events()\n\n    def _create_buttons(self) -&gt; None:\n        # Create buttons for each column\n        self.m_logger.debug(\"Figure size: \", self._get_fig_size_px())\n\n        fig_size_px = self._get_fig_size_px()\n\n        self.m_insert_buttons = []\n        for col in range(self.m_n_col):\n            button = Button(\n                description=\"\u23ec\",\n                layout=Layout(width=f\"{-3 + (fig_size_px[0] / self.m_n_col)}px\", height=\"50px\"),\n            )\n            button.on_click(lambda b, col=col: self._insert_token(col))\n            self.m_insert_buttons.append(button)\n\n    def _create_column_labels(self) -&gt; HBox:\n        \"\"\"Creates a row with the column labels 'a' to 'g'.\n\n        Returns:\n            HBox: A row of textboxes containing the columns labels 'a' to 'g'.\n        \"\"\"\n        fig_size_px = self._get_fig_size_px()\n        width = f\"{-3 + (fig_size_px[0] / self.m_n_col)}px\"\n        textboxes = [\n            widgets.Label(\n                value=chr(ord(\"a\") + i),\n                layout=Layout(justify_content=\"center\", align_items=\"center\", width=width),\n            )\n            for i in range(self.m_n_col)\n        ]\n        return HBox(\n            textboxes,\n            layout=Layout(\n                display=\"flex\",\n                flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n                justify_content=\"center\",  # Left alignment\n                align_items=\"center\",  # Top alignment\n            ),\n        )\n\n    def _on_field_click(self, event: mpl_backend_bases.Event) -&gt; None:\n        \"\"\"Based on the column where the click was detected, insert a token.\n\n        Args:\n            event (mpl_backend_bases.Event): A matplotlib mouse event.\n        \"\"\"\n        if isinstance(event, mpl_backend_bases.MouseEvent):\n            ix, iy = event.xdata, event.ydata\n            self.m_logger.debug(\"click (x,y): %d, %d\", ix, iy)\n            idx = np.where(self.m_axs == event.inaxes)[0][0] % self.m_n_col\n            self._insert_token(idx)\n\n    def get_widget(self) -&gt; AppLayout:\n        \"\"\"Get the widget.\n\n        Examples:\n            Generally, you should this method to retreive and display the widget.\n\n            ```pycon\n            &gt;&gt;&gt; %matplotlib ipympl\n            &gt;&gt;&gt; c4gui = GuiC4()\n            &gt;&gt;&gt; display(c4gui.get_widget())\n            ```\n\n        Returns:\n            AppLayout: the widget.\n        \"\"\"\n        # Arrange buttons in a row\n        insert_button_row = HBox(\n            self.m_insert_buttons,\n            layout=Layout(\n                display=\"flex\",\n                flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n                justify_content=\"center\",  # Left alignment\n                align_items=\"center\",  # Top alignment\n            ),\n        )\n        control_buttons_col = HBox(\n            [VBox(list(self.m_control_buttons.values()))],\n            layout=Layout(\n                display=\"flex\",\n                flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n                justify_content=\"flex-end\",  # Left alignment\n                align_items=\"center\",  # Top alignment\n            ),\n        )\n\n        tb = self._create_column_labels()\n\n        return AppLayout(\n            header=None,\n            left_sidebar=control_buttons_col,\n            center=VBox(\n                [insert_button_row, self.output, tb],\n                layout=Layout(\n                    display=\"flex\",\n                    flex_flow=\"column wrap\",\n                    justify_content=\"flex-start\",  # Left alignment\n                    align_items=\"flex-start\",  # Top alignment\n                ),\n            ),\n            footer=None,\n            right_sidebar=None,\n        )\n\n    def _check_winner(self, board: bitbully_core.BoardCore) -&gt; None:\n        \"\"\"Check for Win or draw.\"\"\"\n        if board.hasWin():\n            winner = \"Yellow\" if board.movesLeft() % 2 else \"Red\"\n            self._popup(f\"Game over! {winner} wins!\")\n            self.m_gameover = True\n        if board.movesLeft() == 0:\n            self._popup(\"Game over! Draw!\")\n            self.m_gameover = True\n\n    def destroy(self) -&gt; None:\n        \"\"\"Destroy and release the acquired resources.\"\"\"\n        plt.close(self.m_fig)\n        del self.bitbully_agent\n        del self.m_axs\n        del self.m_fig\n        del self.output\n</code></pre>"},{"location":"python/#src.bitbully.gui_c4.GuiC4.__init__","title":"<code>__init__()</code>","text":"<p>Init the GuiC4 widget.</p> Source code in <code>src/bitbully/gui_c4.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Init the GuiC4 widget.\"\"\"\n    # Create a logger with the class name\n    self.m_logger = logging.getLogger(self.__class__.__name__)\n    self.m_logger.setLevel(logging.DEBUG)  # Set the logging level\n\n    # Create a console handler (optional)\n    ch = logging.StreamHandler()\n    ch.setLevel(logging.INFO)  # Set level for the handler\n\n    # Create a formatter and add it to the handler\n    formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n    ch.setFormatter(formatter)\n\n    # Add the handler to the logger\n    self.m_logger.addHandler(ch)\n\n    # Avoid adding handlers multiple times\n    self.m_logger.propagate = False\n    assets_pth = Path(str(importlib.resources.files(\"bitbully\").joinpath(\"assets\")))\n    png_empty = plt.imread(assets_pth.joinpath(\"empty.png\"), format=None)\n    png_empty_m = plt.imread(assets_pth.joinpath(\"empty_m.png\"), format=None)\n    png_empty_r = plt.imread(assets_pth.joinpath(\"empty_r.png\"), format=None)\n    png_red = plt.imread(assets_pth.joinpath(\"red.png\"), format=None)\n    png_red_m = plt.imread(assets_pth.joinpath(\"red_m.png\"), format=None)\n    png_yellow = plt.imread(assets_pth.joinpath(\"yellow.png\"), format=None)\n    png_yellow_m = plt.imread(assets_pth.joinpath(\"yellow_m.png\"), format=None)\n    self.m_png = {\n        0: {\"plain\": png_empty, \"corner\": png_empty_m, \"underline\": png_empty_r},\n        1: {\"plain\": png_yellow, \"corner\": png_yellow_m},\n        2: {\"plain\": png_red, \"corner\": png_red_m},\n    }\n\n    self.m_n_row, self.m_n_col = 6, 7\n\n    # TODO: probably not needed:\n    self.m_height = np.zeros(7, dtype=np.int32)\n\n    self.m_board_size = 3.5\n    # self.m_player = 1\n    self.is_busy = False\n\n    self.last_event_time = time.time()\n\n    # Create board first\n    self._create_board()\n\n    # Generate buttons for inserting the tokens:\n    self._create_buttons()\n\n    # Create control buttons\n    self._create_control_buttons()\n\n    # Capture clicks on the field\n    _ = self.m_fig.canvas.mpl_connect(\"button_press_event\", self._on_field_click)\n\n    # Movelist\n    self.m_movelist: list[tuple[int, int, int]] = []\n\n    # Redo list\n    self.m_redolist: list[tuple[int, int, int]] = []\n\n    # Gameover flag:\n    self.m_gameover = False\n\n    # C4 agent\n    import bitbully_databases as bbd\n\n    # TODO: allow choosing opening book\n    db_path: str = bbd.BitBullyDatabases.get_database_path(\"12-ply-dist\")\n    self.bitbully_agent = bitbully_core.BitBullyCore(Path(db_path))\n</code></pre>"},{"location":"python/#src.bitbully.gui_c4.GuiC4.destroy","title":"<code>destroy()</code>","text":"<p>Destroy and release the acquired resources.</p> Source code in <code>src/bitbully/gui_c4.py</code> <pre><code>def destroy(self) -&gt; None:\n    \"\"\"Destroy and release the acquired resources.\"\"\"\n    plt.close(self.m_fig)\n    del self.bitbully_agent\n    del self.m_axs\n    del self.m_fig\n    del self.output\n</code></pre>"},{"location":"python/#src.bitbully.gui_c4.GuiC4.get_widget","title":"<code>get_widget()</code>","text":"<p>Get the widget.</p> <p>Examples:</p> <p>Generally, you should this method to retreive and display the widget.</p> <pre><code>&gt;&gt;&gt; %matplotlib ipympl\n&gt;&gt;&gt; c4gui = GuiC4()\n&gt;&gt;&gt; display(c4gui.get_widget())\n</code></pre> <p>Returns:</p> Name Type Description <code>AppLayout</code> <code>AppLayout</code> <p>the widget.</p> Source code in <code>src/bitbully/gui_c4.py</code> <pre><code>def get_widget(self) -&gt; AppLayout:\n    \"\"\"Get the widget.\n\n    Examples:\n        Generally, you should this method to retreive and display the widget.\n\n        ```pycon\n        &gt;&gt;&gt; %matplotlib ipympl\n        &gt;&gt;&gt; c4gui = GuiC4()\n        &gt;&gt;&gt; display(c4gui.get_widget())\n        ```\n\n    Returns:\n        AppLayout: the widget.\n    \"\"\"\n    # Arrange buttons in a row\n    insert_button_row = HBox(\n        self.m_insert_buttons,\n        layout=Layout(\n            display=\"flex\",\n            flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n            justify_content=\"center\",  # Left alignment\n            align_items=\"center\",  # Top alignment\n        ),\n    )\n    control_buttons_col = HBox(\n        [VBox(list(self.m_control_buttons.values()))],\n        layout=Layout(\n            display=\"flex\",\n            flex_flow=\"row wrap\",  # or \"column\" depending on your layout needs\n            justify_content=\"flex-end\",  # Left alignment\n            align_items=\"center\",  # Top alignment\n        ),\n    )\n\n    tb = self._create_column_labels()\n\n    return AppLayout(\n        header=None,\n        left_sidebar=control_buttons_col,\n        center=VBox(\n            [insert_button_row, self.output, tb],\n            layout=Layout(\n                display=\"flex\",\n                flex_flow=\"column wrap\",\n                justify_content=\"flex-start\",  # Left alignment\n                align_items=\"flex-start\",  # Top alignment\n            ),\n        ),\n        footer=None,\n        right_sidebar=None,\n    )\n</code></pre>"},{"location":"user_guide/","title":"BitBully User Guide","text":""}]}