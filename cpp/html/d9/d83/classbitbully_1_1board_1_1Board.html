<!-- HTML header for doxygen 1.13.1-->
<!---generate with: doxygen -w html header.html delete_me.html delete_me.css -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type"/>
    <meta content="IE=11" http-equiv="X-UA-Compatible"/>
    <meta content="Doxygen 1.14.0" name="generator"/>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
    <title>BitBully: bitbully.board.Board Class Reference</title>
    <link href="../../tabs.css" rel="stylesheet" type="text/css"/>
    <script src="../../jquery.js" type="text/javascript"></script>
    <script src="../../dynsections.js" type="text/javascript"></script>
    <link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
    <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
    <link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
    <!-- ... other metadata & script includes ... -->
    <script src="../../doxygen-awesome-darkmode-toggle.js" type="text/javascript"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
    </script>
    <!-- ... other metadata & script includes ... -->
    <script src="../../doxygen-awesome-fragment-copy-button.js" type="text/javascript"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellpadding="0" cellspacing="0">
                <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img  alt="Logo" src="../../bitbully-logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">BitBully<span id="projectnumber">&#160;0.0.68</span>
                        </div>
                    </td>
                </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('d9/d83/classbitbully_1_1board_1_1Board.html','../../','d1/daa/classbitbully_1_1board_1_1Board-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">bitbully.board.Board Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a26f6bb8016db04d0ed10a8c05cfb87e6" id="r_a26f6bb8016db04d0ed10a8c05cfb87e6"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26f6bb8016db04d0ed10a8c05cfb87e6">__init__</a> (self, Sequence[Sequence[int]]|Sequence[int]|str|None init_with=None)</td></tr>
<tr class="memitem:a14e3593ac443efa0acedf090e3671a7d" id="r_a14e3593ac443efa0acedf090e3671a7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14e3593ac443efa0acedf090e3671a7d">__eq__</a> (self, object value)</td></tr>
<tr class="memitem:af95a367c9b9e977c07ee89189f1e6087" id="r_af95a367c9b9e977c07ee89189f1e6087"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af95a367c9b9e977c07ee89189f1e6087">__ne__</a> (self, object value)</td></tr>
<tr class="memitem:a685b273338fc40f86ce851d01632aeaf" id="r_a685b273338fc40f86ce851d01632aeaf"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a685b273338fc40f86ce851d01632aeaf">__repr__</a> (self)</td></tr>
<tr class="memitem:ad9a2dd40b4217e8d4f3aac392444f79e" id="r_ad9a2dd40b4217e8d4f3aac392444f79e"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9a2dd40b4217e8d4f3aac392444f79e">__str__</a> (self)</td></tr>
<tr class="memitem:a42903f41f41e423c133fd9ed842d2ed8" id="r_a42903f41f41e423c133fd9ed842d2ed8"><td class="memItemLeft" align="right" valign="top">list[<a class="el" href="../../d9/d83/classbitbully_1_1board_1_1Board.html">Board</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42903f41f41e423c133fd9ed842d2ed8">all_positions</a> (self, int up_to_n_ply, bool exactly_n)</td></tr>
<tr class="memitem:a9514b7e3caa5c5d7c3bedd0268865fc1" id="r_a9514b7e3caa5c5d7c3bedd0268865fc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9514b7e3caa5c5d7c3bedd0268865fc1">can_win_next</a> (self, int|None move=None)</td></tr>
<tr class="memitem:a0babec5f817efa063b5e89e035d79b4e" id="r_a0babec5f817efa063b5e89e035d79b4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d83/classbitbully_1_1board_1_1Board.html">Board</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0babec5f817efa063b5e89e035d79b4e">copy</a> (self)</td></tr>
<tr class="memitem:a357ea549197e657a8ea52dcca863b039" id="r_a357ea549197e657a8ea52dcca863b039"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a357ea549197e657a8ea52dcca863b039">count_tokens</a> (self)</td></tr>
<tr class="memitem:ae50b3749d5857b53f6d8d7fed35b3bf7" id="r_ae50b3749d5857b53f6d8d7fed35b3bf7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae50b3749d5857b53f6d8d7fed35b3bf7">has_win</a> (self)</td></tr>
<tr class="memitem:aa56a2afaa85ded51091e20ae61b872ec" id="r_aa56a2afaa85ded51091e20ae61b872ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa56a2afaa85ded51091e20ae61b872ec">__hash__</a> (self)</td></tr>
<tr class="memitem:af0547d9a280ddeaebe6bf563c8a0617a" id="r_af0547d9a280ddeaebe6bf563c8a0617a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0547d9a280ddeaebe6bf563c8a0617a">is_legal_move</a> (self, int move)</td></tr>
<tr class="memitem:aa90638e1d8ff88b5eaedef40b6a6e30e" id="r_aa90638e1d8ff88b5eaedef40b6a6e30e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d83/classbitbully_1_1board_1_1Board.html">Board</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa90638e1d8ff88b5eaedef40b6a6e30e">mirror</a> (self)</td></tr>
<tr class="memitem:aed729a7efcbf07f00e2a8773b875291d" id="r_aed729a7efcbf07f00e2a8773b875291d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed729a7efcbf07f00e2a8773b875291d">moves_left</a> (self)</td></tr>
<tr class="memitem:ac703e9fec40c4d9c60c314b33eb44bbd" id="r_ac703e9fec40c4d9c60c314b33eb44bbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac703e9fec40c4d9c60c314b33eb44bbd">play</a> (self, int|Sequence[int]|str move)</td></tr>
<tr class="memitem:a0c4555d1cb4a50484294b8452b4f02a9" id="r_a0c4555d1cb4a50484294b8452b4f02a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d83/classbitbully_1_1board_1_1Board.html">Board</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c4555d1cb4a50484294b8452b4f02a9">play_on_copy</a> (self, int move)</td></tr>
<tr class="memitem:a3ec7505932466440fce1a9fbbd54355a" id="r_a3ec7505932466440fce1a9fbbd54355a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ec7505932466440fce1a9fbbd54355a">reset_board</a> (self, Sequence[int]|Sequence[Sequence[int]]|str|None board=None)</td></tr>
<tr class="memitem:a936a2a08230396f27c72a75d53103282" id="r_a936a2a08230396f27c72a75d53103282"><td class="memItemLeft" align="right" valign="top">list[list[int]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a936a2a08230396f27c72a75d53103282">to_array</a> (self, bool column_major_layout=True)</td></tr>
<tr class="memitem:a3db1df514e7c6d510f2188ceb7419aca" id="r_a3db1df514e7c6d510f2188ceb7419aca"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3db1df514e7c6d510f2188ceb7419aca">to_string</a> (self)</td></tr>
<tr class="memitem:ad06cd5ac21f137de6b80c9b4f8f89d3b" id="r_ad06cd5ac21f137de6b80c9b4f8f89d3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad06cd5ac21f137de6b80c9b4f8f89d3b">uid</a> (self)</td></tr>
<tr class="memitem:a034cd0819f00709bcaa40520c0972098" id="r_a034cd0819f00709bcaa40520c0972098"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a034cd0819f00709bcaa40520c0972098">current_player</a> (self)</td></tr>
<tr class="memitem:a1f0472df8447db26820d7dd99ffe2bab" id="r_a1f0472df8447db26820d7dd99ffe2bab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f0472df8447db26820d7dd99ffe2bab">is_full</a> (self)</td></tr>
<tr class="memitem:aad6d6426114ac320acf00f17f8291d0d" id="r_aad6d6426114ac320acf00f17f8291d0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad6d6426114ac320acf00f17f8291d0d">is_game_over</a> (self)</td></tr>
<tr class="memitem:aa46e665bb5d315b9be74324bdeb36c3f" id="r_aa46e665bb5d315b9be74324bdeb36c3f"><td class="memItemLeft" align="right" valign="top">int|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa46e665bb5d315b9be74324bdeb36c3f">winner</a> (self)</td></tr>
<tr class="memitem:a9b97a7ced0bf0ed804d120478f57f257" id="r_a9b97a7ced0bf0ed804d120478f57f257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d83/classbitbully_1_1board_1_1Board.html">Board</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b97a7ced0bf0ed804d120478f57f257">from_moves</a> (cls, Sequence[int]|str moves)</td></tr>
<tr class="memitem:a04cf3920d1f460872b42d77c538a3423" id="r_a04cf3920d1f460872b42d77c538a3423"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d83/classbitbully_1_1board_1_1Board.html">Board</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04cf3920d1f460872b42d77c538a3423">from_array</a> (cls, Sequence[Sequence[int]] arr)</td></tr>
<tr class="memitem:a0631f7c4d3734f0bb0993501f67f617c" id="r_a0631f7c4d3734f0bb0993501f67f617c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0631f7c4d3734f0bb0993501f67f617c">to_huffman</a> (self)</td></tr>
<tr class="memitem:afe754d7343ddc9c2b4596ec2c5eea43a" id="r_afe754d7343ddc9c2b4596ec2c5eea43a"><td class="memItemLeft" align="right" valign="top">list[int]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe754d7343ddc9c2b4596ec2c5eea43a">legal_moves</a> (self, bool non_losing=False, bool order_moves=False)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad2a69d01c5b7e9f77041180f58355ae8" id="r_ad2a69d01c5b7e9f77041180f58355ae8"><td class="memItemLeft" align="right" valign="top">tuple[<a class="el" href="../../d9/d83/classbitbully_1_1board_1_1Board.html">Board</a>, list[int]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2a69d01c5b7e9f77041180f58355ae8">random_board</a> (int n_ply, bool forbid_direct_win)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1091ba72ad36a44683ce490d76726447" id="r_a1091ba72ad36a44683ce490d76726447"><td class="memItemLeft" align="right" valign="top">ClassVar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1091ba72ad36a44683ce490d76726447">N_COLUMNS</a> = bitbully_core.N_COLUMNS</td></tr>
<tr class="memitem:aa729e1bd85ba1e8a4e1860b3bd6d5270" id="r_aa729e1bd85ba1e8a4e1860b3bd6d5270"><td class="memItemLeft" align="right" valign="top">ClassVar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa729e1bd85ba1e8a4e1860b3bd6d5270">N_ROWS</a> = bitbully_core.N_ROWS</td></tr>
<tr class="memitem:a6600d819beec87b6cc78c3a90966170c" id="r_a6600d819beec87b6cc78c3a90966170c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6600d819beec87b6cc78c3a90966170c">Player</a> = bitbully_core.Player</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-attribs" class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad34abdcda492a98a5532c713d83f4f0b" id="r_ad34abdcda492a98a5532c713d83f4f0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad34abdcda492a98a5532c713d83f4f0b">_board</a> = bitbully_core.BoardCore()</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Represents the state of a Connect Four board. Mostly a thin wrapper around BoardCore.</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00011">11</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a26f6bb8016db04d0ed10a8c05cfb87e6" name="a26f6bb8016db04d0ed10a8c05cfb87e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f6bb8016db04d0ed10a8c05cfb87e6">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None bitbully.board.Board.__init__ </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[Sequence[int]] | Sequence[int] | str | None </td>          <td class="paramname"><span class="paramname"><em>init_with</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initializes a Board instance.

Args:
    init_with (Sequence[Sequence[int]] | Sequence[int] | str | None):
        Optional initial board state. Accepts:
        - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7
        - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3])
        - String: A move sequence of columns as string (e.g., "002233")
        - None for an empty board

Raises:
    ValueError: If the provided initial board state is invalid.

Example:
    You can initialize an empty board in multiple ways:
    ```python
    import bitbully as bb

    # Create an empty board using the default constructor.
    board = bb.Board()  # Starts with no tokens placed.

    # Alternatively, initialize the board explicitly from a 2D list.
    # Each inner list represents a column (7 columns total, 6 rows each).
    # A value of 0 indicates an empty cell; 1 and 2 would represent player tokens.
    board = bb.Board([[0] * 6 for _ in range(7)])  # Equivalent to an empty board.

    # You can also set up a specific board position manually using a 6 x 7 layout,
    # where each inner list represents a row instead of a column.
    # (Both layouts are accepted by BitBully for convenience.)
    # For more complex examples using 2D arrays, see the examples below.
    board = bb.Board([[0] * 7 for _ in range(6)])  # Also equivalent to an empty board.

    # Display the board in text form.
    # The __repr__ method shows the current state (useful for debugging or interactive use).
    board
    ```
    Expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    ```

The recommended way to initialize an empty board is simply `Board()`.

Example:
    You can also initialize a board with a sequence of moves:
    ```python
    import bitbully as bb

    # Initialize a board with a sequence of moves played in the center column.

    # The list [3, 3, 3] represents three moves in column index 3 (zero-based).
    # Moves alternate automatically between Player 1 (yellow, X) and Player 2 (red, O).
    # After these three moves, the center column will contain:
    #   - Row 0: Player 1 token (bottom)
    #   - Row 1: Player 2 token
    #   - Row 2: Player 1 token
    board = bb.Board([3, 3, 3])

    # Display the resulting board.
    # The textual output shows the tokens placed in the center column.
    board
    ```

    Expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  X  _  _  _
    _  _  _  O  _  _  _
    _  _  _  X  _  _  _
    ```

Example:
    You can also initialize a board using a string containing a move sequence:
    ```python
    import bitbully as bb

    # Initialize a board using a compact move string.

    # The string "33333111" represents a sequence of eight moves:
    #   3 3 3 3 3 → five moves in the center column (index 3)
    #   1 1 1 → three moves in the second column (index 1)
    #
    # Moves are applied in order, alternating automatically between Player 1 (yellow, X)
    # and Player 2 (red, O), just as if you had called `board.play()` repeatedly.
    #
    # This shorthand is convenient for reproducing board states or test positions
    # without having to provide long move lists.

    board = bb.Board("33333111")

    # Display the resulting board.
    # The printed layout shows how the tokens stack in each column.
    board
    ```
    Expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  X  _  _  _
    _  _  _  O  _  _  _
    _  O  _  X  _  _  _
    _  X  _  O  _  _  _
    _  O  _  X  _  _  _
    ```

Example:
    You can also initialize a board using a 2D array (list of lists):
    ```python
    import bitbully as bb

    # Use a 6 x 7 list (rows x columns) to set up a specific board position manually.

    # Each inner list represents a row of the Connect-4 grid.
    # Convention:
    #   - 0 → empty cell
    #   - 1 → Player 1 token (yellow, X)
    #   - 2 → Player 2 token (red, O)
    #
    # The top list corresponds to the *top row* (row index 5),
    # and the bottom list corresponds to the *bottom row* (row index 0).
    # This layout matches the typical visual display of the board.

    board_array = [
        [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)
        [0, 0, 0, 1, 0, 0, 0],  # Row 4: Player 1 token in column 3
        [0, 0, 0, 2, 0, 0, 0],  # Row 3: Player 2 token in column 3
        [0, 2, 0, 1, 0, 0, 0],  # Row 2: tokens in columns 1 and 3
        [0, 1, 0, 2, 0, 0, 0],  # Row 1: tokens in columns 1 and 3
        [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom): tokens stacked lowest
    ]

    # Create a Board instance directly from the 2D list.
    # This allows reconstructing arbitrary positions (e.g., from test data or saved states)
    # without replaying the move sequence.
    board = bb.Board(board_array)

    # Display the resulting board state in text form.
    board
    ```
    Expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  X  _  _  _
    _  _  _  O  _  _  _
    _  O  _  X  _  _  _
    _  X  _  O  _  _  _
    _  O  _  X  _  _  _
    ```

Example:
    You can also initialize a board using a 2D (7 x 6) array with columns as inner lists:
    ```python
    import bitbully as bb

    # Use a 7 x 6 list (columns x rows) to set up a specific board position manually.

    # Each inner list represents a **column** of the Connect-4 board, from left (index 0)
    # to right (index 6). Each column contains six entries — one for each row, from
    # bottom (index 0) to top (index 5).
    #
    # Convention:
    #   - 0 → empty cell
    #   - 1 → Player 1 token (yellow, X)
    #   - 2 → Player 2 token (red, O)
    #
    # This column-major layout matches the internal representation used by BitBully,
    # where tokens are dropped into columns rather than filled row by row.

    board_array = [
        [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)
        [2, 1, 2, 0, 0, 0],  # Column 1
        [0, 0, 0, 0, 0, 0],  # Column 2
        [1, 2, 1, 2, 1, 0],  # Column 3 (center)
        [0, 0, 0, 0, 0, 0],  # Column 4
        [0, 0, 0, 0, 0, 0],  # Column 5
        [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)
    ]

    # Create a Board instance directly from the 2D list.
    # This allows reconstructing any arbitrary position (e.g., test cases, saved games)
    # without replaying all moves individually.
    board = bb.Board(board_array)

    # Display the resulting board.
    # The text output shows tokens as they would appear in a real Connect-4 grid.
    board
    ```
    Expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  X  _  _  _
    _  _  _  O  _  _  _
    _  O  _  X  _  _  _
    _  X  _  O  _  _  _
    _  O  _  X  _  _  _
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00020">20</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a14e3593ac443efa0acedf090e3671a7d" name="a14e3593ac443efa0acedf090e3671a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e3593ac443efa0acedf090e3671a7d">&#9670;&#160;</a></span>__eq__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool bitbully.board.Board.__eq__ </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks equality between two Board instances.

Notes:
    - Equality checks in BitBully compare the *exact board state* (bit patterns),
      not just the move history.
    - Two different move sequences can still yield the same position if they
      result in identical token configurations.
    - This is useful for comparing solver states, verifying test positions,
      or detecting transpositions in search algorithms.

Args:
    value (object): The other Board instance to compare against.

Returns:
    bool: True if both boards are equal, False otherwise.

Raises:
    NotImplementedError: If the other value is not a Board instance.

Example:
    ```python
    import bitbully as bb

    # Create two boards that should represent *identical* game states.
    board1 = bb.Board()
    assert board1.play("33333111")

    board2 = bb.Board()
    # Play the same position step by step using a different but equivalent sequence.
    # Internally, the final bitboard state will match `board1`.
    assert board2.play("31133331")

    # Boards with identical token placements are considered equal.
    # Equality (`==`) and inequality (`!=`) operators are overloaded for convenience.
    assert board1 == board2
    assert not (board1 != board2)

    # ------------------------------------------------------------------------------

    # Create two boards that differ by one move.
    board1 = bb.Board("33333111")
    board2 = bb.Board("33333112")  # One extra move in the last column (index 2)

    # Since the token layout differs, equality no longer holds.
    assert board1 != board2
    assert not (board1 == board2)
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00230">230</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="aa56a2afaa85ded51091e20ae61b872ec" name="aa56a2afaa85ded51091e20ae61b872ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56a2afaa85ded51091e20ae61b872ec">&#9670;&#160;</a></span>__hash__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int bitbully.board.Board.__hash__ </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a hash of the Board instance for use in hash-based collections.

Returns:
    int: The hash value of the Board instance.

Example:
    ```python
    import bitbully as bb

    # Create two boards that represent the same final position.
    # The first board is initialized directly from a move string.
    board1 = bb.Board("33333111")

    # The second board is built incrementally by playing an equivalent sequence of moves.
    # Even though the order of intermediate plays differs, the final layout of tokens
    # (and thus the internal bitboard state) will be identical to `board1`.
    board2 = bb.Board()
    board2.play("31133331")

    # Boards with identical configurations produce the same hash value.
    # This allows them to be used efficiently as keys in dictionaries or members of sets.
    assert hash(board1) == hash(board2)

    # Display the board's hash value.
    hash(board1)
    ```
    Expected output:
    ```text
    971238920548618160
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00645">645</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="af95a367c9b9e977c07ee89189f1e6087" name="af95a367c9b9e977c07ee89189f1e6087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95a367c9b9e977c07ee89189f1e6087">&#9670;&#160;</a></span>__ne__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool bitbully.board.Board.__ne__ </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks inequality between two Board instances.

See the documentation for [Board.__eq__][src.bitbully.board.Board.__eq__] for details.

Args:
    value (object): The other Board instance to compare against.

Returns:
    bool: True if both boards are not equal, False otherwise.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00283">283</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="a685b273338fc40f86ce851d01632aeaf" name="a685b273338fc40f86ce851d01632aeaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685b273338fc40f86ce851d01632aeaf">&#9670;&#160;</a></span>__repr__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str bitbully.board.Board.__repr__ </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a string representation of the Board instance.</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00296">296</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="ad9a2dd40b4217e8d4f3aac392444f79e" name="ad9a2dd40b4217e8d4f3aac392444f79e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a2dd40b4217e8d4f3aac392444f79e">&#9670;&#160;</a></span>__str__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str bitbully.board.Board.__str__ </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a human-readable ASCII representation (same as to_string()).

See the documentation for [Board.to_string][src.bitbully.board.Board.to_string] for details.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00300">300</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="a42903f41f41e423c133fd9ed842d2ed8" name="a42903f41f41e423c133fd9ed842d2ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42903f41f41e423c133fd9ed842d2ed8">&#9670;&#160;</a></span>all_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[<a class="el" href="../../d9/d83/classbitbully_1_1board_1_1Board.html">Board</a>] bitbully.board.Board.all_positions </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>up_to_n_ply</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>exactly_n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find all positions reachable from the current position up to a given ply.

This is a high-level wrapper around
`bitbully_core.BoardCore.allPositions`.

Starting from the **current** board, it generates all positions that can be
reached by playing additional moves such that the resulting position has:

- At most ``up_to_n_ply`` tokens on the board, if ``exactly_n`` is ``False``.
- Exactly ``up_to_n_ply`` tokens on the board, if ``exactly_n`` is ``True``.

Note:
    The number of tokens already present in the current position is taken
    into account. If ``up_to_n_ply`` is smaller than
    ``self.count_tokens()``, the result is typically empty.

    This function can grow combinatorially with ``up_to_n_ply`` and the
    current position, so use it with care for large depths.

Args:
    up_to_n_ply (int):
        The maximum total number of tokens (ply) for generated positions.
        Must be between 0 and 42 (inclusive).
    exactly_n (bool):
        If ``True``, only positions with exactly ``up_to_n_ply`` tokens
        are returned. If ``False``, all positions with a token count
        between the current number of tokens and ``up_to_n_ply`` are
        included.

Returns:
    list[Board]: A list of :class:`Board` instances representing all
    reachable positions that satisfy the ply constraint.

Raises:
    ValueError: If ``up_to_n_ply`` is outside the range ``[0, 42]``.

Example:
    Compute all positions at exactly 3 ply from the empty board:

    ```python
    import bitbully as bb

    # Start from an empty board.
    board = bb.Board()

    # Generate all positions that contain exactly 3 tokens.
    positions = board.all_positions(3, exactly_n=True)

    # According to OEIS A212693, there are exactly 238 distinct
    # reachable positions with 3 played moves in standard Connect-4.
    assert len(positions) == 238
    ```

    Reference:
        - Number of distinct positions at ply *n*:
          https://oeis.org/A212693
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00307">307</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="a9514b7e3caa5c5d7c3bedd0268865fc1" name="a9514b7e3caa5c5d7c3bedd0268865fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9514b7e3caa5c5d7c3bedd0268865fc1">&#9670;&#160;</a></span>can_win_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool bitbully.board.Board.can_win_next </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None </td>          <td class="paramname"><span class="paramname"><em>move</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks if the current player can win in the next move.

Args:
    move (int | None): Optional column to check for an immediate win. If None, checks all columns.

Returns:
    bool: True if the current player can win next, False otherwise.

See also: [`Board.has_win`][src.bitbully.board.Board.has_win].

Example:
    ```python
    import bitbully as bb

    # Create a board from a move string.
    # The string "332311" represents a short sequence of alternating moves
    # that results in a nearly winning position for Player 1 (yellow, X).
    board = bb.Board("332311")

    # Display the current board state (see below)
    print(board)

    # Player 1 (yellow, X) — who is next to move — can win immediately
    # by placing a token in either column 0 or column 4.
    assert board.can_win_next(0)
    assert board.can_win_next(4)

    # However, playing in other columns does not result in an instant win.
    assert not board.can_win_next(2)
    assert not board.can_win_next(3)

    # You can also call `can_win_next()` without arguments to perform a general check.
    # It returns True if the current player has *any* winning move available.
    assert board.can_win_next()
    ```
    The board we created above looks like this:
    ```text
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  O  _  _  _
    _  O  _  O  _  _  _
    _  X  X  X  _  _  _
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00381">381</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="a0babec5f817efa063b5e89e035d79b4e" name="a0babec5f817efa063b5e89e035d79b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0babec5f817efa063b5e89e035d79b4e">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../d9/d83/classbitbully_1_1board_1_1Board.html">Board</a> bitbully.board.Board.copy </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a copy of the current Board instance.

The `copy()` method returns a new `Board` object that represents the
*same position* as the original at the time of copying. Subsequent
changes to one board do **not** affect the other — they are completely
independent.

Returns:
    Board: A new Board instance that is a copy of the current one.

Example:
    Create a board, copy it, and verify that both represent the same position:
    ```python
    import bitbully as bb

    # Create a board from a compact move string.
    board = bb.Board("33333111")

    # Create an independent copy of the current position.
    board_copy = board.copy()

    # Both boards represent the same position and are considered equal.
    assert board == board_copy
    assert hash(board) == hash(board_copy)
    assert board.to_string() == board_copy.to_string()

    # Display the board state.
    print(board)
    ```
    Expected output (both boards print the same position):
    ```text
    _  _  _  _  _  _  _
    _  _  _  X  _  _  _
    _  _  _  O  _  _  _
    _  O  _  X  _  _  _
    _  X  _  O  _  _  _
    _  O  _  X  _  _  _
    ```

Example:
    Modifying the copy does not affect the original:
    ```python
    import bitbully as bb

    board = bb.Board("33333111")

    # Create a copy of the current position.
    board_copy = board.copy()

    # Play an additional move on the copied board only.
    assert board_copy.play(0)  # Drop a token into the leftmost column.

    # Now the boards represent different positions.
    assert board != board_copy

    # The original board remains unchanged.
    print("Original:")
    print(board)

    print("Modified copy:")
    print(board_copy)
    ```
    Expected output:
    ```text
    Original:

    _  _  _  _  _  _  _
    _  _  _  X  _  _  _
    _  _  _  O  _  _  _
    _  O  _  X  _  _  _
    _  X  _  O  _  _  _
    _  O  _  X  _  _  _

    Modified copy:

    _  _  _  _  _  _  _
    _  _  _  X  _  _  _
    _  _  _  O  _  _  _
    _  O  _  X  _  _  _
    _  X  _  O  _  _  _
    X  O  _  X  _  _  _
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00431">431</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="a357ea549197e657a8ea52dcca863b039" name="a357ea549197e657a8ea52dcca863b039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357ea549197e657a8ea52dcca863b039">&#9670;&#160;</a></span>count_tokens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int bitbully.board.Board.count_tokens </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Counts the total number of tokens currently placed on the board.

This method simply returns how many moves have been played so far in the
current position — that is, the number of occupied cells on the 7x6 grid.

It does **not** distinguish between players; it only reports the total
number of tokens, regardless of whether they belong to Player 1 or Player 2.

Returns:
    int: The total number of tokens on the board (between 0 and 42).

Example:
    Count tokens on an empty board:
    ```python
    import bitbully as bb

    board = bb.Board()  # No moves played yet.
    assert board.count_tokens() == 0

    # The board is completely empty.
    print(board)
    ```
    Expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    ```

Example:
    Count tokens after a few moves:
    ```python
    import bitbully as bb

    # Play three moves in the center column (index 3).
    board = bb.Board()
    assert board.play([3, 3, 3])

    # Three tokens have been placed on the board.
    assert board.count_tokens() == 3

    print(board)
    ```
    Expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  X  _  _  _
    _  _  _  O  _  _  _
    _  _  _  X  _  _  _
    ```

Example:
    Relation to the length of a move sequence:
    ```python
    import bitbully as bb

    moves = "33333111"  # 8 moves in total
    board = bb.Board(moves)

    # The number of tokens on the board always matches
    # the number of moves that have been played.
    # (as long as the input was valid)
    assert board.count_tokens() == len(moves)
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00519">519</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="a034cd0819f00709bcaa40520c0972098" name="a034cd0819f00709bcaa40520c0972098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034cd0819f00709bcaa40520c0972098">&#9670;&#160;</a></span>current_player()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int bitbully.board.Board.current_player </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the player whose turn it is to move.

The current player is derived from the **parity** of the number of tokens
on the board:

- Player 1 (yellow, ``X``) moves first on an empty board.
- After an even number of moves → it is Player 1's turn.
- After an odd  number of moves → it is Player 2's turn.

Returns:
    int:
        The player to move:

        - ``1`` → Player 1 (yellow, ``X``)
        - ``2`` → Player 2 (red, ``O``)

Example:
    ```python
    import bitbully as bb

    # Empty board → Player 1 starts.
    board = bb.Board()
    assert board.current_player() == 1
    assert board.count_tokens() == 0

    # After one move, it's Player 2's turn.
    assert board.play(3)
    assert board.count_tokens() == 1
    assert board.current_player() == 2

    # After a second move, it's again Player 1's turn.
    assert board.play(4)
    assert board.count_tokens() == 2
    assert board.current_player() == 1
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l01384">1384</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="a04cf3920d1f460872b42d77c538a3423" name="a04cf3920d1f460872b42d77c538a3423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cf3920d1f460872b42d77c538a3423">&#9670;&#160;</a></span>from_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../d9/d83/classbitbully_1_1board_1_1Board.html">Board</a> bitbully.board.Board.from_array </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>cls</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[Sequence[int]]</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a board directly from a 2D array representation.

This is a convenience wrapper around the main constructor [board.Board][src.bitbully.board.Board]
and accepts the same array formats:

- **Row-major**: 6 x 7 (``[row][column]``), top row first.
- **Column-major**: 7 x 6 (``[column][row]``), left column first.

Values must follow the usual convention:

- ``0`` → empty cell
- ``1`` → Player 1 token (yellow, ``X``)
- ``2`` → Player 2 token (red, ``O``)

Args:
    arr (Sequence[Sequence[int]]):
        A 2D array describing the board state, either in row-major or
        column-major layout. See the examples in
        [Board][src.bitbully.board.Board] for details.

Returns:
    Board:
        A new `Board` instance representing the given layout.

Example:
    Using a 6 x 7 row-major layout:
    ```python
    import bitbully as bb

    board_array = [
        [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)
        [0, 0, 0, 1, 0, 0, 0],  # Row 4
        [0, 0, 0, 2, 0, 0, 0],  # Row 3
        [0, 2, 0, 1, 0, 0, 0],  # Row 2
        [0, 1, 0, 2, 0, 0, 0],  # Row 1
        [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom)
    ]

    board = bb.Board.from_array(board_array)
    print(board)
    ```

Example:
    Using a 7 x 6 column-major layout:
    ```python
    import bitbully as bb

    board_array = [
        [0, 0, 0, 0, 0, 0],  # Column 0
        [2, 1, 2, 1, 0, 0],  # Column 1
        [0, 0, 0, 0, 0, 0],  # Column 2
        [1, 2, 1, 2, 1, 0],  # Column 3
        [0, 0, 0, 0, 0, 0],  # Column 4
        [2, 1, 2, 0, 0, 0],  # Column 5
        [0, 0, 0, 0, 0, 0],  # Column 6
    ]

    board = bb.Board.from_array(board_array)

    # Round-trip via to_array:
    assert board.to_array() == board_array
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l01605">1605</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="a9b97a7ced0bf0ed804d120478f57f257" name="a9b97a7ced0bf0ed804d120478f57f257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b97a7ced0bf0ed804d120478f57f257">&#9670;&#160;</a></span>from_moves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../d9/d83/classbitbully_1_1board_1_1Board.html">Board</a> bitbully.board.Board.from_moves </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>cls</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[int] | str</td>          <td class="paramname"><span class="paramname"><em>moves</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a board by replaying a sequence of moves from the empty position.

This is a convenience constructor around [Board.play][src.bitbully.board.Board.play].
It starts from an empty board and applies the given move sequence, assuming
it is **legal** (no out-of-range columns, no moves in full columns, etc.).

Args:
    moves (Sequence[int] | str):
        The move sequence to replay from the starting position. Accepts:

        - A sequence of integers (e.g. ``[3, 3, 3, 1]``)
        - A string of digits (e.g. ``"3331"``)

        Each value represents a column index (0-6). Players alternate
        automatically between moves.

Returns:
    Board:
        A new `Board` instance representing the final position
        after all moves have been applied.

Example:
    ```python
    import bitbully as bb

    # Create a position directly from a compact move string.
    board = bb.Board.from_moves("33333111")

    # Equivalent to:
    # board = bb.Board()
    # assert board.play("33333111")

    print(board)
    assert board.count_tokens() == 8
    assert not board.has_win()
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l01562">1562</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="ae50b3749d5857b53f6d8d7fed35b3bf7" name="ae50b3749d5857b53f6d8d7fed35b3bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50b3749d5857b53f6d8d7fed35b3bf7">&#9670;&#160;</a></span>has_win()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool bitbully.board.Board.has_win </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks if the current player has a winning position.

Returns:
    bool: True if the current player has a winning position (4-in-a-row), False otherwise.

Unlike `can_win_next()`, which checks whether the current player *could* win
on their next move, the `has_win()` method determines whether a winning
condition already exists on the board.
This method is typically used right after a move to verify whether the game
has been won.

See also: [`Board.can_win_next`][src.bitbully.board.Board.can_win_next].

Example:
    ```python
    import bitbully as bb

    # Initialize a board from a move sequence.
    # The string "332311" represents a position where Player 1 (yellow, X)
    # is one move away from winning.
    board = bb.Board("332311")

    # At this stage, Player 1 has not yet won, but can win immediately
    # by placing a token in either column 0 or column 4.
    assert not board.has_win()
    assert board.can_win_next(0)  # Check column 0
    assert board.can_win_next(4)  # Check column 4
    assert board.can_win_next()  # General check (any winning move)

    # Simulate Player 1 playing in column 4 — this completes
    # a horizontal line of four tokens and wins the game.
    assert board.play(4)

    # Display the updated board to visualize the winning position.
    print(board)

    # The board now contains a winning configuration:
    # Player 1 (yellow, X) has achieved a Connect-4.
    assert board.has_win()
    ```
    Board from above, expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  O  _  _  _
    _  O  _  O  _  _  _
    _  X  X  X  X  _  _
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00592">592</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="a1f0472df8447db26820d7dd99ffe2bab" name="a1f0472df8447db26820d7dd99ffe2bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0472df8447db26820d7dd99ffe2bab">&#9670;&#160;</a></span>is_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool bitbully.board.Board.is_full </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks whether the board has any empty cells left.

A Connect Four board has 42 cells in total (7 columns x 6 rows).
This method returns ``True`` if **all** cells are occupied, i.e.
when  [Board.moves_left][src.bitbully.board.Board.moves_left] returns ``0``.

Returns:
    bool:
        ``True`` if the board is completely full
        (no more legal moves possible), otherwise ``False``.

Example:
    ```python
    import bitbully as bb

    board = bb.Board()
    assert not board.is_full()
    assert board.moves_left() == 42
    assert board.count_tokens() == 0

    # Fill the board column by column.
    for _ in range(6):
        assert board.play("0123456")  # one token per column, per row

    # Now every cell is occupied.
    assert board.is_full()
    assert board.moves_left() == 0
    assert board.count_tokens() == 42
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l01424">1424</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="aad6d6426114ac320acf00f17f8291d0d" name="aad6d6426114ac320acf00f17f8291d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6d6426114ac320acf00f17f8291d0d">&#9670;&#160;</a></span>is_game_over()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool bitbully.board.Board.is_game_over </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks whether the game has ended (win or draw).

A game of Connect Four is considered **over** if:

- One of the players has a winning position
  (see [Board.has_win][src.bitbully.board.Board.has_win]), **or**
- The board is completely full and no further moves can be played
  (see [Board.is_full][src.bitbully.board.Board.is_full]).

This method does **not** indicate *who* won; for that, use
[Board.winner][src.bitbully.board.Board.winner].

Returns:
    bool:
        ``True`` if the game is over (win or draw), otherwise ``False``.

Example:
    Game over by a win:
    ```python
    import bitbully as bb

    # Player 1 (X) wins horizontally on the bottom row.
    board = bb.Board()
    assert board.play("0101010")

    assert board.has_win()
    assert board.is_game_over()
    assert board.winner() == 1
    ```

Example:
    Game over by a draw (full board, no winner):
    ```python
    import bitbully as bb

    board, _ = bb.Board.random_board(42, forbid_direct_win=False)

    assert board.is_full()
    assert not board.has_win()
    assert board.is_game_over()
    assert board.winner() is None
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l01457">1457</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="af0547d9a280ddeaebe6bf563c8a0617a" name="af0547d9a280ddeaebe6bf563c8a0617a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0547d9a280ddeaebe6bf563c8a0617a">&#9670;&#160;</a></span>is_legal_move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool bitbully.board.Board.is_legal_move </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>move</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks if a move (column) is legal in the current position.

A move is considered *legal* if:

- The column index is within the valid range (0-6), **and**
- The column is **not full** (i.e. it still has at least one empty cell).

This method does **not** check for tactical consequences such as
leaving an immediate win to the opponent, nor does it stop being
usable once a player has already won. It purely validates whether a
token can be dropped into the given column according to the basic
rules of Connect Four. You have to check for wins separately using
[Board.has_win][src.bitbully.board.Board.has_win].


Args:
    move (int): The column index (0-6) to check.

Returns:
    bool: True if the move is legal, False otherwise.

Example:
    All moves are legal on an empty board:
    ```python
    import bitbully as bb

    board = bb.Board()  # Empty 7x6 board

    # Every column index from 0 to 6 is a valid move.
    for col in range(7):
        assert board.is_legal_move(col)

    # Out-of-range indices are always illegal.
    assert not board.is_legal_move(-1)
    assert not board.is_legal_move(7)
    ```

Example:
    Detecting an illegal move in a full column:
    ```python
    import bitbully as bb

    # Fill the center column (index 3) with six tokens.
    board = bb.Board()
    assert board.play([3, 3, 3, 3, 3, 3])

    # The center column is now full, so another move in column 3 is illegal.
    assert not board.is_legal_move(3)

    # Other columns are still available (as long as they are not full).
    assert board.is_legal_move(0)
    assert board.is_legal_move(6)

    print(board)
    ```
    Expected output:
    ```text
    _  _  _  O  _  _  _
    _  _  _  X  _  _  _
    _  _  _  O  _  _  _
    _  _  _  X  _  _  _
    _  _  _  O  _  _  _
    _  _  _  X  _  _  _
    ```

Example:
    This function only checks legality, not for situations where a player has won:
    ```python
    import bitbully as bb

    # Player 1 (yellow, X) wins  the game.
    board = bb.Board()
    assert board.play("1122334")

    # Even though Player 1 has already won, moves in non-full columns are still legal.
    for col in range(7):
        assert board.is_legal_move(col)

    print(board)
    ```
    Expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  O  O  O  _  _  _
    _  X  X  X  X  _  _
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00679">679</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="afe754d7343ddc9c2b4596ec2c5eea43a" name="afe754d7343ddc9c2b4596ec2c5eea43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe754d7343ddc9c2b4596ec2c5eea43a">&#9670;&#160;</a></span>legal_moves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[int] bitbully.board.Board.legal_moves </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>non_losing</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>order_moves</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a list of all legal moves (non-full columns) for the current board state.

Args:
    non_losing (bool):
        If ``True``, only returns moves that do **not** allow the opponent
        to win immediately on their next turn. The list might be empty
        If ``False``, all legal moves are returned.
    order_moves (bool):
        If ``True``, the returned list is ordered to prioritize moves (potentially more promising first).

Returns:
    list[int]: A list of column indices (0-6) where a token can be legally dropped.

Example:
    ```python
    import bitbully as bb

    board = bb.Board()
    legal_moves = board.legal_moves()
    assert set(legal_moves) == set(range(7))  # All columns are initially legal
    assert set(legal_moves) == set(board.legal_moves(order_moves=True))
    board.legal_moves(order_moves=True) == [3, 2, 4, 1, 5, 0, 6]  # Center column prioritized
    ```

Example:
    ```python
    import bitbully as bb

    board = bb.Board()
    board.play("3322314")
    print(board)
    assert board.legal_moves() == list(range(7))
    assert board.legal_moves(non_losing=True) == [5]
    ```
Expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  X  _  _  _
    _  _  O  O  _  _  _
    _  O  X  X  X  _  _
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l01813">1813</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="aa90638e1d8ff88b5eaedef40b6a6e30e" name="aa90638e1d8ff88b5eaedef40b6a6e30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90638e1d8ff88b5eaedef40b6a6e30e">&#9670;&#160;</a></span>mirror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../d9/d83/classbitbully_1_1board_1_1Board.html">Board</a> bitbully.board.Board.mirror </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a new Board instance that is the mirror image of the current board.

This method reflects the board **horizontally** around its vertical center column:
- Column 0 &lt;-&gt; Column 6
- Column 1 &lt;-&gt; Column 5
- Column 2 &lt;-&gt; Column 4
- Column 3 stays in the center

The player to move is not changed - only the spatial
arrangement of the tokens is mirrored. The original board remains unchanged;
`mirror()` always returns a **new** `Board` instance.

Returns:
    Board: A new Board instance that is the mirror image of the current one.

Example:
    Mirroring a simple asymmetric position:
    ```python
    import bitbully as bb

    # Play four moves along the bottom row.
    board = bb.Board()
    assert board.play("0123")  # Columns: 0, 1, 2, 3

    # Create a mirrored copy of the board.
    mirrored = board.mirror()

    print("Original:")
    print(board)

    print("Mirrored:")
    print(mirrored)
    ```

    Expected output:
    ```text
    Original:

    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    X  O  X  O  _  _  _

    Mirrored:

    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  O  X  O  X
    ```

Example:
    Mirroring a position that is already symmetric:
    ```python
    import bitbully as bb

    # Central symmetry: one token in each outer column and in the center.
    board = bb.Board([1, 3, 5])

    mirrored = board.mirror()

    # The mirrored position is identical to the original.
    assert board == mirrored
    assert hash(board) == hash(mirrored)

    print(board)
    ```
     Expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  X  _  O  _  X  _
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00772">772</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="aed729a7efcbf07f00e2a8773b875291d" name="aed729a7efcbf07f00e2a8773b875291d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed729a7efcbf07f00e2a8773b875291d">&#9670;&#160;</a></span>moves_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int bitbully.board.Board.moves_left </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the number of moves left until the board is full.

This is simply the number of *empty* cells remaining on the 7x6 grid.
On an empty board there are 42 free cells, so:

- At the start of the game: `moves_left() == 42`
- After `n` valid moves: `moves_left() == 42 - n`
- On a completely full board: `moves_left() == 0`

This method is equivalent to:
```
42 - board.count_tokens()
```
but implemented efficiently in the underlying C++ core.

Returns:
    int: The number of moves left (0-42).

Example:
    Moves left on an empty board:
    ```python
    import bitbully as bb

    board = bb.Board()  # No tokens placed yet.
    assert board.moves_left() == 42
    assert board.count_tokens() == 0
    ```

Example:
    Relation to the number of moves played:
    ```python
    import bitbully as bb

    # Play five moves in various columns.
    moves = [3, 3, 1, 4, 6]
    board = bb.Board()
    assert board.play(moves)

    # Five tokens have been placed, so 42 - 5 = 37 moves remain.
    assert board.count_tokens() == 5
    assert board.moves_left() == 37
    assert board.moves_left() + board.count_tokens() == 42
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00858">858</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="ac703e9fec40c4d9c60c314b33eb44bbd" name="ac703e9fec40c4d9c60c314b33eb44bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac703e9fec40c4d9c60c314b33eb44bbd">&#9670;&#160;</a></span>play()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool bitbully.board.Board.play </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | Sequence[int] | str</td>          <td class="paramname"><span class="paramname"><em>move</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Plays one or more moves for the current player.

The method updates the internal board state by dropping tokens
into the specified columns. Input can be:
- a single integer (column index 0 to 6),
- an iterable sequence of integers (e.g., `[3, 1, 3]` or `range(7)`),
- or a string of digits (e.g., `"33333111"`) representing the move order.

Args:
    move (int | Sequence[int] | str):
        The column index or sequence of column indices where tokens should be placed.

Returns:
    bool: True if the move was played successfully, False if the move was illegal.


Example:
    Play a sequence of moves into the center column (column index 3):
    ```python
    import bitbully as bb

    board = bb.Board()
    assert board.play([3, 3, 3])  # returns True on successful move
    board
    ```

    Expected output:

    ```
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  X  _  _  _
    _  _  _  O  _  _  _
    _  _  _  X  _  _  _
    ```

Example:
    Play a sequence of moves across all columns:
    ```python
    import bitbully as bb

    board = bb.Board()
    assert board.play(range(7))  # returns True on successful move
    board
    ```
    Expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    X  O  X  O  X  O  X
    ```

Example:
    Play a sequence using a string:
    ```python
    import bitbully as bb

    board = bb.Board()
    assert board.play("33333111")  # returns True on successful move
    board
    ```
    Expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  X  _  _  _
    _  _  _  O  _  _  _
    _  O  _  X  _  _  _
    _  X  _  O  _  _  _
    _  O  _  X  _  _  _
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00905">905</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="a0c4555d1cb4a50484294b8452b4f02a9" name="a0c4555d1cb4a50484294b8452b4f02a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4555d1cb4a50484294b8452b4f02a9">&#9670;&#160;</a></span>play_on_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../d9/d83/classbitbully_1_1board_1_1Board.html">Board</a> bitbully.board.Board.play_on_copy </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>move</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a new board with the given move applied, leaving the current board unchanged.

Args:
    move (int):
        The column index (0-6) in which to play the move.

Returns:
    Board:
        A new Board instance representing the position after the move.

Raises:
    ValueError: If the move is illegal (e.g. column is full or out of range).

Example:
    ```python
    import bitbully as bb

    board = bb.Board("333")  # Some existing position
    new_board = board.play_on_copy(4)

    # The original board is unchanged.
    assert board.count_tokens() == 3

    # The returned board includes the new move.
    assert new_board.count_tokens() == 4
    assert new_board != board
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00993">993</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="ad2a69d01c5b7e9f77041180f58355ae8" name="ad2a69d01c5b7e9f77041180f58355ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a69d01c5b7e9f77041180f58355ae8">&#9670;&#160;</a></span>random_board()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[<a class="el" href="../../d9/d83/classbitbully_1_1board_1_1Board.html">Board</a>, list[int]] bitbully.board.Board.random_board </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n_ply</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>forbid_direct_win</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Generates a random board state by playing a specified number of random moves.

If ``forbid_direct_win`` is ``True``, the generated position is guaranteed
**not** to contain an immediate winning move for the player to move.

Args:
    n_ply (int):
        Number of random moves to simulate (0-42).
    forbid_direct_win (bool):
        If ``True``, ensures the resulting board has **no immediate winning move**.

Returns:
    tuple[Board, list[int]]:
        A pair ``(board, moves)`` where ``board`` is the generated position
        and ``moves`` are the exact random moves performed.

Raises:
    ValueError: If `n_ply` is outside the valid range [0, 42].

Example:
    Basic usage:
    ```python
    import bitbully as bb

    board, moves = bb.Board.random_board(10, forbid_direct_win=True)

    print("Moves:", moves)
    print("Board:")
    print(board)

    # The move list must match the requested ply.
    assert len(moves) == 10

    # No immediate winning move when forbid_direct_win=True.
    assert not board.can_win_next()
    ```

Example:
    Using random boards in tests or simulations:
    ```python
    import bitbully as bb

    # Generate 50 random 10-ply positions.
    for _ in range(50):
        board, moves = bb.Board.random_board(10, forbid_direct_win=True)
        assert len(moves) == 10
        assert not board.has_win()  # Game should not be over
        assert board.count_tokens() == 10  # All generated boards contain exactly 10 tokens
        assert not board.can_win_next()  # Since `forbid_direct_win=True`, no immediate threat
    ```

Example:
    Reconstructing the board manually from the move list:
    ```python
    import bitbully as bb

    b1, moves = bb.Board.random_board(8, forbid_direct_win=True)

    # Recreate the board using the move sequence:
    b2 = bb.Board(moves)

    assert b1 == b2
    assert b1.to_string() == b2.to_string()
    assert b1.uid() == b2.uid()
    ```

Example:
    Ensure randomness by generating many distinct sequences:
    ```python
    import bitbully as bb

    seen = set()
    for _ in range(20):
        _, moves = bb.Board.random_board(5, False)
        seen.add(tuple(moves))

    # Very likely to see more than one unique sequence.
    assert len(seen) &gt; 1
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l01672">1672</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="a3ec7505932466440fce1a9fbbd54355a" name="a3ec7505932466440fce1a9fbbd54355a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec7505932466440fce1a9fbbd54355a">&#9670;&#160;</a></span>reset_board()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool bitbully.board.Board.reset_board </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[int] | Sequence[Sequence[int]] | str | None </td>          <td class="paramname"><span class="paramname"><em>board</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Resets the board or sets (overrides) the board to a specific state.

Args:
    board (Sequence[int] | Sequence[Sequence[int]] | str | None):
        The new board state. Accepts:
        - 2D array (list, tuple, numpy-array) with shape 7x6 or 6x7
        - 1D sequence of ints: a move sequence of columns (e.g., [0, 0, 2, 2, 3, 3])
        - String: A move sequence of columns as string (e.g., "002233...")
        - None: to reset to an empty board

Returns:
    bool: True if the board was set successfully, False otherwise.

Example:
    Reset the board to an empty state:
    ```python
    import bitbully as bb

    # Create a temporary board position from a move string.
    # The string "0123456" plays one token in each column (0-6) in sequence.
    board = bb.Board("0123456")

    # Reset the board to an empty state.
    # Calling `reset_board()` clears all tokens and restores the starting position.
    # No moves → an empty board.
    assert board.reset_board()
    board
    ```
    Expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    ```

Example:
    (Re-)Set the board using a move sequence string:
    ```python
    import bitbully as bb

    # This is just a temporary setup; it will be replaced below.
    board = bb.Board("0123456")

    # Set the board state directly from a move sequence.
    # The list [3, 3, 3] represents three consecutive moves in the center column (index 3).
    # Moves alternate automatically between Player 1 (yellow) and Player 2 (red).
    #
    # The `reset_board()` method clears the current position and replays the given moves
    # from an empty board — effectively overriding any existing board state.
    assert board.reset_board([3, 3, 3])

    # Display the updated board to verify the new position.
    board
    ```
    Expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  _  _  _  _
    _  _  _  X  _  _  _
    _  _  _  O  _  _  _
    _  _  _  X  _  _  _
    ```

Example:
    You can also set the board using other formats, such as a 2D array or a string.
    See the examples in the [Board][src.bitbully.board.Board] docstring for details.

    ```python
    # Briefly demonstrate the different input formats accepted by `reset_board()`.
    import bitbully as bb

    # Create an empty board instance
    board = bb.Board()

    # Variant 1: From a list of moves (integers)
    # Each number represents a column index (0-6); moves alternate between players.
    assert board.reset_board([3, 3, 3])

    # Variant 2: From a compact move string
    # Equivalent to the list above — useful for quick testing or serialization.
    assert board.reset_board("33333111")

    # Variant 3: From a 2D list in row-major format (6 x 7)
    # Each inner list represents a row (top to bottom).
    # 0 = empty, 1 = Player 1, 2 = Player 2.
    board_array = [
        [0, 0, 0, 0, 0, 0, 0],  # Row 5 (top)
        [0, 0, 0, 1, 0, 0, 0],  # Row 4
        [0, 0, 0, 2, 0, 0, 0],  # Row 3
        [0, 2, 0, 1, 0, 0, 0],  # Row 2
        [0, 1, 0, 2, 0, 0, 0],  # Row 1
        [0, 2, 0, 1, 0, 0, 0],  # Row 0 (bottom)
    ]
    assert board.reset_board(board_array)

    # Variant 4: From a 2D list in column-major format (7 x 6)
    # Each inner list represents a column (left to right); this matches BitBully's internal layout.
    board_array = [
        [0, 0, 0, 0, 0, 0],  # Column 0 (leftmost)
        [2, 1, 2, 1, 0, 0],  # Column 1
        [0, 0, 0, 0, 0, 0],  # Column 2
        [1, 2, 1, 2, 1, 0],  # Column 3 (center)
        [0, 0, 0, 0, 0, 0],  # Column 4
        [2, 1, 2, 0, 0, 0],  # Column 5
        [0, 0, 0, 0, 0, 0],  # Column 6 (rightmost)
    ]
    assert board.reset_board(board_array)

    # Display the final board state in text form
    board
    ```

    Expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  X  _  _  _
    _  X  _  O  _  _  _
    _  O  _  X  _  O  _
    _  X  _  O  _  X  _
    _  O  _  X  _  O  _
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l01034">1034</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="a936a2a08230396f27c72a75d53103282" name="a936a2a08230396f27c72a75d53103282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936a2a08230396f27c72a75d53103282">&#9670;&#160;</a></span>to_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[list[int]] bitbully.board.Board.to_array </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>column_major_layout</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the board state as a 2D array (list of lists).

This layout is convenient for printing, serialization, or converting
to a NumPy array for further analysis.

Args:
    column_major_layout (bool): Use column-major format if set to `True`,
        otherwise the row-major-layout is used.

Returns:
    list[list[int]]: A 7x6 2D list representing the board state.

Raises:
    NotImplementedError: If `column_major_layout` is set to `False`.

Example:
    === "Column-major Format:"

        The returned array is in **column-major** format with shape `7 x 6`
        (`[column][row]`):

        - There are 7 inner lists, one for each column of the board.
        - Each inner list has 6 integers, one for each row.
        - Row index `0` corresponds to the **bottom row**,
        row index `5` to the **top row**.
        - Convention:
        - `0` -&gt; empty cell
        - `1` -&gt; Player 1 token (yellow, X)
        - `2` -&gt; Player 2 token (red, O)

        ```python
        import bitbully as bb
        from pprint import pprint

        # Create a position from a move sequence.
        board = bb.Board("33333111")

        # Extract the board as a 2D list (rows x columns).
        arr = board.to_array()

        # Reconstruct the same position from the 2D array.
        board2 = bb.Board(arr)

        # Both boards represent the same position.
        assert board == board2
        assert board.to_array() == board2.to_array()

        # print ther result of `board.to_array()`:
        pprint(board.to_array())
        ```
        Expected output:
        ```text
        [[0, 0, 0, 0, 0, 0],
        [2, 1, 2, 0, 0, 0],
        [0, 0, 0, 0, 0, 0],
        [1, 2, 1, 2, 1, 0],
        [0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0]]
        ```

    === "Row-major Format:"

        ``` markdown
        TODO: This is not supported yet
        ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l01178">1178</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="a0631f7c4d3734f0bb0993501f67f617c" name="a0631f7c4d3734f0bb0993501f67f617c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0631f7c4d3734f0bb0993501f67f617c">&#9670;&#160;</a></span>to_huffman()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int bitbully.board.Board.to_huffman </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Encode the current board position into a Huffman-compressed byte sequence.

This is a high-level wrapper around
`bitbully_core.BoardCore.toHuffman`. The returned int encodes the
exact token layout **and** the side to move using the same format as
the BitBully opening databases.

The encoding is:

- Deterministic: the same position always yields the same byte sequence.
- Compact: suitable for storage (of positions with little number of tokens),
  or lookups in the BitBully database format.

Returns:
    int: A Huffman-compressed representation of the current board
    state.

Raises:
    NotImplementedError:
        If the position does not contain exactly 8 or 12 tokens, as the
          Huffman encoding is only defined for these cases.

Example:
    Encode a position and verify that equivalent positions have the
    same Huffman code:

    ```python
    import bitbully as bb

    # Two different move sequences leading to the same final position.
    b1 = bb.Board("01234444")
    b2 = bb.Board("44440123")

    h1 = b1.to_huffman()
    h2 = b2.to_huffman()

    # Huffman encoding is purely position-based.
    assert h1 == h2

    print(f"Huffman code: {h1}")
    ```
Expected output:
    ```text
    Huffman code: 10120112
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l01761">1761</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="a3db1df514e7c6d510f2188ceb7419aca" name="a3db1df514e7c6d510f2188ceb7419aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db1df514e7c6d510f2188ceb7419aca">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str bitbully.board.Board.to_string </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a human-readable ASCII representation of the board.

The returned string shows the **current board position** as a 6x7 grid,
laid out exactly as it would appear when you print a `Board` instance:

- 6 lines of text, one per row (top row first, bottom row last)
- 7 entries per row, separated by two spaces
- `_` represents an empty cell
- `X` represents a token from Player 1 (yellow)
- `O` represents a token from Player 2 (red)

This is useful when you want to explicitly capture the board as a string
(e.g., for logging, debugging, or embedding into error messages) instead
of relying on `print(board)` or `repr(board)`.

Returns:
    str: A multi-line ASCII string representing the board state.

Example:
    Using `to_string()` on an empty board:
    ```python
    import bitbully as bb

    board = bb.Board("33333111")

    s = board.to_string()
    print(s)
    ```

    Expected output:
    ```text
    _  _  _  _  _  _  _
    _  _  _  X  _  _  _
    _  _  _  O  _  _  _
    _  O  _  X  _  _  _
    _  X  _  O  _  _  _
    _  O  _  X  _  _  _
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l01252">1252</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="ad06cd5ac21f137de6b80c9b4f8f89d3b" name="ad06cd5ac21f137de6b80c9b4f8f89d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06cd5ac21f137de6b80c9b4f8f89d3b">&#9670;&#160;</a></span>uid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int bitbully.board.Board.uid </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a unique identifier for the current board state.

The UID is a deterministic integer computed from the internal bitboard
representation of the position. It is **stable**, **position-based**, and
uniquely tied to the exact token layout **and** the side to move.

Key properties:

- Boards with the **same** configuration (tokens + player to move) always
  produce the **same** UID.
- Any change to the board (e.g., after a legal move) will almost always
  result in a **different** UID.
- Copies of a board created via the copy constructor or `Board.copy()`
  naturally share the same UID as long as their states remain identical.

Unlike `__hash__()`, the UID is not optimized for hash-table dispersion.
For use in transposition tables, caching, or dictionary/set keys,
prefer `__hash__()` since it provides a higher-quality hash distribution.

Returns:
    int: A unique integer identifier for the board state.

Example:
    UID is an integer and not None:
    ```python
    import bitbully as bb

    board = bb.Board()
    u = board.uid()

    assert isinstance(u, int)
    # Empty board has a well-defined, stable UID.
    assert board.uid() == u
    ```

Example:
    UID changes when the position changes:
    ```python
    import bitbully as bb

    board = bb.Board()
    uid_before = board.uid()

    assert board.play(1)  # Make a move in column 1.

    uid_after = board.uid()
    assert uid_after != uid_before
    ```

Example:
    Copies share the same UID while they are identical:
    ```python
    import bitbully as bb

    board = bb.Board("0123")

    # Create an independent copy of the same position.
    board_copy = board.copy()

    assert board is not board_copy  # Different objects
    assert board == board_copy  # Same position
    assert board.uid() == board_copy.uid()  # Same UID

    # After modifying the copy, they diverge.
    assert board_copy.play(4)
    assert board != board_copy
    assert board.uid() != board_copy.uid()
    ```

Example:
    Different move sequences leading to the same position share the same UID:
    ```python
    import bitbully as bb

    board_1 = bb.Board("01234444")
    board_2 = bb.Board("44440123")

    assert board_1 is not board_2  # Different objects
    assert board_1 == board_2  # Same position
    assert board_1.uid() == board_2.uid()  # Same UID

    # After modifying the copy, they diverge.
    assert board_1.play(4)
    assert board_1 != board_2
    assert board_1.uid() != board_2.uid()
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l01294">1294</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="aa46e665bb5d315b9be74324bdeb36c3f" name="aa46e665bb5d315b9be74324bdeb36c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46e665bb5d315b9be74324bdeb36c3f">&#9670;&#160;</a></span>winner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int | None bitbully.board.Board.winner </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the winning player, if the game has been won.

This helper interprets the current board under the assumption that
[Board.has_win][src.bitbully.board.Board.has_win] indicates **the last move** created a
winning configuration. In that case, the winner is the *previous* player:

- If it is currently Player 1's turn, then Player 2 must have just won.
- If it is currently Player 2's turn, then Player 1 must have just won.

If there is no winner (i.e. [Board.has_win][src.bitbully.board.Board.has_win] is ``False``),
this method returns ``None``.

Returns:
    int | None:
        The winning player, or ``None`` if there is no winner.

        - ``1`` → Player 1 (yellow, ``X``)
        - ``2`` → Player 2 (red, ``O``)
        - ``None`` → No winner (game still ongoing or draw)

Example:
    Detecting a winner:
    ```python
    import bitbully as bb

    # Player 1 wins with a horizontal line at the bottom.
    board = bb.Board()
    assert board.play("1122334")

    assert board.has_win()
    assert board.is_game_over()

    # It is now Player 2's turn to move next...
    assert board.current_player() == 2

    # ...which implies Player 1 must be the winner.
    assert board.winner() == 1
    ```

Example:
    No winner yet:
    ```python
    import bitbully as bb

    board = bb.Board()
    assert board.play("112233")  # no connect-four yet

    assert not board.has_win()
    assert not board.is_game_over()
    assert board.winner() is None
    ```
</pre> 
<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l01503">1503</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="ad34abdcda492a98a5532c713d83f4f0b" name="ad34abdcda492a98a5532c713d83f4f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34abdcda492a98a5532c713d83f4f0b">&#9670;&#160;</a></span>_board</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bitbully.board.Board._board = bitbully_core.BoardCore()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00224">224</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="a1091ba72ad36a44683ce490d76726447" name="a1091ba72ad36a44683ce490d76726447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1091ba72ad36a44683ce490d76726447">&#9670;&#160;</a></span>N_COLUMNS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ClassVar bitbully.board.Board.N_COLUMNS = bitbully_core.N_COLUMNS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00015">15</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="aa729e1bd85ba1e8a4e1860b3bd6d5270" name="aa729e1bd85ba1e8a4e1860b3bd6d5270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa729e1bd85ba1e8a4e1860b3bd6d5270">&#9670;&#160;</a></span>N_ROWS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ClassVar bitbully.board.Board.N_ROWS = bitbully_core.N_ROWS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00016">16</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<a id="a6600d819beec87b6cc78c3a90966170c" name="a6600d819beec87b6cc78c3a90966170c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6600d819beec87b6cc78c3a90966170c">&#9670;&#160;</a></span>Player</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bitbully.board.Board.Player = bitbully_core.Player</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../df/d85/board_8py_source.html#l00018">18</a> of file <a class="el" href="../../df/d85/board_8py_source.html">board.py</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/bitbully/<a class="el" href="../../df/d85/board_8py_source.html">board.py</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="../../d4/dde/namespacebitbully.html">bitbully</a></li><li class="navelem"><a href="../../d5/d0e/namespacebitbully_1_1board.html">board</a></li><li class="navelem"><a href="../../d9/d83/classbitbully_1_1board_1_1Board.html">Board</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
